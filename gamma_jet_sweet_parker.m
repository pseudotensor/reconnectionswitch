(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)






 AutoGeneratedPackage->Button[Automatic, Inherited, BaseStyle -> "Link", ButtonData -> "paclet:ref/Automatic"]


InitializationCell->True


(* IF ADD NEW CELLS, MUST MAKE THEM INITIALZATION CELL BY GOING TO CELL->CELL PROPERTIES->INITIALZATION CELL *)


(* Setup inflow conditions *)
setupsplocalrun:=Module[
{foo},
eff2global=1;
guidefactorglobal=0;
whichaccuracy=14;
whichprecision=14;
Clear[By,c,L,eta,rhoin,iein,gam,dzsp,whichvel,nonrel];
(*constssprel={By->1,c->1,L->1,eta->10^(-10),rhoin->10^(-5),iein->0,gam->5/3,dzsp->1};*)
(* Didn't hurt solver to have By=constant/gamx *)
bx0=1;
setupspjetclearall;
constssprel={Bzin->guidefactor*By,By->bx0/gamx,c->1,L->1,eta->10^(-10),rhoin->10^(-5),iein->0,gam->5/3,dzsp->1};
bgauss=By//.consts;
Lpnum=L//.consts;
etatotal=eta//.consts;
rhobvalue=rhoin//.consts;
UginfixedT=iein//.consts;
PginfixedT=(gam-1)*pin//.consts;
workprec=500;
maxiter=5000;
(* with guide field stuff there are 10 unknowns *)
numunknowns=10;
];
setupspjetrun:=Module[
{foo},
whichaccuracy=14;
whichprecision=14;
(* gamma_jet _wrapper.nb sets these *)
(* Jet solution is in HL units, while this file is all in Gaussian units *)
(* gamma=4/3 is approximate -- otherwise can fix p,u and iterate over this -- would be crazy to use P (T),U (T) internally here *)
(* gamx here is variable so far, but may need to iterate on it or something *)
(* Didn't hurt solver to have By=constant/gamx *)
setupspjetclearall;
(* with guide field stuff there are 10 unknowns *)
numunknowns=10;
setupspversion1;
(*setupspversion2;*)
workprec=500;
maxiter=5000;
constssprel=SetPrecision[constssprel,workprec];
eqieunits=SetPrecision[Evaluate[rhobunits*c^2/L^3]//.constssprel,workprec];
eqBunits=SetPrecision[Evaluate[Sqrt[eqieunits]]//.constssprel,workprec];
eqrhobunits=SetPrecision[Evaluate[eqieunits/c^2]//.constssprel,workprec];
eqetaunits=SetPrecision[Evaluate[c*L]//.constssprel,workprec];
];


setupspversion1:=Module[{foo},
(*constssprel={By->bgauss/gamx,L->Lpnum,eta->etatotal,rhoin->rhobvalue*c^2,iein->UginfixedT,gam->4/3,dzsp->1};*)
Munits=Evaluate[rhobvalue*Lpnum^3];
ieunits=Evaluate[rhobvalue*c^2];
Bunits=Evaluate[Sqrt[ieunits]];
rhobunits=Evaluate[ieunits/c^2];
etaunits=Evaluate[c*Lpnum];
Lunits=Evaluate[Lpnum];
(* and make rho into energy density units *)
(* unitslist should have numunknown items *)
unitslist=Evaluate[{Lpnum,c,rhobunits,ieunits,rhobunits,ieunits,Bunits,c,Bunits,Bunits}];
(* FindRoot works best with mostly similar values, so have c=1 *)
(* for compatibility and ease, don't put c into constssprel *)
c=1;
constssprel={Bzin->guidefactor*By,By->(bgauss/gamx)/Bunits,L->1,eta->etatotal/etaunits,rhoin->rhobvalue/rhobunits,iein->UginfixedT/ieunits,gam->4/3,dzsp->1};
 (* for now *)
PginfixedT=0;
];
setupspversion2:=Module[{foo},
Munits=1;
ieunits=1;
Bunits=1;
rhobunits=1;
etaunits=1;
Lunits=1;
unitslist=Table[1,{ii,1,numunknowns}];
constssprel={Bzin->guidefactor*By,By->(bgauss/gamx),L->Lpnum,eta->etatotal,rhoin->rhobvalue,iein->UginfixedT,gam->4/3,dzsp->1};
 (* for now *)
PginfixedT=0;
];


setupspjetclearall:=Module[
{foo},
(* below required for non-rel setup since otherwise gamx gets set as for rel version when back here *)
(* for now only actually required for gamx *)
Clear[ieout,iec];
Clear[rhoout,rhoc];
Clear[vx,vy,ux,uy,gamx,gamy,whichvx,whichvy];
Clear[bsqcent,by,By,bx,Bx,bzin,bzout,bsqin,bsqout,Bzc];
Clear[gam];
];


setupsprelinputs:=Module[
{foo},
myfun[x_]:=x;
Clear[ieout,iec];
Clear[rhoout,rhoc];

(* whichvel=3;*)
whichvel=4; 
(* factoreq6 controls compressibility through layer, but only important for non-ideal EOS *)
factoreq6=1;
(* eff1 is eff in paper -- NO LONGER CHANGE from exactly 1 *)
eff1=1;

(* now eff2 and guidefactor are set outside as calling terms *)
eff2=eff2global;
(* strength of guide field relative to ingoing field that generates current*)
(* can be -infinity .. infinity *)
guidefactor=guidefactorglobal;

Afactor=Afactorglobal;

(* ensure precision *)
factoreq6=SetPrecision[factoreq6,workprec];
eff2=SetPrecision[eff2,workprec];
eff1=SetPrecision[eff1,workprec];
guidefactor=SetPrecision[guidefactor,workprec];
Afactor=SetPrecision[Afactor,workprec];

pin=(gam-1)*iein;
pcent=(gam-1)*iec;
pout=(gam-1)*ieout;
];



setupsprelvelocity[nonrelsprel0_]:=Module[
{foo,nonrelsprel=nonrelsprel0},
Clear[vx,vy,ux,uy,gamx,gamy,whichvx,whichvy];
(*3-velocity*)
If[whichvel==3,
(* relativistic *)
If[nonrelsprel==0,
gamx=1/Sqrt[1-(vx/c)^2];gamxgamxm1=gamx*(gamx-1);
gamy=1/Sqrt[1-(vy/c)^2];gamygamym1=gamy*(gamy-1);
];
(* non-rel limit that can be solved analytically *)
If[nonrelsprel==1,
gamx=1;gamxgamxm1=(vx^2/c^2)/2;
gamy=1;gamygamym1=(vy^2/c^2)/2;
];
(* mixed limit *)
If[nonrelsprel==2,
gamx=1;gamxgamxm1=(vx^2/c^2)/2;
gamy=1/Sqrt[1-(vy/c)^2];gamygamym1=gamy*(gamy-1);
];
ux=vx*gamx;
uy=vy*gamy;
(* numunknowns things *)
myvarssimple={d,vx,rhoc,iec,rhoout,ieout,Bx,vy,Bzc,Bzout};
whichvx=vx;
whichvy=vy;
(*Print["Got here whichvel==3"];*)
];
(*Print["Got here 0"];*)
(* 4-velocity *)
If[whichvel==4,
(* relativistic *)
(*Print[nonrelsprel];*)
If[nonrelsprel==0,
gamx=Sqrt[1+ux^2/c^2];gamxgamxm1=(ux^4/c^4+ux^2/c^2)/(ux^2/c^2+1+Sqrt[ux^2/c^2+1]);
gamy=Sqrt[1+uy^2/c^2];gamygamym1=(uy^4/c^4+uy^2/c^2)/(uy^2/c^2+1+Sqrt[uy^2/c^2+1]);
];
(* non-rel limit that can be solved analytically *)
If[nonrelsprel==1,
gamx=1;gamxgamxm1=(ux^2/c^2)/2;
gamy=1;gamygamym1=(uy^2/c^2)/2;
];
(* mixed limit *)
If[nonrelsprel==2,
gamx=1;gamxgamxm1=(ux^2/c^2)/2;
gamy=-(uy/c);(* assume uy/c<0 *)
gamygamym1=(uy/c)^2; (* (uy/c)^2+(uy/c)+1 assuming uy/c<0 *)
];
vx=ux/gamx;
vy=uy/gamy;
(* numunknowns things *)
myvarssimple={d,ux,rhoc,iec,rhoout,ieout,Bx,uy,Bzc,Bzout};
whichvx=ux;
whichvy=uy;
(*Print["Got here whichvel==4"];*)
];
];


(* b^i = (B^i + b^t u^i)/u^t = B^i/u^t + b^t v^i = B^i/u^t + B^j u^t v^j v^i ;  b^t = B^i u_i = B^i u^t v^i *)
(*btin=0 (* since perp *)*)
(*btout=0 (* since perp *)*)
setupsprelb:=Module[
{foo},
Clear[gammac,bycent,bzcent,bsqcent,by,By,bx,Bx,bzin,bzout,bsqin,bsqout,Bzc];
bycent=(1-eff1)*by^2;
gammac=1;
bzcent=Bzc/gammac;
bsqcent=bycent^2+bzcent^2;
by=By/gamx;
bzin=Bzin/gamx;
bsqin=by^2 + bzin^2;
bx=Bx/gamy;
bzout=Bzout/gamy;
bsqout=bx^2 + bzout^2;
];


(* START COMPACT *)
solvespsimple[nonrelsprel0_]:=Module[
{foo,nonrelsprel=nonrelsprel0},
setupsprelinputs;
(* CHOOSE: nonrelsprel==1 for pure non-rel *)
(* CHOOSE: nonrelsprel==2 for non-rel inflow and ultra-rel outflow *)
setupsprelvelocity[nonrelsprel];
(*Print["Got here 0.5"];*)
setupsprelb;
(*Print["Got here1"];*)
(*auxvars={etap->eta*4*Pi/c^2,Ez->etap*Jz/Afactor,Jz->(c/(4*Pi))*(Bx/L-By/d)};*)
auxvars={etap->eta*4*Pi/c^2,Ez->etap*Jz/Afactor,Jz->(c/(4*Pi))*(-By/d)};

setupfulleqns;

eqnscompact=Evaluate[{eq1,eq2,eq3,eq4,eq5,eq6,eq7,eq8,eq9,eq10}];
eqns0={eq1==0,eq2==0,eq3==0,eq4==0,eq5==0,eq6==0,eq7==0,eq8==0,eq9==0,eq10==0};
myeqns0=eqns0;
nummyeqns0=myeqns0//.constssprel;
numeffEM=effEM//.constssprel;

(*fsols=NSolve[nummyeqns0,myvarssimple,WorkingPrecision->100];*)
(* sometimes have to really increase this at high S in order to get all roots and to ensure desired root is found *)
fsols=NSolve[nummyeqns0,myvarssimple,WorkingPrecision->workprec];
Print["Dimensions of Nsolve:",Dimensions[fsols],"nonrelsprel=",nonrelsprel];
If[dodebugprint==1,Print[Dimensions[fsols][[1]]];];
whichi=picksimplesol[fsols];
If[whichi==-1,whichi=picksimplesolalternative[fsols];If[whichi>-1,Print["Used Alt"];,Print["Alt failed"];];];
If[whichi>-1,
If[dodebugprint==1,Print["Picked i=",whichi];];
mysol=fsols[[whichi]];
errorvec=eqnscompact//.constssprel//.mysol;
error=errorvec.errorvec;
If[dodebugprint==1,Print["Error=",error];];

simplevector=Table[mysol[[i,2]],{i,1,numunknowns}];

(* convert solution to be closer to rel answer *)
If[nonrelsprel==1,
nonrelsolution=1;
fsolsnonrel=fsols;
mysolnonrel=mysol;
mysolnonrelconverted=convertotherrel2relall[nonrelsprel,mysolnonrel];
numeffEMnonrel=numeffEM//.mysolnonrel;
];
If[nonrelsprel==2,
mixedrelsolution=1;
fsolsmixedrel=fsols;
mysolmixedrel=mysol;
mysolmixedrelconverted=convertotherrel2relall[nonrelsprel,mysolmixedrel];
numeffEMmixedrel=numeffEM//.mysolmixedrel;
];

Print["After2"];

];


If[whichi==-1,
Print["No good solution found!"];
deathfsols={d->0,whichvx->0,rhoc->0,iec->0,rhoout->0,ieout->0,Bx->0,whichvy->0,Bzc->0,Bzout->0};
(*deathmysol={d,whichvx,rhoc,iec,rhoout,ieout,Bx,whichvy,Bzc,Bzout}//.deathfsols;*)
deathmysol=deathfsols;
If[nonrelsprel==1,
nonrelsolution=0;
fsolsnonrelbackup=fsols;
fsolsnonrel=deathfsols;
mysolnonrel=deathmysol;
mysolnonrelconverted=mysolnonrel;
numeffEMnonrel=0;
];
If[nonrelsprel==2,
mixedrelsolution=0;
fsolsmixedrelbackup=fsols;
fsolsmixedrel=deathfsols;
mysolmixedrel=deathmysol;
mysolmixedrelconverted=mysolmixedrel;
numeffEMmixedrel=0;
];
];

];
(* formrelguess depends upon whichvx and whichvy, but assume whichvel doesn't change regardless of using nonrel or mixedrel solutions *)
formrelguess[mysol0_]:=Module[
{foo,myvars,mysol=mysol0,varreplace},
(* Form initial guess from NSolve since otherwise has problems *)
(* numunknown items *)
varreplace={dvar->mysol[[1,2]],vxvar->mysol[[2,2]],rhocvar->mysol[[3,2]],iecvar->mysol[[4,2]],rhooutvar->mysol[[5,2]],ieoutvar->mysol[[6,2]],Bxvar->mysol[[7,2]],vyvar->mysol[[8,2]],Bzcvar->mysol[[9,2]],Bzoutvar->mysol[[10,2]]};
(* numunknown items *)
myvars={{d,dvar},{whichvx,vxvar},{rhoc,rhocvar},{iec,iecvar},{rhoout,rhooutvar},{ieout,ieoutvar},{Bx,Bxvar},{whichvy,vyvar},{Bzc,Bzcvar},{Bzout,Bzoutvar}}//.varreplace;
(* return value *)
myvars
]
picksimplesol[fsols0_]:=Module[
{foo,whichi,fsols=fsols0},
whichi=-1;
For[i=1,i<=Dimensions[fsols][[1]],i++,
If[Re[fsols[[i,3,2]]]>0&&Re[fsols[[i,4,2]]]>0&&Re[fsols[[i,5,2]]]>0&&Re[fsols[[i,6,2]]]>0&&Re[fsols[[i,1,2]]]>0&&Re[fsols[[i,1,2]]]<0.95*(L//.constssprel)&&Abs[Im[fsols[[i,1,2]]]]<10^(-13)*Abs[Re[fsols[[i,1,2]]]],mysol=fsols[[i]];whichi=i;];
(*Print[Im[fsols[[i,1,2]]]];
Print[Re[fsols[[i,1,2]]]];
Print[i];*)
];
whichi
];

picksimplesolalternative[fsols0_]:=Module[
{foo,whichi,fsols=fsols0},
whichi=-1;
For[i=1,i<=Dimensions[fsols][[1]],i++,
If[Re[fsols[[i,3,2]]]>0&&Re[fsols[[i,4,2]]]>0&&Re[fsols[[i,5,2]]]>0&&Re[fsols[[i,6,2]]]>0&&Re[fsols[[i,1,2]]]>0&&Abs[Im[fsols[[i,1,2]]]]<10^(-13)*Abs[Re[fsols[[i,1,2]]]],mysol=fsols[[i]];whichi=i;];
(*Print[Im[fsols[[i,1,2]]]];
Print[Re[fsols[[i,1,2]]]];
Print[i];*)
];
whichi
];

(* fsols=FindRoot[nummyeqns0,myvars,WorkingPrecision->20,MaxIterations->1000]; *)
(* Check: result=myeqns//.constssprel//.fsols;
error=Sqrt[result.result];*)


(* 5: rhoin, iein, Byin=By, Bzin, Bxin=0, vxin=vx, vyin=0 *)
(* 3: rhoc, iec, Bxc=Byc=0, Bzc, vxc=vyc=0 *)
(* 5: rhoout, ieout, Bxout=Bx, Byout=0, Bzout, vyout=vy, vxout=0 *)
(* 1 : d *)

(* 14 total variables *)
(* 4: rhoin, iein, Byin, Bzin considered knowns *)
(* 10 unkonwns: d,vx,rhoc,iec,rhout,ieout,Bx,vy,Bzc,Bzout *)
(* So we need 10 equations *)

(* Aux variables: Ez, Jz, np *)
(* UpperRight x-y quad: sign[By]=sign[Bx] and sign[vx]=-sign[vy] *)
(* UpperLeft x-y quad: sign[By]=-sign[Bx] and sign[vx]=sign[vy] *)
(* LowerRight x-y quad: sign[By]=-sign[Bx] and sign[vx]=sign[vy] *)
(* LowerLeft x-y quad: sign[By]=sign[Bx] and sign[vx]=-sign[vy] *)
solvespfullsetup1:=Module[
{foo,nonrelsprel},

setupsprelinputs;
(* nonrelsprel==0 means full rel equations *)
nonrelsprel=0;
setupsprelvelocity[nonrelsprel];
setupsprelb;

(* correct even in relativistic steady case *)
auxvars={etap->eta*4*Pi/c^2,Ez->etap*Jz/Afactor,Jz->(c/(4*Pi))*(Bx/L-By/d)};
(* L>>d *)
(*auxvars={etap->eta*4*Pi/c^2,Ez->etap*Jz/Afactor,Jz->(c/(4*Pi))*(-By/d)};*)
(* get equations *)
setupfulleqns;
(*simplifyfulleqns;*)
];


(*
d: eq1,eq2,eq5,eq7: eq1
ux: *eq1,eq2,~eq3,*eq5,*eq7,Xeq8: eq7
rhoc: eq6: eq6
iec: eq3,eq4,eq8: eq3
rhoout: eq4,eq5,eq6,~eq7: eq5
ieout: eq4,~eq7,eq8: eq8:
Bx: ~eq1,**eq2,*eq4,Xeq7 : eq2
uy: Xeq2,eq4,eq5,eq7: eq4
*)
SPFindRootone[whichvar0_,whicheq0_,sols00_,eqns0_,constssprel0_]:=Module[
{foo,whichvar=whichvar0,whicheq=whicheq0,sols0=sols00,eqns=eqns0,constssprel=constssprel0},
myvars=Evaluate[{sols0[[whichvar,1]],sols0[[whichvar,2]]}];
thevar=Evaluate[sols0[[whichvar,1]]];
eqnums=Table[ii,{ii,1,numunknowns}];
othereqs=Delete[eqnums,whichvar];
sol=Table[sols0[[ii]],{ii,othereqs}];
tosolve=eqns[[whicheq]]//.constssprel//.sol;

(*
result1=NSolve[0==tosolve,thevar,WorkingPrecision->400];
result2=SPFindRootpicksol[whichvar,sols0,result1];
result2
*)
(* DampingFactor->.8,MaxIterations->10000 *)
Print["SPFindRootone"];
result1=FindRoot[0==tosolve,myvars,WorkingPrecision->workprec];
result1

];
SPFindRootpicksol[whichvar0_,sols00_,fsols0_]:=Module[
{f00,whichvar=whichvar0,sols0=sols00,fsols=fsols0},
If[sols0[[whichvar,2]]>=0,resultpick=SPFindRootpicksolpos[fsols];];
If[sols0[[whichvar,2]]<0,resultpick=SPFindRootpicksolneg[fsols];];
resultpick
];
SPFindRootpicksolneg[fsols0_]:=Module[
{foo,fsols=fsols0},
For[i=1,i<=Dimensions[fsols][[1]],i++,
whichi=i;
If[Re[fsols[[i,1,2]]]<0&&Abs[Im[fsols[[i,1,2]]]]<10^(-13)*Abs[Re[fsols[[i,1,2]]]],finalsol=fsols[[i]];];
];
finalsol
];
SPFindRootpicksolpos[fsols0_]:=Module[
{foo,fsols=fsols0},
For[i=1,i<=Dimensions[fsols][[1]],i++,
whichi=i;
If[Re[fsols[[i,1,2]]]>=0&&Abs[Im[fsols[[i,1,2]]]]<10^(-13)*Abs[Re[fsols[[i,1,2]]]],finalsol=fsols[[i]];];
];
finalsol
];
SPFindRootonereplacesols[whichvar0_,whicheq0_,sols00_,eqns0_,constssprel0_]:=Module[
{foo,whichvar=whichvar0,whicheq=whicheq0,sols0=sols00,eqns=eqns0,constssprel=constssprel0},
solstouse=sols0;
resultre=SPFindRootone[whichvar,whicheq,solstouse,eqns,constssprel];
solsnew=Insert[Delete[solstouse,whichvar],resultre[[1]],whichvar]
];
SPFindRootall[sols00_,eqns0_,constssprel0_]:=Module[
{foo,i,whichvar,whicheq,sols0=sols00,eqns=eqns0,constssprel=constssprel0},
solstouse=sols0;
(* numunknowns things *)
vareqmap={1,7,6,3,5,8,2,4,9,10};
varorder=RandomSample[Range[numunknowns]];
(*Print["Here"];*)
For[i=1,i<=numunknowns,i++,
whichvar=varorder[[i]];
whicheq=vareqmap[[whichvar]];
(*Print["blob",whichvar,whicheq,i];*)
solstouse=SPFindRootonereplacesols[whichvar,whicheq,solstouse,eqns,constssprel];
];
solstouse
];
SPFindRoot[numiter0_,sols00_,eqns0_,constssprel0_]:=Module[
{foo,numiter=numiter0,sols0=sols00,eqns=eqns0,constssprel=constssprel0},
solstouse=sols0;
For[i=1,i<=numiter,i++,
solstouse=SPFindRootall[solstouse,eqns,constssprel];
];
solstouse
];
setupfulleqns:=Module[
{foo},
(* E_z dissipation at center *)
(* ideal MHD outside each face *)
(* E_z constant *)
(* correct even in relativistic case *)
eq1=(eqBunits*myfun[-Ez-vx*By/c])//.auxvars;
eq2=(eqBunits*myfun[-Ez+vy*Bx/c])//.auxvars;

(* x-momentum flux dissipates completely, then y-momentum is created *)
(* C=(rho + u + p + bsq)v^i v^j + (bsq/2+pg)\delta^i_j - b^i b_j *)
(* along x-direction:  *)
(* C=(rho + u + p + bsq)v^x v^x + bsq/2+p - b^x b_x *)
(* no stress *)
(* C=(rho + u + p + bsq)vx^2 + bsq/2+p *)
(* from in to c *)

(*eq3=(By^2/(8*Pi)+pin)==pcent;*)
(* -bx*bx/(4*Pi) *)
eq3=myfun[(rhoin+(iein+pin+bsqin/(4*Pi))/c^2)*ux^2+(bsqin/(8*Pi)+pin)-(bsqcent/(8*Pi)+pcent)];
(*eq3=(By^2/2+0)==pcent;*)
(* from in to out *)
(* bsqin/2 + pin = (rhoout + uout + pout + bsqout)vx^2 + bsqout/2+pout *)
(* By^2/2 + (gam-1)*iein == (rhoout + gam*ieout + 0)vy^2 + 0 + (gam-1)ieout *)
(*eq4=pcent *dzsp*L*d== ((rhoout + gam*ieout)*vy^2 +pout)*dzsp*d;*)
(* non-rel *)
(*eq4=pcent== ((rhoout)*vy^2 +pout);*)
(* -bx*bx/(4*Pi) *)
eq4=myfun[-((bsqcent/(8*Pi)+pcent))+ (rhoout + (ieout+pout+bsqout/(4*Pi))/c^2)*uy^2 +(bsqout/(8*Pi)+pout)];

(* rest mass conservation: applies to UpperRight quad *)
eq5=(1/(L*dzsp))*myfun[rhoin*c*(-ux)*L*dzsp-rhoout*c*uy*d*dzsp];

(* assumption by Dmitri *)
(* Dmitri version *)
eq6=c^2*myfun[rhoc-factoreq6*rhoout];
(* jon version *)
(*uth=Sqrt[2*iec/rhoc];
eq6=myfun[uth*rhoc-vy*rhoout];*)
(* jon test *)
(*eq6=rhoc==(1/2)*rhoout;*)

(* energy conservation *)
(* -rho u_t + (rho+u+p+bsq)u^i u_t - b^i b_t *)
(* (1/2*rho*v^2 + u+p+bsq)*v^i - b^i b_t *)
(* assume no stress , and no incoming inertia not dominating *)
(* 0\sim (1/2)*rhoin*vx^2 *)
(*eq7=( (1/2)*rhoin*vx^2+iein + pin+By^2/(4*Pi))*vx  * L * dzsp== ( (1/2)*rhoout*vy^2+ieout+pout+Bx^2/(4*Pi))*vy * d * dzsp; *)
(*eq7=( By^2)*vx  * L * dzsp== ( (1/2)*rhoout*vy^2+pout)*vy * d * dzsp;*)
(* Applies to UpperRight quad *)
(*eq7=(1/(c*L*dzsp))*myfun[(( rhoin*gamx*(gamx-1)*c^2+iein + pin+bsqin/(4*Pi))*(-ux)*gamx  * L * dzsp)-(( rhoout*gamy*(gamy-1)*c^2+ieout+pout+bsqout/(4*Pi))*uy*gamy* d * dzsp)];*)
EdotMAin=(( rhoin*gamxgamxm1*c^2+iein + pin)*(-ux)*gamx  * L * dzsp);
EdotEMin=(( bsqin/(4*Pi))*(-ux)*gamx  * L * dzsp);
(*Edotin=(( rhoin*gamxgamxm1*c^2+iein + pin+bsqin/(4*Pi))*(-ux)*gamx  * L * dzsp);*)
Edotin=EdotMAin+EdotEMin;
EdotMAout=(( rhoout*gamygamym1*c^2+ieout+pout)*uy*gamy* d * dzsp);
EdotEMout=(( bsqout/(4*Pi))*uy*gamy* d * dzsp);
(*Edotout=(( rhoout*gamygamym1*c^2+ieout+pout+bsqout/(4*Pi))*uy*gamy* d * dzsp);*)
Edotout=EdotMAout+EdotEMout;
effEM=1-EdotEMout/EdotEMin;
eq7=(1/(c*L*dzsp))*myfun[Edotin-Edotout];

(* Dmitri assumption *)
(* -- below equivalent to pin=pout *)
(*eq8=pcent-pout==pin+bsqin/(8*Pi);*)
(* other choices *)
(*eq8=pcent-pout==0; -- not allowed?*)
(*eq8=pout==pcent/4.7;*)
(* Dmitri assumption -- what was using before *)
(*eq8=myfun[(pcent-pout)-eff2*(pin+by^2/(8*Pi))];*)
(*eq8=myfun[(pcent-pout)-(bsqin/(8*Pi))];*)
(* Jon simplification with detachment from inflow field *)
eq8=myfun[pout-(1-eff2)*pcent];

(* for guide field, 2 extra equations to determine Bzc and Bzout *)
eq9=(eqBunits/(c*L))*myfun[L*vx*Bzin-d*vy*Bzout];
eq10=(eqBunits)*myfun[bzcent-bzout];
];
simplifyfulleqns:=Module[
{foo},
eq1=FullSimplify[eq1*L*d*gamx];
eq2=FullSimplify[eq2*L*d*gamy];
eq3=FullSimplify[eq3*(1+ux^2)];
eq4=FullSimplify[eq4*(1+uy^2)];
eq5=FullSimplify[eq5*dzsp*L];
eq6=FullSimplify[eq6];
eq7=FullSimplify[eq7*(4 \[Pi] (1+ux^2))*(4 \[Pi] (1+uy^2))*(1+ux^2+Sqrt[1+ux^2])*(1+uy^2+Sqrt[1+uy^2])];
eq8=FullSimplify[eq8*(8*Pi*(1+ux^2))];
eq9=FullSimplify[eq9];
eq10=FullSimplify[eq10];
];


solvespfullsetup2:=Module[
{foo},
(* Check if setup magnetically-dominated *)
(By^2/(8*Pi)-(pin))//.constssprel;
(* Original SP solution: Used as initial guess, since otherwise can miss finding solution for some inflow values for no good reason *)
(* original SP delta: delta = (eta L/va)^(1/2) *)
vaold=c*By/Sqrt[1*4*Pi*(rhoin*c^2+iein+pin+By^2/(4*Pi))]//.constssprel;
olddelta=Sqrt[eta*L/vaold]//.constssprel;
Slund=1*L*vaold/eta//.constssprel//.{ux->0};
Print["Slund=",SetPrecision[Slund,10]];
sigma=1*By^2/(8*Pi)/(rhoin*c^2)//.constssprel//.{ux->0};
Print["sigma=",SetPrecision[sigma,10]];
(* UpperRight quad *)
vxold=-(vaold*Slund^(-1/2));
rhoold=rhoin//.constssprel;
ieold=iein//.constssprel;
(* UpperRight quad *)
(* guess on Ez=constant *)
Bxold=-By*vxold/vaold//.constssprel;
olddelta=Sqrt[eta*L/vaold]//.constssprel//.{ux->0};
vextreme=1-10^(-5);
];


solvespfull:=Module[
{foo,errorroot,errormessage,rootmyprec,varmyprec},
eqnsfull=Evaluate[{eq1,eq2,eq3,eq4,eq5,eq6,eq7,eq8,eq9,eq10}];
eqns0={eq1==0,eq2==0,eq3==0,eq4==0,eq5==0,eq6==0,eq7==0,eq8==0,eq9==0,eq10==0};
myeqns0=eqns0;
nummyeqns0=myeqns0//.constssprel;
numeffEM=effEM//.constssprel;

(*fsols;=FindRoot[nummyeqns0,myvars,MaxIterations->10000,DampingFactor->0.5] (* was good *)*)
(*fsols=FindRoot[nummyeqns0,myvars,MaxIterations->10000,DampingFactor->0.5,WorkingPrecision->50,AccuracyGoal->14,PrecisionGoal->14];*)
(*If[normalsolve==0,Print["FindRoot0"];fsolsspotherunits=FindRoot[nummyeqns0,myvars];];*)
(* if takes more than 2000 iterations, probably going to fail to converge *)
Print["FindRoot1"];
errorroot=0;
(*Check[fsolsspotherunits=FindRoot[nummyeqns0,myvars,MaxIterations->maxiter,DampingFactor->0.8,WorkingPrecision->workprec,AccuracyGoal->whichaccuracy,PrecisionGoal->whichprecision],errorroot=1];*)
rootmyprec=SetPrecision[nummyeqns0,workprec];
varmyprec=SetPrecision[myvars,workprec];
Check[fsolsspotherunits=FindRoot[rootmyprec,varmyprec,MaxIterations->maxiter,WorkingPrecision->workprec,AccuracyGoal->whichaccuracy,PrecisionGoal->whichprecision],errorroot=1];
numeffEMrel=numeffEM//.fsolsspotherunits;
(*Print["FindRoot2"];fsolsspotherunits=FindRoot[nummyeqns0,myvars,MaxIterations->100000,DampingFactor->0.001,WorkingPrecision->800,AccuracyGoal->whichaccuracy,PrecisionGoal->whichprecision];*)
(* stupid mathematica doesn''t give message till after If[] apparently, so can't put the below check inside If -- so FindRoot[] should be last command or remove If[] *)
(* default no error *)
(*errorroot=0;
If[errormessage=={FindRoot::"cvmit"},errorroot=1;];
If[errormessage=={FindRoot::"lstol"},errorroot=2;];
*)
(*fsolsspotherunits=FindRoot[nummyeqns0,{{d,olddelta},{vx,vxold},{rhoc,rhoold},{iec,ieold},{rhoout,rhoold},{ieout,ieold},{Bx,Bxold},{vy,vaold}},WorkingPrecision->20,MaxIterations->1000];*)
(* MaxIterations->10000,WorkingPrecision->50]; *)
(*computefullerror; errorsolve0=Abs[normalizederror1];
If[errorsolve0>10^(-4),fsolsspotherunits=FindRoot[nummyeqns0,myvars,MaxIterations->100000,DampingFactor->0.8,WorkingPrecision->100,AccuracyGoal->whichaccuracy,PrecisionGoal->whichprecision];computefullerror;];
*)
(* return error value *)
Print["Full Errorroot=",errorroot];
errorroot
];


computefullerror:=Module[
{foo},
vector=Table[fsolsspotherunits[[i,2]],{i,1,numunknowns}];
resultfull=eqnsfull//.constssprel//.fsolsspotherunits;
error=Sqrt[resultfull.resultfull];
(*normalizederror=(error/eqieunits); NO *)
normalizederror1=Evaluate[(error/(iec//.fsolsspotherunits))//.constssprel];
normalizederror2=Evaluate[(error/(rhoc*c^2//.fsolsspotherunits))//.constssprel];
(* compare simple and real *)
diffvector=vector-simplevector;
diffvectorratio=diffvector/(simplevector+vector);
deltaspfinalotherunits=fsolsspotherunits[[1,2]];
vanewish=c*By/Sqrt[1*4*Pi*(rhoout*c^2+iein+pin+By^2/(4*Pi))]//.constssprel;
olddeltanewish=Sqrt[eta*L/vanewish]//.constssprel//.fsolsspotherunits;
];


setSsigmava[rho0_,b0_,ug0_,pg0_,l0_,eta0_]:=Module[
{foo,rho=rho0,b=b0,ug=ug0,pg=pg0,l=l0,eta=eta0,mysigma,myva,myS},
(* bgauss=Sqrt[8*Pi*mysigma*rhobvalue*c^2]; *)
mysigma=b^2/(8*Pi*rho*c^2);
myva=c*b/Sqrt[1*4*Pi*(rho*c^2+ug+pg+b^2/(4*Pi))];
myS=l*myva/eta;
(* return value *)
{mysigma,myva,myS}
];


(* based upon spreconfitrats.nb and SM plots using reconnection_norad.m *)
convertotherrel2rel[nonrelsprel0_,which0_]:=Module[
{foo,nonrelsprel=nonrelsprel0,which=which0,mysigma,myva,myS,conditiontomodify1,conditiontomodify2,conditiontomodify3,conditiontomodify4,conditiontomodify5,cuti,fun,dratconsts,uxratconsts,rhocratconsts,iecratconsts,rhooutratconsts,ieoutratconsts,Bxratconsts,uyratconsts,Bzcratconsts,Bzoutratconsts,a1,b1,a2,b2,f3,e3,d3,c3,a3,b3,npow,signtouse,allconsts},
(*Print[rhobvalue," ",bgauss," ",UginfixedT," ",PginfixedT," ",Lpnum," ",etatotal];*)
{mysigma,myva,myS}=setSsigmava[rhobvalue,bgauss,UginfixedT,PginfixedT,Lpnum,etatotal];
conditiontomodify1=If[150*mysigma>myS^(1/4),1,0];
(*conditiontomodify2=10*mysigma-myS^(1/2);*)
conditiontomodify2=If[8*mysigma>myS^(3/5),1,0];
conditiontomodify3=If[0.5*mysigma>myS^(-1) && mysigma<0.001,1,0];
conditiontomodify4=If[10^4*mysigma<myS^(4/5) && mysigma>=0.5,1,0];
conditiontomodify5=If[0.5*mysigma>myS^(-1) &&  mysigma>=0.001 && mysigma<10,1,0];
(* rats for: 1=d 2=ux 3=rhoc 4=iec 5=rhoout 6=ieout 7=Bx 8=uy 9=Bzc 10=Bzout *)
 (* default is no cut or modification *)
cuti=-1;
fun=1;
If[nonrelsprel==1 &&(conditiontomodify2<=0&&conditiontomodify1>0),
(* CUT 1 *)
signtouse={-1,1,1,-1,1,1,1,-1,1,1};
cuti=1;
dratconsts={a1->0.04786021708046376,b1->-0.43477355192455974,a2->0.9992035139365585,b2->-0.1258579448348711,f3->1.,e3->1.,d3->1.,c3->1.,a3->-0.0001352757261747089,b3->1.,npow->1.};uxratconsts={a1->0.13111103399207727,b1->-0.33863473165404434,a2->0.9995749855188978,b2->-0.12701964662835039,f3->1.,e3->1.,d3->1.,c3->1.,a3->0.0000364445243039451,b3->1.,npow->1.};rhocratconsts={a1->0.3478973290172718,b1->0.3000649958225696,a2->1.000359978989461,b2->0.4814920337896888,f3->1.,e3->1.,d3->1.,c3->1.,a3->-0.000029218334036272235,b3->1.,npow->1.};iecratconsts={a1->0.4774086634607869,b1->0.10436175109739151,a2->1.1083328583839787,b2->-0.06996569064290178,f3->1.,e3->1.,d3->1.,c3->1.,a3->-0.9996081499207383,b3->1.,npow->1.};rhooutratconsts={a1->0.3478973290172718,b1->0.3000649958225696,a2->1.000359978989461,b2->0.4814920337896888,f3->1.,e3->1.,d3->1.,c3->1.,a3->-0.000029218334036272235,b3->1.,npow->1.};ieoutratconsts={a1->0.20174289234914577,b1->-0.06023988735369447,a2->0.9951654754134456,b2->0.14319755643633134,f3->1.,e3->1.,d3->1.,c3->1.,a3->0.00002501130110008313,b3->1.,npow->1.};Bxratconsts={a1->0.5866660067799973,b1->0.37814722851199023,a2->1.0007535416662767,b2->0.6335763867874434,f3->1.,e3->1.,d3->1.,c3->1.,a3->0.00002446979874962092,b3->1.,npow->1.};uyratconsts={a1->0.027190372433796167,b1->-0.20788024641957578,a2->1.0001696739359327,b2->0.17938246113425677,f3->1.,e3->1.,d3->1.,c3->1.,a3->-0.000029555074703701793,b3->1.,npow->1.};
Bzcratconsts={a1->0.0,b1->0,a2->0,b2->0,f3->0.,e3->0.,d3->0.,c3->0.,a3->0,b3->0,npow->0};
Bzoutratconsts={a1->0.0,b1->0,a2->0,b2->0,f3->0.,e3->0.,d3->0.,c3->0.,a3->0,b3->0,npow->0};
];
If[ nonrelsprel==1 &&(conditiontomodify2>0&&conditiontomodify1>0),
(* CUT 2 *)
signtouse={-1,1,1,-1,1,1,1,-1,1,1};
cuti=2;
dratconsts={a1->-0.07055247866577966,b1->0.448982194291537,a2->0.05986469793826613,b2->-0.018010885872619124,f3->-0.15523330952567427,e3->-0.023252128642946977,d3->0.03345954445329196,c3->-0.5449909641846628,a3->0.005383907383868816,b3->-0.002759038867109294,npow->0.};uxratconsts={a1->-0.02761020412828064,b1->0.6192660713845041,a2->0.12493335170994431,b2->-0.0635265019931846,f3->-0.17290616783764642,e3->-0.061900970059541836,d3->0.08474620367635682,c3->-0.45776809947060937,a3->0.015731247387578057,b3->-0.026117621945494274,npow->0.};rhocratconsts={a1->0.046337284629318874,b1->0.7271223431987213,a2->0.15809581617443028,b2->-0.09366194936983281,f3->-0.1234636831696684,e3->-0.08197981342515699,d3->0.10529862619092822,c3->0.1805181679711891,a3->0.021809909612323763,b3->-0.03749291397889188,npow->0.};iecratconsts={a1->-0.4642385375882243,b1->-0.18001561718834166,a2->0.07038723409470067,b2->0.01268057552350868,f3->-0.25825101028380587,e3->0.13331853067892963,d3->-0.18089993642200625,c3->-1.1081608015268947,a3->-0.032945325983724426,b3->0.10436363413749772,npow->0.};rhooutratconsts={a1->0.046337284629318874,b1->0.7271223431987213,a2->0.15809581617443028,b2->-0.09366194936983281,f3->-0.1234636831696684,e3->-0.08197981342515699,d3->0.10529862619092822,c3->0.1805181679711891,a3->0.021809909612323763,b3->-0.03749291397889188,npow->0.};ieoutratconsts={a1->0.02884157400886772,b1->0.696367332776852,a2->0.17442920876874596,b2->-0.1009561104396555,f3->-0.16983642508962582,e3->-0.08978196463875894,d3->0.1195367594594502,c3->-0.1490044081231664,a3->0.023547012078865337,b3->-0.042383140817311364,npow->0.};Bxratconsts={a1->0.26351598618645555,b1->0.5714524905317424,a2->0.21402442815562692,b2->-0.12444459381870066,f3->-0.12352775993489748,e3->-0.06802380307360031,d3->0.07923046392848619,c3->0.09024495566091298,a3->0.02009971601675062,b3->-0.025831145492941653,npow->0.};uyratconsts={a1->0.010339311036673992,b1->0.3324285243013885,a2->-0.0021513940838879236,b2->-0.0020220453279061407,f3->-0.10283089872533453,e3->-0.0002720579250887734,d3->0.0007170492344859532,c3->-0.523123891280456,a3->0.00021220258474655514,b3->0.01293251818106794,npow->0.};
Bzcratconsts={a1->0.0,b1->0,a2->0,b2->0,f3->0.,e3->0.,d3->0.,c3->0.,a3->0,b3->0,npow->0};
Bzoutratconsts={a1->0.0,b1->0,a2->0,b2->0,f3->0.,e3->0.,d3->0.,c3->0.,a3->0,b3->0,npow->0};
];
(* allow override by cuti=3,4,5 *)
If[nonrelsprel==1 &&( conditiontomodify3>0),
(* CUT 3 *)
signtouse={-1,1,1,-1,1,1,1,-1,1,1};
cuti=3;
dratconsts={a1->-0.012189775518847094,b1->0.9653734952043307,a2->0.0019406626014562948,b2->0.0011001138713430626,f3->-0.002729899401083556,e3->-0.00006720151615874917,d3->-0.00004876507151268549,c3->-0.13621575619029758,a3->-0.000028132749600590663,b3->-0.00018424580551701828,npow->0.};uxratconsts={a1->0.014805502012962548,b1->0.9930628461867431,a2->-0.0021734536737175185,b2->-0.0013087690745298816,f3->-0.004018762822581118,e3->0.00007640147659236001,d3->0.000058443946106580106,c3->-0.21010997382606122,a3->0.00003318113750579658,b3->-0.00013679404309485777,npow->0.};rhocratconsts={a1->0.00031502033967914484,b1->0.9846210822176993,a2->0.000017955422190740494,b2->-0.00001757293530833211,f3->-0.0023584255679888083,e3->-2.52531*10^-7,d3->8.57138*10^-7,c3->0.44454006208940416,a3->3.30557*10^-7,b3->-0.00011484164744344336,npow->0.};iecratconsts={a1->-1.1964362696003015,b1->1.0852001528025308,a2->0.06868659093692647,b2->0.04143399061380359,f3->0.09267951717284528,e3->-0.007977966289384903,d3->-0.009172557915425709,c3->0.15511200943287143,a3->-0.0028363644111612544,b3->0.0009089001240110444,npow->0.};rhooutratconsts={a1->0.00031502033967914484,b1->0.9846210822176993,a2->0.000017955422190740494,b2->-0.00001757293530833211,f3->-0.0023584255679888083,e3->-2.52531*10^-7,d3->8.57138*10^-7,c3->0.44454006208940416,a3->3.30557*10^-7,b3->-0.00011484164744344336,npow->0.};ieoutratconsts={a1->0.014815343153346457,b1->0.9945865370933509,a2->-0.0021727973755730234,b2->-0.001309300107065623,f3->-0.003782761310623364,e3->0.00007639008246340802,d3->0.00005846787116309578,c3->0.09397167815065427,a3->0.00003319075133546133,b3->-0.00012522582858348697,npow->0.};Bxratconsts={a1->0.0027421961007336538,b1->0.9896531581642275,a2->-0.0003444747572799879,b2->-0.0002329570678662876,f3->-0.0020722393993344397,e3->0.000012438865724398912,d3->0.000010445954902817104,c3->0.5943435464897215,a3->5.79936*10^-6,b3->-0.00009097476022563219,npow->0.};uyratconsts={a1->0.0002813539720275817,b1->0.9754507028305147,a2->0.00001558318256036524,b2->-0.000015782412292221592,f3->-0.003777311384180067,e3->-2.07158*10^-7,d3->7.84817*10^-7,c3->0.12503436195274745,a3->2.9884*10^-7,b3->-0.00018434319802684382,npow->0.};
Bzcratconsts={a1->0.0,b1->0,a2->0,b2->0,f3->0.,e3->0.,d3->0.,c3->0.,a3->0,b3->0,npow->0};
Bzoutratconsts={a1->0.0,b1->0,a2->0,b2->0,f3->0.,e3->0.,d3->0.,c3->0.,a3->0,b3->0,npow->0};
];
If[ nonrelsprel==2 &&(conditiontomodify4>0),
(* CUT 4 *)
signtouse={1,-1,-1,-1,-1,-1,-1,1,1,1};
cuti=4;
dratconsts={a1->-0.01107342079331653,b1->0.41758950542143974,a2->-0.0012806236314584236,b2->0.0007577320543266084,f3->-0.1627594949627593,e3->0.00002235382651247665,d3->-0.00028571453360875474,c3->-0.7047937951982105,a3->-0.00001577361645609262,b3->-0.011745247857082617,npow->0.};uxratconsts={a1->-0.004055181709634218,b1->0.5186370975820438,a2->-0.005053420315384705,b2->0.0001253808037152951,f3->-0.143553126069433,e3->0.0001353125546809919,d3->-0.00033538475150473213,c3->-0.6433756303345691,a3->1.50018*10^-7,b3->-0.010879440755332358,npow->0.};rhocratconsts={a1->-0.0074845468002893625,b1->0.6308792717337779,a2->-0.0029996889575357112,b2->0.00044429180703149353,f3->-0.1058675034371879,e3->0.00007267451315033938,d3->-0.000326745539462483,c3->0.09757200946920445,a3->-8.00354*10^-6,b3->-0.0077532636293906375,npow->0.};iecratconsts={a1->-0.9072205212996106,b1->0.6083061854143571,a2->0.0672131576640778,b2->-0.011196194941098655,f3->-0.2485678142947526,e3->-0.0038803737195037594,d3->0.004486509376558615,c3->-0.43434536319080386,a3->0.00042466641259343194,b3->-0.051054137607309126,npow->0.};rhooutratconsts={a1->-0.0074845468002893625,b1->0.6308792717337779,a2->-0.0029996889575357112,b2->0.00044429180703149353,f3->-0.1058675034371879,e3->0.00007267451315033938,d3->-0.000326745539462483,c3->0.09757200946920445,a3->-8.00354*10^-6,b3->-0.0077532636293906375,npow->0.};ieoutratconsts={a1->-0.004946759914445769,b1->0.5632166566764654,a2->-0.005487852792890134,b2->0.00017740368092618867,f3->-0.13063200930898658,e3->0.00014488742720258284,d3->-0.00039782079336360914,c3->-0.29608263612383606,a3->-7.60011*10^-7,b3->-0.009892760882350035,npow->0.};Bxratconsts={a1->0.0007546336498103159,b1->0.7132803528137435,a2->-0.0011016959976825236,b2->-0.00008656460039820905,f3->-0.07542401837639147,e3->0.000027271326595091544,d3->-0.0001077740617752087,c3->0.30514646488288116,a3->2.46082*10^-6,b3->-0.004135851648515479,npow->0.};uyratconsts={a1->0.0009650088111134972,b1->0.3697950396933458,a2->-0.00008742384133042377,b2->-0.00007258636320059408,f3->-0.17715155428277513,e3->3.14544*10^-6,d3->7.67761*10^-6,c3->-0.4915689540078929,a3->1.63193*10^-6,b3->-0.012489350611914274,npow->0.};
Bzcratconsts={a1->0.0,b1->0,a2->0,b2->0,f3->0.,e3->0.,d3->0.,c3->0.,a3->0,b3->0,npow->0};
Bzoutratconsts={a1->0.0,b1->0,a2->0,b2->0,f3->0.,e3->0.,d3->0.,c3->0.,a3->0,b3->0,npow->0};
];
If[nonrelsprel==1 &&( conditiontomodify5>0),
(* CUT 5 *)
signtouse={-1,1,1,-1,1,1,1,-1,1,1};
cuti=5;
dratconsts={a1->-0.0005317335326220828,b1->-0.09372354482251724,a2->-0.00001301318837760367,b2->0.000032666628625851564,f3->-0.04083288109209074,e3->2.31536*10^-7,d3->4.82528*10^-7,c3->-1.3172170356825086,a3->-6.3131*10^-7,b3->0.0021768151038864237,npow->0.};uxratconsts={a1->-0.0005048807798997877,b1->-0.08712210634872507,a2->-0.000012183524304644456,b2->0.00003100262225739979,f3->-0.04148474564442021,e3->2.10858*10^-7,d3->4.83108*10^-7,c3->-1.3378345851068068,a3->-5.98784*10^-7,b3->0.0021955529447943625,npow->0.};rhocratconsts={a1->-0.00044473479382601075,b1->-0.07749894954224297,a2->-7.68865*10^-6,b2->0.000027147012164638565,f3->-0.04242693395353735,e3->6.51619*10^-8,d3->6.71829*10^-7,c3->-0.7662468887427943,a3->-5.20485*10^-7,b3->0.0022217527348302136,npow->0.};iecratconsts={a1->-1.001747142281031,b1->0.7055316050121079,a2->-0.0000904823506477582,b2->0.0001546219219634157,f3->-0.007646264530656149,e3->-1.24584*10^-6,d3->0.000018511330886478776,c3->0.15400828198209965,a3->-4.08923*10^-6,b3->0.0004283447303474846,npow->0.};rhooutratconsts={a1->-0.00044473479382601075,b1->-0.07749894954224297,a2->-7.68865*10^-6,b2->0.000027147012164638565,f3->-0.04242693395353735,e3->6.51619*10^-8,d3->6.71829*10^-7,c3->-0.7662468887427943,a3->-5.20485*10^-7,b3->0.0022217527348302136,npow->0.};ieoutratconsts={a1->-0.0004957926862960113,b1->-0.08387088326808903,a2->-0.000012026960526710944,b2->0.00003044240537512275,f3->-0.04180291032244257,e3->2.07116*10^-7,d3->4.82454*10^-7,c3->-1.0469824998003052,a3->-5.87881*10^-7,b3->0.002204554555073312,npow->0.};Bxratconsts={a1->-0.0038007861354831685,b1->0.6214230943451922,a2->7.75157*10^-6,b2->0.00021508454918630997,f3->-0.14935272949255085,e3->-9.21673*10^-7,d3->2.83926*10^-6,c3->-2.803908538515292,a3->-3.87336*10^-6,b3->0.00743658560365399,npow->0.};uyratconsts={a1->-0.0005174931269572766,b1->-0.09712425886934724,a2->-6.08815*10^-6,b2->0.000031442405816196946,f3->-0.040505064883148846,e3->-6.62145*10^-9,d3->8.46203*10^-7,c3->-1.005883947226965,a3->-6.00371*10^-7,b3->0.0021669275126324473,npow->0.};
Bzcratconsts={a1->0.0,b1->0,a2->0,b2->0,f3->0.,e3->0.,d3->0.,c3->0.,a3->0,b3->0,npow->0};
Bzoutratconsts={a1->0.0,b1->0,a2->0,b2->0,f3->0.,e3->0.,d3->0.,c3->0.,a3->0,b3->0,npow->0};
];
Print["Using CUT=",cuti," for which=",which," for nonrelsprel=",nonrelsprel];
allconsts={dratconsts,uxratconsts,rhocratconsts,iecratconsts,rhooutratconsts,ieoutratconsts,Bxratconsts,uyratconsts,Bzcratconsts,Bzoutratconsts};
(* non-default rescaling *)
If[cuti!=-1,
fun=otherrel2relfun[cuti,which,allconsts[[which]],myS,mysigma,signtouse[[which]]];
];
(* return ratio of rel to otherrel *)
SetPrecision[fun,workprec]
];


convertotherrel2relall[nonrelsprel0_,mysol00_]:=Module[
{foo,mysol,nonrelsprel=nonrelsprel0,mysol0=mysol00,ii,convertfactor},
convertfactor=Table[convertotherrel2rel[nonrelsprel,ii],{ii,1,numunknowns}];
mysol=Table[mysol0[[ii,1]]->mysol0[[ii,2]]*convertfactor[[ii]],{ii,1,numunknowns}];
(* return value *)
mysol
];


otherrel2relfun[cuti0_,choosei0_,ratconsts0_,S0_,sigma0_,signtouse0_]:=Module[
{foo,cuti=cuti0,choosei=choosei0,initratconsts=ratconsts0,S=S0,sigma=sigma0,signtouse=signtouse0,lfit1,fit1,lfit2,fit2,lfit3,fit3,upmodel,model,x,y,a1,b1,a2,b2,f3,e3,d3,c3,a3,b3,npow,values,ratconsts,numfitparms,numiters,npowlist,npowa},
(*values should be same order as used in spreconfitrats.nb*)
values={a1,b1,a2,b2,f3,e3,d3,c3,a3,b3,npow};
numfitparms=11;
ratconsts=Table[values[[ii]]->initratconsts[[ii,2]],{ii,1,numfitparms}];
x=Log[10,S];
y=Log[10,sigma];
(* get below from spreconfitrats.nb *)
(* default model *)
numiters=200;
model=c3+a1*x+b1*y+a2*x*y+b2*x^2+f3*y^2+e3*x^2*y+d3*y^2*x+a3*x^3+b3*y^3;
If[cuti==1 ,
numiters=100;
lfit1=a1*y+b1;
fit1=10^lfit1;
lfit2=a2*y+b2;
fit2=10^lfit2;
lfit3=a3*x;
fit3=10^lfit3;
(*upmodel=(1/(1/fit1^npow+1/fit2^npow))^(1/npow);*)
(* fitting procedure poor job most of the time for npow, so use npow from when was good fit *)
npowlist={0.73001,0.763018,1.00885,1.00885,1.00885,1.00885,1.82356,0.725738,1,1};
npowa=npowlist[[choosei]];
upmodel=(1/(1/fit1^npowa+1/fit2^npowa))^(1/npowa);
(*If[cuti==1,model=Log[10,upmodel] ,model=Log[10,upmodel] + lfit3;];*)
model=Log[10,upmodel] + lfit3;
];
(* now return answer as a linear function of actual fit to function without 1 subtracted *)
(1+10^model)//.ratconsts
];


(* after setup, get complete rel solution *)
solvespcomplete:=Module[
{foo,errorroot,vel4togorel,sigmatogorel ,mysigma,myva,myS,mysolaveraged},
(* get non-rel solution *)
solvespsimple[1];
(* get mixed rel solution *)
solvespsimple[2];
{mysigma,myva,myS}=setSsigmava[rhobvalue,bgauss,UginfixedT,PginfixedT,Lpnum,etatotal];

(* generically expect NSolve to find solution at least in certain gross regimes -- else no solution at all *)
sigmatogorel =0.5;
(* default is no solution at all *)
errorroot=-1;
fsolsspotherunits=fsolsnonrel;

If[nonrelsolution==1 &&mysigma<=sigmatogorel|| mixedrelsolution==1&&mysigma>=sigmatogorel,
(* now default is solution is present and can be solved for *)
errorroot=0;
(* check -uy for relativistic outflow *)
vel4togorel=2.0;
(* sigma to start using mixedrel solution *)
sigmatogorel =0.5;
(* for sigma>=1, mixedrel solution is actually more accurate independent of uy or sigma *)
If[(mysigma>=sigmatogorel ||(Abs[mysolnonrel[[8,2]]]>vel4togorel||
Abs[mysolmixedrel[[8,2]]]>vel4togorel||Abs[mysolnonrelconverted[[8,2]]]>vel4togorel||Abs[mysolmixedrelconverted[[8,2]]]>vel4togorel)),mysol=mysolmixedrelconverted;Print["Using mixedrelconverted"];,mysol=mysolnonrelconverted;Print["Using nonrelconverted"];];
(* form guess for rel calculation *)
myvars=formrelguess[mysol];
(* start rel calculation process *)
solvespfullsetup1;
solvespfullsetup2;
errorroot=solvespfull;
fsolsspotherunitsnormal=fsolsspotherunits;
numeffEMrelnormal=numeffEMrel;
(* if errorroot==1, then FindRoot failed in some way, so see if in middle of non-rel to rel regime and use average of converted rel and mixedrel to see if can still get solution *)
(* check -uy for mildy relativistic outflow *)
vel4togorel=0.5;
(* sigma to start using mixedrel solution *)
sigmatogorel =0.1;
If[errorroot==1 &&(mysigma>=sigmatogorel ||(Abs[mysolnonrel[[8,2]]]>vel4togorel||
Abs[mysolmixedrel[[8,2]]]>vel4togorel||Abs[mysolnonrelconverted[[8,2]]]>vel4togorel||Abs[mysolmixedrelconverted[[8,2]]]>vel4togorel)),
(* then average converted and mixedrel solutions *)
mysolaveraged=Table[mysolnonrelconverted[[ii,1]]->(mysolnonrelconverted[[ii,2]]+mysolmixedrel[[ii,2]])*0.5,{ii,1,numunknowns}];
(* now try again *)
mysol=mysolaveraged;
(* form guess for rel calculation *)
myvars=formrelguess[mysol];
(* start rel calculation process *)
solvespfullsetup1;
solvespfullsetup2;
errorroot=solvespfull;
fsolsspotherunitsfromaveraged=fsolsspotherunits;
numeffEMrelfromaveraged=numeffEMrel;
If[errorroot==1,
(* trust non-averaged version as probably much closer if averaged version also failed to converge *)
fsolsspotherunits=fsolsspotherunitsnormal;
numeffEMrel=numeffEMrelnormal;
];
If[errorroot==0,
Print["Recovered!"];
];
];
(* end if some NSolve solution in appropriate regimes *)
];
(* fsolsspotherunits is also grabbed as output *)
errorroot
];


(* this is called by external file *)
solvespfullall[eff20_,guidefactor0_,Afactor0_]:=Module[
{foo,errorroot,eff2=eff20,guidefactor=guidefactor0,Afactor=Afactor0},
(* set some global model parameter constants *)
eff2global=eff2;
guidefactorglobal=guidefactor;
Afactorglobal=Afactor;
(* get physical constants *)
getconstants;
(*setupsplocalrun*)
setupspjetrun;
errorroot=solvespcomplete;
(* numunknowns things *)
blob=({d,ux,rhoc,iec,rhoout,ieout,Bx,uy,Bzc,Bzout})//.fsolsspotherunits;
blob=Table[blob[[ii]]*unitslist[[ii]],{ii,1,numunknowns}];
If[dodebugprint==1,Print["Dblob",Dimensions[blob]];];
(* numunknowns things *)
fsolssp={d->blob[[1]],ux->blob[[2]],rhoc->blob[[3]],iec->blob[[4]],rhoout->blob[[5]],ieout->blob[[6]],Bx->blob[[7]],uy->blob[[8]],Bzc->blob[[9]],Bzout->blob[[10]]};
deltaspfinal=(deltaspfinalotherunits*Lunits);
getconstants;
(*
deltaspfinal;
olddelta/deltaspfinal;
olddeltanewish/deltaspfinal;
*)
Print["Final Errorroot=",errorroot];
(* return error value *)
errorroot
];


(* DONE *)
