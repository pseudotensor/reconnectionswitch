(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* see also gamma_jet _superwrapper.nb *)


AutoGeneratedPackage->Button[Automatic, Inherited, BaseStyle -> "Link", ButtonData -> "paclet:ref/Automatic"]


InitializationCell->True


(* IF ADD NEW CELLS, MUST MAKE THEM INITIALZATION CELL BY GOING TO CELL->CELL PROPERTIES->INITIALZATION CELL *)


(* Setup which things to do *)
doplot=0
dotest=0
dotestcons=0


myMax0[x_]:=Max[x,0];
myMax1[x_]:=Max[x,1];
specialMax[x_]:=Max[x,10^(-1)*c^2];
(*
(* test *)
myMax0[x_]:=x;
myMax1[x_]:=x;
specialMax[x_]:=x;
*)


(* original mueq=2500 *)
(* 50000 gives 10X necessary for Ljet=1E14 and thfp=pi/2 *)
(* 20000 gives 1X for Ljet=1E14 and thfp=pi/2 *)


(* NOTE: consts not setup here if called from gamma_jet _wrapper and then gamma_jet.nb just sets up functions only, not evaluating anything *)
(* if want to test this file by itself, then run below "consts" first *)
(*consts={M->3*msun,rl->G*M/c^2,tl->rl/c,mueq->10000,C0->3,C1->2,C2->0.4,msun->1.989*10^(33), lsun->3.89*10^(33),rsun->695500*10^3*100,G->6.672*10^(-8) ,c->2.99792458*10^(10),nucoll->3/4,rmono->3*10^(10),Br0gauss->10^(15), Br0->Br0gauss/Sqrt[4*Pi],rfp->rl ,rfinal->10^(15),thfinal->0.02,Bphi0->Br0*1.00}*)


(* Uniform omega, vp, rho0 at foot point for now *)
omegafp0[thfp_]:=(1/4)/tl
vpfp0[thfp_]:=1/2*c
rho0fp0[thfp_]:=Br0gauss^2/(8*Pi*mueq*c^2)


If[dotest==1,
(rl/10^5)//.consts
]


(* Set A_\phi *)

aphisimplemono[th_]:=1-Cos[th];
Aphicollpre[r_,th_,mynu_]:=(r/rfp)^mynu*aphisimplemono[th];
ClearAll[thofrpre];
thofrpre[r_?NumericQ,thfp_?NumericQ,theconsts_]:=thofrpre[r,thfp,theconsts]=Module[{result,th,rvar,theconstsvar,functh,rootsol,myrfp,mynucoll},
myrfp=rfp//.theconsts;
mynucoll=nucoll//.theconsts;
functh[rvar_,th_,theconstsvar_]:=(Aphicollpre[myrfp,thfp,mynucoll]==Aphicollpre[rvar,th,mynucoll])//.theconstsvar;
rootsol=FindRoot[functh[r,th,theconsts],{th,thfp},WorkingPrecision->30];
result=rootsol[[1,2]];
(* return *)
result
];

Bprsq[th_?NumericQ,theconsts_]:=Module[{result,myrmono,BB,aa,thetaout,thfpout},
(* From TMN monopole paper *)
BB=0.075/0.85;
(*BB=0; (* TEST *)*)
aa=1.1;
(*aa=1; (* for simplicity *)*)
myrmono=rmono//.theconsts;
thfpout=Pi/2;
thetaout=thofrpre[myrmono,thfpout,theconsts]//.theconsts;
result=1+BB*(Sin[th]^(-aa)-Sin[thetaout]^(-aa));
(* return *)
result
];
(* different assumed vector potentials *)
(*Aphicoll[r_,th_]:=(r/rfp)^nucoll*(1-Cos[th])*)
(*Aphicoll[r_,th_]:=(r/rfp)^nucoll*(1-Cos[th]+BB*Sin[th]);*)
faphi[thin_,theconsts_]:=Module[{result,th},
result=NIntegrate[Bprsq[th,theconsts]*Sin[th],{th,0,thin}];
(* return *)
result
];
Nlth=200;
lth0=-4;
lthf=Log[10,Pi/2];
lth[ii_]:=lth0 + (ii-1)*(lthf-lth0)/(Nlth-1);
faphitable0[theconsts_]:=Table[{10^lth[ii],faphi[10^lth[ii],theconsts]},{ii,1,Nlth}];
faphitable[theconsts_]:=Join[{{0,0}},faphitable0[theconsts]];
ifaphi[th_,theconsts_]:=Interpolation[faphitable[theconsts]][th];

(* rapid change at rmono, while real simulation takes a couple decades *)
finalaphith[r_,th_,theconsts_]:=ifaphi[th,theconsts]*(Exp[-rmono/r])+aphisimplemono[th]*(1-Exp[-rmono/r]);

Aphicollgen[r_,th_,mynu_,theconsts_]:=(r/rfp)^mynu*finalaphith[r,th,theconsts];

(* Probably should have log collimation for monopole *Log[1+r/rfp]^(1/3) *)
(*Aphimono[r_,th_]:=Aphicoll[rmono,th]*Log[1+r/rfp]^(1/2)/Log[1+rmono/rfp]^(1/2)*)
(*Aphimono[r_,th_]:=Aphicoll[rmono,th]*(Exp[Log[1+r/rfp]^(1/3)]/Exp[Log[1+rmono/rfp]^(1/3)])^2*)
(* have to change whichsol below to pick correct root when solving for thfp (r,th) *)

(* now instead using change in nu *)
(*thenufunc[r_]:=nucoll*(1-Exp[-rmono/r])+ 0 *Exp[-rmono/r] ;*)
(* NO, must match Aphi *)

(* Aphicoll more general now -- not just coll but also monopole solution *)
Aphicoll[r_,th_,theconsts_]:=Module[{result,mynucoll},
mynucoll=nucoll//.theconsts;
result=Aphicollgen[r,th,mynucoll,theconsts];
(* return *)
result
];
Aphimono[r_,th_,theconsts_]:=(rmono/rfp)^nucoll*finalaphith[r,th,theconsts];

(* setup temp final A_\phi *)
(*Aphitemp[r_,th_]:=1/Sqrt[(1/Aphicoll[r,th]^2+1/Aphimono[r,th]^2)];*)
(*Aphitemp[r_,th_]:=Aphicoll[r,th]*(1-Exp[-rmono/r])+Aphimono[r,th]*(Exp[-rmono/r]);*)
Aphitemp[r_,th_,theconsts_]:=Module[{result,myrmono},
myrmono=rmono//.theconsts;
result=If[r<myrmono,Aphicoll[r,th,theconsts],Aphimono[r,th,theconsts]];
(* return *)
result
];
(* normalize vector potential *)
Brtemp[r_,th_,theconsts_]:=Module[{daphidth,thvar,daphidthnum,result},
daphidth=D[Aphitemp[r,thvar,theconsts],thvar];
daphidthnum=daphidth//.{thvar->th};
result=daphidthnum/(r^2*Sin[th]);
(* return *)
result
];
(* Br0 is Br at pole: below is kludge because of mathematica bug/inconsistent behavior *)
(* Why at pole?  Can be at equator -- original monopole is constant *)
wheretoeval=0;
wheretoeval=Pi/2;
(*normaphi[r_,th_]=Limit[Evaluate[Brtemp[rfp,thth]//.{th->thth}],thth->wheretoeval];*)
normaphi[theconsts_]:=Module[{result,myrfp},
myrfp=rfp//.theconsts;
result=Brtemp[myrfp,wheretoeval,theconsts];
(* return *)
result
];
(*Aphi[r_,th_]:=FullSimplify[(Br0/normaphi[r,th])*Aphitemp[r,th],{r>0,nucoll>=0,rfp>0,th>=0}]*)
Aphi[r_,th_,theconsts_]:=(Br0/normaphi[theconsts])*Aphitemp[r,th,theconsts];
(* set old A_\phi *)
(*Aphiold[r_,th_,theconsts_]:=(Br0/normaphi[theconsts])*If[r<Evaluate[rmono],Evaluate[Aphicoll[r,th,theconsts]],Evaluate[Aphimono[r,th,theconsts]]];*)


(* test *)
If[dotest==1,
Print[Br0/normaphi[r,th]//.consts];
Print[Aphiold[rfinal,thfinal]//.consts];
Print[Aphi[rfinal,thfinal]//.consts];
]


If[doplot==1,
(* Below is for all plots that follow *)
lowerx=IntegerPart[Log[10,rl]//.consts];
upperx=IntegerPart[Log[10,10^(16)]//.consts];
maxi=20;
mini=1;
Clear[ploti];
x=lowerx+(upperx-lowerx)/(maxi-mini)*(ploti-mini);
thpick=0.02;
]


(* Plot Aphi *)
If[doplot==1,
theth=0.02;
toplot1=Log[10,Aphiold[r,theth]//.consts//.{r->10^x}];
toplot2=Log[10,Aphi[r,theth]//.consts//.{r->10^x}];
lowerx=Log[10,rl//.consts];
upperx=Log[10,10^(16)];
Plot[{toplot1,toplot2},{ploti,mini,maxi}]
]


(* Setup field line trajectory *)
Clear[thfp];
(* NOTE: used to have //.consts below *)
(*
(* too slow to Solve and does not work for general enough Aphi *)
functh=(Aphi[rfp,thfp]==Aphi[r,th]);
Print["Before Solve[functh,th]"];
solsfuncth=Solve[functh,th];
whichsol=2;
tempthofr[r_,thfp_]=FullSimplify[Evaluate[solsfuncth[[whichsol,1,2]]],{r>0,nucoll>=0,rfp>0,th>=0,rmono>0}];
thofr[r_,thfp_]:=Evaluate[tempthofr[r,thfp]];
(* below not used anymore *)
thofrold[r_,thfp_]:=If[r<rmono,ArcCos[1-rfp^nucoll*(1-Cos[thfp])/r^nucoll],ArcCos[1-rfp^nucoll*(1-Cos[thfp])/rmono^nucoll]];
*)
(* theta from radius and foot point angle *)
ClearAll[thofr];
thofr[r_?NumericQ,thfp_?NumericQ,theconsts_]:=thofr[r,thfp,theconsts]=Module[{result,th,rvar,theconstsvar,functh,rootsol,myrfp},
myrfp=rfp//.theconsts;
functh[rvar_?NumericQ,th_?NumericQ,theconstsvar_]:=(Aphi[myrfp,thfp,theconsts]-Aphi[rvar,th,theconsts])//.theconstsvar;
rootsol=FindRoot[0==functh[r,th,theconsts],{th,thfp},WorkingPrecision->30];
result=rootsol[[1,2]];
(* return *)
result
];


(* test *)
If[dotest==1,
thofr[rfinal,1.0]//.consts;
thofrold[rfinal,1.0]//.consts;
]


(* test *)
If[dotest==1,
Print[thofr[rfinal,1.0]//.consts];
Print[thofr[10^(12),1.0]//.consts];
Print[thofr[10^(15),1.0]//.consts];
Print[thofr[rfp,1.0]//.consts];
];


(* Plot thofr *)
If[doplot==1,
thethfp=1.0;
toplot=Log[10,thofr[r,thethfp]//.consts//.{r->10^x}];
lowerx=Log[10,rl//.consts];
upperx=Log[10,10^(16)];
Plot[toplot,{ploti,mini,maxi}]
]


(* setup thfp : assume rfp constant.  This is used to trace back to foot point from given r,th *)
Clear[thfp]
(*
(*not general enough and slow *)
(* NOTE: used to have //.consts below *)
functh=(Aphi[rfp,thfp]==Aphi[r,th]);
Print["Before Solve[functh,thfp]"];
solsfuncth2=Solve[functh,thfp];
whichsol=2;
tempthfpofrth[r_,th_]=FullSimplify[Evaluate[solsfuncth2[[whichsol,1,2]]],{r>0,nucoll>=0,rfp>0,th>=0,rmono>0}];
(* below should always have related r,th pair plugged into it corresponding to a single point in space *)
(* Don't mix up and use thfp=thfpofrth[rfp,th] unless one has func[rfp,thfpofrth[rfp,th]] *)
thfpofrth[r_,th_]:=Evaluate[tempthfpofrth[r,th]];
(* below is not used anymore *)
thfpofrthold[r_,th_]:=If[r<rmono,ArcCos[1-r^nucoll*(1-Cos[th])/rfp^nucoll],ArcCos[1-rmono^nucoll*(1-Cos[th])/rfp^nucoll]]
*)
ClearAll[thfpofrth];
thfpofrth[r_?NumericQ,th_?NumericQ,theconsts_]:=thfpofrth[r,th,theconsts]=Module[{result,thfp,functh,rootsol,myrfp},
myrfp=rfp//.theconsts;
functh[rvar_?NumericQ,thfp_?NumericQ,theconstsvar_]:=(Aphi[myrfp,thfp]==Aphi[rvar,th])//.theconstsvar;
rootsol=FindRoot[functh[r,thfp,theconsts],{thfp,th},WorkingPrecision->30];
result=rootsol[[1,2]];
(* return *)
result
];


(* test *)
If[dotest==1,
Print[thfpofrth[rfinal,thfinal]//.consts];
Print[thfpofrthold[rfinal,thfinal]//.consts];
Print[thfpofrth[rfp,0.5]//.consts];
Print[thfpofrth[rfp,1.0]//.consts];
Print[thfinal*180/Pi//.consts];
]


(* Set omegaf *)
(* Note that omegaf is conserved along field lines, so omegaf can be used for foot point or full function value *)
omegaf[r_,th_,theconsts_]:= omegafp0[thfpofrth[r,th,theconsts]]


(* test *)
If[dotest==1,
Print[rfp*(omegaf[10^15,thfinal,consts]//.consts)/c//.consts];
]


(* Setup field -- now use vector potential *)
(* Write down final Br *)
(*
Brcoll[r_,th_]:= Br0 *(r/rfp)^(nucoll-2) 
Brmono[r_,th_]:= Brcoll[rmono,th] *(r/rmono)^(0-2) 
Brold[r_,th_]:=If[r<Evaluate[rmono],Evaluate[Brcoll[r,th]],Evaluate[Brmono[r,th]]];
*)
(* below presumes Br0 is polar value and that A_\phi already normalized *)
(*dAphidh[r_,th_]=Evaluate[D[Aphi[r,th],th]];
tempBr[r_,th_]=FullSimplify[Evaluate[dAphidh[r,th]]/(r^2*Sin[th]),{r>0,nucoll>=0,rfp>0,th>=0,rmono>0}];
Brnearly[r_,th_,theconsts_]:=Evaluate[tempBr[r,th]];
*)
Brnearly[r_,th_,theconsts_]:=Module[{daphidth,thvar,daphidthnum,result},
daphidth=D[Aphi[r,thvar],thvar];
daphidthnum=daphidth//.{thvar->th};
result=daphidthnum/(r^2*Sin[th]);
(* return *)
result
];


(* test *)
If[dotest==1,
Print[Limit[Brnearly[rfp,thth],thth->0]//.consts];
Print[1.0*Br0//.consts];
Print[(Br0-Limit[Brnearly[rfp,thth],thth->0])//.consts];
]


(* test *)
If[dotest==1,
Print[Brnearly[10^(15),thfinal]//.consts];
Print[Brold[10^(15),thfinal]//.consts];
]


(* Plot Br at a particular angle *)
If[doplot==1,
toplot=Log[10,Brnearly[r,th]//.consts//.{r->10^x,th->0.05}];
lowerx=Log[10,rl//.consts];
upperx=Log[10,10^(16)];
Plot[toplot,{ploti,mini,maxi}]
]


(* Write down final Bh *)
(*Bhcoll[r_,th_]:= Br0*(-nucoll*(r/rfp)^(nucoll-2)*Tan[th/2])
Bhmono[r_,th_]:=0
Bhold[r_,th_]:=If[r<Evaluate[rmono],Evaluate[Bhcoll[r,th]],Evaluate[Bhmono[r,th]]];
dAphidr[r_,th_]=Evaluate[D[Aphi[r,th],r]];
tempBh[r_,th_]=FullSimplify[-(r)*Evaluate[dAphidr[r,th]]/(r^2*Sin[th]),{r>0,nucoll>=0,rfp>0,th>=0,rmono>0}];
Bhnearly[r_,th_]:=Evaluate[tempBh[r,th]];
*)
Bhnearly[r_,th_,theconsts_]:=Module[{daphidr,thvar,daphidrnum,result},
daphidr=D[Aphi[rvar,th],rvar];
daphidrnum=daphidr//.{rvar->r};
result=daphidrnum/(r^2*Sin[th]);
(* return *)
result
];



(* test *)
If[dotest==1,
Print[Bhnearly[10^(10),0.1]//.consts];
]


(* Plot Bh at a particular angle *)
If[doplot==1,
(*toplot1=Log[10,-Bhold[r,th]//.consts//.{r->10^x,th->0.05}];*)
toplot2=Log[10,-Bhnearly[r,th]//.consts//.{r->10^x,th->0.05}];
toplot1=toplot2;
lowerx=Log[10,rl//.consts];
upperx=Log[10,10^(16)];
Plot[{toplot1,toplot2},{ploti,mini,maxi}]
]


(* Write down final Bp *)
(*
tempBp[r_,th_,theconsts_]=FullSimplify[Sqrt[Brnearly[r,th,theconsts]^2+Bhnearly[r,th,theconsts]^2],{r>0,nucoll>=0,rfp>0,th>=0,rmono>0}];
Bpnearly[r_,th_,theconsts_]:=Evaluate[tempBp[r,th,theconsts]];
*)
Bpnearly[r_,th_,theconsts_]:=Sqrt[Brnearly[r,th,theconsts]^2+Bhnearly[r,th,theconsts]^2];


(* test *)
If[dotest==1,
Print[Bpnearly[10^(15),thfinal]//.consts];
]


(* Plot Bp at a particular angle *)
If[doplot==1,
toplot1=Log[10,Brnearly[r,th]//.consts//.{r->10^x,th->0.05}];
toplot2=Log[10,Bpnearly[r,th]//.consts//.{r->10^x,th->0.05}];
lowerx=Log[10,rl//.consts];
upperx=Log[10,10^(16)];
Plot[{toplot1,toplot2},{ploti,mini,maxi}]
]


(* Write down final Bphistart: Actually only used to determine foot point Bphi -- can tweek *)
(* Apparently true pitch angle alpha=arctan (|Brhat/Bphihat|) is smaller than standad result compared to at large radii *)
(* Well, making Bphi0=2Br0 kills the solution at 10rl *)
(* (* NO *) Bphistart[r_,th_,theconsts_]:=Bphistartcoll[r,th,thenufunc[r],theconsts];*)
Bphistartcoll[r_,th_,nuvar_,theconsts_]:=(Bphi0/Br0)*Br0*(-2*rfp*omegaf[r,th,theconsts]/c)*(r/rfp)^(nuvar-1)*Tan[th/2]
Bphistartmono[r_,th_]:=Bphistartcoll[rmono,th] *(r/rmono)^(0-1) 
Bphistart[r_,th_]:=If[r<Evaluate[rmono],Evaluate[Bphistartcoll[r,th]],Evaluate[Bphistartmono[r,th]]];


(* test *)
If[dotest==1,
Print[Bphistart[10^(10),0.1]//.consts];
]


(* Plot Bphistart at a particular angle *)
If[doplot==1,
thpick=0.02;
toplot=Log[10,-Bphistart[r,th]//.consts//.{r->10^x,th->thpick}];
lowerx=Log[10,rl//.consts];
upperx=Log[10,10^(16)];
Plot[toplot,{ploti,mini,maxi}]
]


(* Setup foot point velocities and MHD invariants to project-outward the solution along the given field *)
(* Free parameters are really: Bphistart@fp, omegaf@fp, vp@fp, Bp@fp, rho0@fp, and (Bphistart/Bp)@fp determines unique torque *)
(* Note that omegaffp and maybe Bphifp have some problem with recursion using thfpofrth if kept as formula instead of numerical value *)
Clear[Rfp,omegaffp,Bphifp,Bpfp,vphifp,vsqfp,gammafp,uphifp,vpfp]
vpfp[r_,th_,theconsts_]:=vpfp0[thfpofrth[r,th,theconsts]]
rho0fp[r_,th_,theconsts_]:=rho0fp0[thfpofrth[r,th,theconsts]]
(*omegaffp[r_,th_]:=omegaf[rfp,th,theconsts]*)
(* omegaf[r,th] already uses thfpofrth[r,th], so can't duplicate *)
omegaffp[r_,th_,theconsts_]:=omegaf[rfp,thfpofrth[r,th,theconsts],theconsts]

Rfp[r_,th_,theconsts_]:=rfp*Sin[thfpofrth[r,th,theconsts]]
Bphifp[r_,th_,theconsts_]:=Bphistart[rfp,thfpofrth[r,th,theconsts],theconsts]
Bpfp[r_,th_,theconsts_]:=Bpnearly[rfp,thfpofrth[r,th,theconsts],theconsts] 
vphifp[r_,th_,theconsts_]:=(omegaffp[r,th,theconsts]*Rfp[r,th,theconsts]+Bphifp[r,th,theconsts]*vpfp[r,th,theconsts]/Bpfp[r,th,theconsts])
vsqfp[r_,th_,theconsts_]:=(vpfp[r,th,theconsts]^2+vphifp[r,th,theconsts]^2)
gammafp[r_,th_,theconsts_]:=1/Sqrt[1-(vsqfp[r,th,theconsts]/c^2)]
upfp[r_,th_,theconsts_]:=gammafp[r,th,theconsts]*vpfp[r,th,theconsts]
uphifp[r_,th_,theconsts_]:=vphifp[r,th,theconsts]*gammafp[r,th,theconsts]
(*rho0fp[r_,th_, theconsts_]:=-Bpfp[r,th,theconsts]*omegaffp[r,th,theconsts]*Rfp[r,th,theconsts]*Bphifp[r,th,theconsts]/(mu-gammafp[r,th,theconsts])/upfp[r,th,theconsts]*)
(* Note that \Phi, \lambda, and \mu are conserved along field lines, so can be used anywhere \Phi, \lambda, and \mu full functions needed *)
(* Am I sure I want to use poloidal field and velocity and not r,th? *)
Phi1fp[r_,th_, theconsts_]:=Bpfp[r,th,theconsts]/(rho0fp[r,th,theconsts]*upfp[r,th,theconsts])
Phi2fp[r_,th_, theconsts_]:=Bphifp[r,th,theconsts]/(rho0fp[r,th,theconsts]*(uphifp[r,th,theconsts]-gammafp[r,th,theconsts]*Rfp[r,th,theconsts]*omegaffp[r,th,theconsts]))
lambdafp[r_,th_, theconsts_]:=(Rfp[r,th,theconsts]*(uphifp[r,th,theconsts]-Phi1fp[r,th,theconsts]*Bphifp[r,th,theconsts]))/c
mufp[r_,th_, theconsts_]:=gammafp[r,th,theconsts]-Phi1fp[r,th,theconsts]*omegaffp[r,th,theconsts]*Rfp[r,th,theconsts]*Bphifp[r,th,theconsts]/c^2


(* test *)
If[dotest==1,
Print[(1/c)*Rfp[rfinal,thfinal]*omegaffp[rfinal,thfinal]//.consts];
Print[(1/c)*rfp*omegaffp[rfinal,thfinal]//.consts];
Print[gammafp[rfp,thfpofrth[rfp,1.5],consts]//.consts];
Print[myrho0=rho0fp[rfp,thfpofrth[rfp,1.5]]//.consts];
Print[myBp0=Bpfp[rfp,thfpofrth[rfp,1.5]]//.consts];
Print[fakemu=myBp0^2/(myrho0*c^2)//.consts];
Print[mufp[rfp,thfpofrth[rfp,1.5]]//.consts];
]


(* Setup 1st asymptotic *)
Clear[R,Rfunc,gamma1,gamma2]
R=r*Sin[th];
Rfunc[r_,th_,theconsts_]:=r*Sin[th]
gamma1dep[r_,th_, theconsts_]:=Sqrt[myMax0[(omegaf[r,th,theconsts]*Rfunc[r,th,theconsts]/c)^2-(omegaffp[r,th,theconsts]*Rfp[r,th,theconsts]/c)^2]]
gamma1[r_,th_, theconsts_]:=Sqrt[myMax1[gamma0^2 + gamma1dep[r,th,theconsts]^2]]

(* Setup 2nd asymptotic -- but avoid division by zero *)
nu[r_]:=If[r>rmono,10^(-30),nucoll]
gamma2[r_,th_, theconsts_]:=(2/th)*Sqrt[myMax0[C0/((2-nu[r])*nu[r])]]

(* get final force-free result *)
eqgammaff=1/gammaff^2 ==1/gamma1[r,th,theconsts]^2 +1/gamma2[r,th,theconsts]^2;
Print["Before Solve[eqgammaff,gammaff]"];
solsgammaff=Solve[eqgammaff,gammaff];
mygammaff[r_,th_, theconsts_]:=Evaluate[solsgammaff[[2,1,2]]](* Obtain semi-final collimating solution for Lorentz factor *)
mysemigammacoll[r_,th_, theconsts_]:=1/(1/mufp[r,th,theconsts] + 1/Evaluate[mygammaff[r,th,theconsts]])


(* Test *)
If[dotest==1,
Print[gamma1[10^(10),0.02]//.consts];
Print[(gamma0-gamma1[rfp,thfpofrth[rfp,0.02]]//.consts)];
]


(* Test *)
If[dotest==1,
rtest=10^(10);
thtest=thofr[rtest,Pi/2];
Print[gamma2[10^(10),0.2]//.consts];
Print[gamma2[10^(10),thtest]//.consts];
]


(* Find/Set gamma0 *)
(* Use findroot because depends non-trivially on r,th *)
(* Use findroot instead of Nsolve to force single solution that is positive and real *)
(* Have to push consts here since needs to resolve to number when doing findroot *)
(*eqgamma0=(gammafp[r,th,theconsts]==mysemigammacoll[rfp,thfpofrth[r,th,theconsts],theconsts]);
mygamma0old[rr_,thth_]:=FindRoot[eqgamma0//.{r->rr,th->thth}//.consts,{gamma0,2}][[1,2]]*)
(* NO, of course, can solve for gamma0 directly in terms of things *)
mygamma0[r_,th_, theconsts_]:=Module[{result,myrfp},
myrfp=rfp//.theconsts;
result=Sqrt[myMax1[1/( (1/gammafp[r,th,theconsts]-1/mufp[r,th,theconsts])^2-1/gamma2[myrfp,thfpofrth[r,th,theconsts],theconsts]^2) - gamma1dep[myrfp,thfpofrth[r,th,theconsts],theconsts]^2]];
(* return *)
result
];
(* The max is used only in rare cases, such as at very small foot point angles where this approximation doesn't apply *)


(* test *)
If[dotest==1,
Print[mygamma0[rfp,1.0]//.consts];
myr=rfp//.consts;
Print[mygamma0[myr,1.0]//.consts];

testr=10^(15);
testth=0.02;
Print[mygamma0[testr,testth]//.consts];
Print[mygamma0[testr,testth]//.consts];
]


(* test *)
If[dotest==1,
testr=rfp//.consts;
testth=Pi/2;
Print[mygamma0[testr,testth]//.consts];
Print[(mysemigammacoll[testr,testth]//.consts)//.{gamma0->mygamma0[testr,testth]}//.consts];
Print[gammafp[testr,testth]//.consts];
]


(* Obtain true final collimating solution for Lorentz factor *)
mygammacoll[r_,th_, theconsts_]:=myMax1[mysemigammacoll[r,th,theconsts]//.{gamma0->mygamma0[r,th,theconsts]}]


(* test *)
If[dotest==1,
Print[mygammacoll[rfinal,thfinal]//.consts];
thtest=1.0;
thtest=thfpofrth[rfp,thtest]//.consts;
(* warning: super expensive to stick in thfpofrth into below directly *)
Print[mygammacoll[rfp,thtest]//.consts];
Print[mygammacoll[10^(10),thfinal]//.consts];
]


(* Setup monopole jet solution *)
thjc=th;
(*rc=mufpfunc^(1/3)/(omegaffunc/c*Sin[thjc]^(5/3));*)
(*eqgamma2m=
gamma2m==C1*(mufpfunc-gamma2m)^(1/3)*Log[1+C2*r/rc]^(1/3)/Sin[thjc]^(2/3);*)
gammac=(mufpfunc/Sin[thjc]^2)^(1/3);
eqgamma2m=
gamma2m==C1*((mufpfunc-gamma2m)/Sin[thjc]^2*Log[1+C2*r*omegaffunc/c*Sin[thjc]/gammac])^(1/3);
(*eqgamma2m=
gamma2m==C1*((mu-gamma2m)/Sin[thjc]^2)^(1/3)*)


(* Solve for monopole gamma2 *)
Print["Before Solve[eqgamma2m,gamma2m]"];
solsmygamma2m=Solve[eqgamma2m,gamma2m];
(* never clear solsmygamma2m since used during runtime to find correct root *)
Clear[mygamma2m];
(* need to determine which is correct root *)

(* Well, below is ok, but don't know Ljet and thetajet here when running solution! *)
(*
allrootsnum=solsmygamma2m//.{mufpfunc->mufp[r,th,theconsts],omegaffunc->omegaf[r,th,theconsts]}//.consts//.{r->Ljet,th->thetajet};
dimallroots=Dimensions[allrootsnum][[1]];
allrootsnumreal=Table[Abs[Re[allrootsnum[[iroots,1,2]]]],{iroots,1,dimallroots}];
allrootsnumimaginary=Table[Abs[Im[allrootsnum[[iroots,1,2]]]],{iroots,1,dimallroots}];
(* choose root with smallest absolute imaginary part -- not 1 or \mu is always reference value *)
BADIMAGINARY=Infinity;
For[iroots=1,iroots<=dimallroots,
If[allrootsnumimaginary[[iroots]]<BADIMAGINARY,BADIMAGINARY=allrootsnumimaginary[[iroots]],chosenroot=iroots;];
iroots++;
];
mygamma2m[r_,th_, theconsts_]:=Evaluate[solsmygamma2m[[1,1,2]]//.{mufpfunc->mufp[r,th,theconsts],omegaffunc->omegaf[r,th,theconsts]}]
*)


Print["Before mygamma2m"];
mygamma2m[rinput_?NumericQ,thinput_?NumericQ,localconsts_]:=Module[{foo,allrootsnum,dimallroots,allrootsnumreal,allrootsnumimaginary,BADIMAGINARY,iroots,chosenroot,result},
allrootsnum=solsmygamma2m/.{mufpfunc->mufp[rinput,thinput],omegaffunc->omegaf[rinput,thinput]}//.localconsts//.{r->rinput,th->thinput};
dimallroots=Dimensions[allrootsnum][[1]];
allrootsnumreal=Table[Abs[Re[allrootsnum[[iroots,1,2]]]],{iroots,1,dimallroots}];
allrootsnumimaginary=Table[Abs[Im[allrootsnum[[iroots,1,2]]]],{iroots,1,dimallroots}];
(* choose root with smallest absolute imaginary part -- not 1 or \mu is always reference value *)
BADIMAGINARY=Infinity;
For[iroots=1,iroots<=dimallroots,
If[allrootsnumimaginary[[iroots]]<BADIMAGINARY,BADIMAGINARY=allrootsnumimaginary[[iroots]];chosenroot=iroots;];
iroots++;
];
(*
Print["chosenroot=",chosenroot];
Print["allrootsnumreal="allrootsnumreal];
*)
result=myMax1[allrootsnumreal[[chosenroot]]];
(* return *)
result
];

(* 1 not generally correct root *)
(*
mygamma2m[r_,th_,consts_]:=Evaluate[solsmygamma2m[[1,1,2]]//.{mufpfunc->mufp[r,th,theconsts],omegaffunc->omegaf[r,th,theconsts]}]
*)





(* Obtain final monopole solution for Lorentz factor *)
(*eqgammamono=1/gammamono^2 ==1/gamma1^2 +1/gamma2m^2;
solsgammamono=Solve[eqgammamono,gammamono]
mysemigammamono[r_,th_, theconsts_]:=Evaluate[solsgammamono[[2,1,2]]//.{gamma1->gamma1[r,th,theconsts],gamma2m->mygamma2m[r,th,theconsts]}]*)
(* below use of mygamma2m assumes consts are set to be numbers *)
mysemigammamonotemp[r_,th_, theconsts_]:=1/Sqrt[1/gamma1[r,th,theconsts]^2+1/mygamma2m[r,th,consts]^2]
(*mysemigammamono[r_,th_, theconsts_]:=1/(1/mufp[r,th,theconsts]+1/mysemigammamonotemp[r,th,theconsts])*)
(* Don't use reciprical sum for monopole since should already be limited and would cause efficiency to always be 1/2 at most! *)
(* So only place strict limit -- as consistent with paper anyways *)
mysemigammamono[r_,th_, theconsts_]:=Max[Min[mufp[r,th,theconsts],mysemigammamonotemp[r,th,theconsts]],1];


(* Find/Set gamma0 for monopole solution *)
(*eqgammamono0=(gammafp[r,th,theconsts]==mysemigammamono[rfp,thfpofrth[r,th,theconsts],theconsts]);
mygammamono0old[rr_,thth_]:=FindRoot[Evaluate[eqgammamono0//.{r->rr,th->thth}//.consts],{gamma0,2}][[1,2]]*)
(* below use of mygamma2m assumes consts are set to be numbers *)
mygammamono0[r_,th_, theconsts_]:=Module[{result,myrfp,mytheta,resultsq},
myrfp=rfp//.consts; (* needed so mygamma2m gets a numerical value for rfp *)
mytheta=thfpofrth[r,th,theconsts]//.consts;
resultsq=1/( (1/gammafp[r,th,theconsts]-1/mufp[r,th,theconsts])^2-1/mygamma2m[myrfp,mytheta,consts]^2) - gamma1dep[myrfp,thfpofrth[r,th,theconsts]]^2;
result=Sqrt[myMax1[resultsq]];
(* return *)
result
];
(* don't mix monopole with \n u limit. -- well, need limit still near pole *)


(* test*)
If[dotest==1,
testr=rfp//.consts;
testth=0.5;
gammafp[testr,testth]//.consts;
]


(* test *)
If[dotest==1,
testr=rfp//.consts;
testth=0.5;
Print[mygammamono0old[testr,testth]//.consts];
Print[mygammamono0[testr,testth]//.consts];
testth=Evaluate[thfpofrth[testr,testth]//.consts];
Print[mygammamono0[testr,testth]//.consts];
Print[(mysemigammamono[testr,testth]//.consts)//.{gamma0->mygammamono0[testr,testth]}//.consts];
Print[gammafp[testr,testth]//.consts];
]


(* Obtain true final monopole solution for Lorentz factor *)
mygammamono[r_,th_, theconsts_]:=myMax1[mysemigammamono[r,th,theconsts]//.{gamma0->mygammamono0[r,th,theconsts]}]


(* Test *)
If[dotest==1,
Print[mygammamono[10^(10),thfinal]//.consts];
]


(* Write down final gamma that includes collimating and monopole branches *)
mygammafinal[r_,th_, theconsts_]:=If[r<Evaluate[rmono],Evaluate[mygammacoll[r,th,theconsts]],Evaluate[mygammamono[r,th,theconsts]]];


(* Test *)
If[dotest==1,
Print[mygammafinal[1.0*10^(10),thfinal]//.consts];
rtest=rfp//.consts;
thtest=thfpofrth[rfp,0.5]//.consts;
Print[(mygammafinal[rtest,thtest]-gammafp[rtest,thtest])//.consts];
]


(* Plot \Gamma at a particular angle *)
If[doplot==1,
mufptbl=Table[{x,(Log[10,mufp[10^x,thpick]//.consts])},{ploti,mini,maxi}];
gammatbl=Table[{x,(Log[10,(mygammafinal[10^x,thpick]//.consts)])},{ploti,mini,maxi}];
p1=ListPlot[mufptbl,Joined->True,PlotStyle->Red];
p2=ListPlot[gammatbl,Joined->True,PlotStyle->Black];
Show[{p1,p2}]
]


(* Setup u_\phi using angular momentum conservation *)
uphi[r_,th_, theconsts_]:=(myMax0[mygammafinal[r,th,theconsts]-gammafp[r,th,theconsts]]+Rfp[r,th,theconsts]*omegaffp[r,th,theconsts]*uphifp[r,th,theconsts]/c^2)/((Rfunc[r,th,theconsts]*omegaf[r,th,theconsts])/c^2)


(* test *)
If[dotest==1,
Print[(1/c)uphi[10^(15),0.01]//.consts];
rtest=rfp//.consts;
thtest=thfpofrth[rfp,1.0]//.consts;
Print[(1/c)*uphi[rtest,thtest]//.consts];
]


(* Plot u_\phi/c at a particular angle *)
If[doplot==1,
tbl=Table[{x,(Log[10,(1/c)*uphi[10^x,thpick]//.consts])},{ploti,mini,maxi}];
ListPlot[tbl,Joined->True,PlotStyle->Black]
]


(* Setup u_p *)
vpother=uppother/sgamma
vphiother=uphother/sgamma
vsqother=vpother^2+vphiother^2
myeq=sgamma^2==1/(1-vsqother/c^2)
Print["Before Solve[myeq,sgamma]"];
solssgamma=Solve[myeq,sgamma]
mygammaofu=solssgamma[[2,1,2]]
Print["Before Solve[myeq,uppother]"];
solsuppother=Solve[myeq,uppother]





(* force up to not be super small so no division by 0 later *)
up[r_,th_, theconsts_]:=ReleaseHold[Sqrt[specialMax[(Hold[mygammafinal[r,th,theconsts]]^2-1)*c^2-Hold[uphi[r,th,theconsts]]^2]]];
(*up[r_,th_, theconsts_]:=ReleaseHold[Sqrt[(Hold[mygammafinal[r,th,theconsts]]^2-1)*c^2-Hold[uphi[r,th,theconsts]]^2]]*)
v3p[r_,th_, theconsts_]:=up[r,th,theconsts]/mygammafinal[r,th,theconsts];


(* test*)
If[dotest==1,
Print[(1/c)*up[10^(15),thfinal]//.consts];
rtest=rfp//.consts;
thtest1=thfpofrth[rfp,1.0]//.consts;
Print[(1/c)*up[rtest,thtest1]//.consts];
thtest2=thfpofrth[rfp,0.5]//.consts;
Print[(1/c)*up[rtest,thtest2]//.consts];
Print[(1/c//.consts)*(gammafp[rtest,thtest1]//.consts)*(vpfp[rtest,1.0]//.consts)];
Print[(1/c//.consts)*(gammafp[rtest,thtest2]//.consts)*(vpfp[rtest,0.5]//.consts)];
]


(* Plot u_p/c at a particular angle *)
If[doplot==1,
tbl=Table[{x,(Log[10,(1/c)*up[10^x,thpick]//.consts])},{ploti,mini,maxi}];
ListPlot[tbl,Joined->True,PlotStyle->Black]
]







(* NOW DONE WITH gamma and have initial Br, Bh, Bphi *)








(* setup rho0 using \Phi1 *)
(*rho0[r_,th_, theconsts_]:=rho0fp[r,th,theconsts]*(Bpnearly[r,th,theconsts]/Bpnearly[rfp,thfpofrth[r,th,theconsts],theconsts])*(up[rfp,thfpofrth[r,th,theconsts],theconsts]/up[r,th,theconsts])*)
rho0nearly[r_,th_, theconsts_]:=Bpnearly[r,th,theconsts]/(up[r,th,theconsts]*Phi1fp[r,th,theconsts])


(* Setup ur and uh *)
ur[r_,th_, theconsts_]:=Brnearly[r,th,theconsts]/(rho0nearly[r,th,theconsts]*Phi1fp[r,th,theconsts])
uh[r_,th_, theconsts_]:=Bhnearly[r,th,theconsts]/(rho0nearly[r,th,theconsts]*Phi1fp[r,th,theconsts])


(* test *)
If[dotest==1,
rtest=rfp//.consts;
thtest=thfpofrth[rfp,1.0]//.consts;
Print[testrhofp=rho0nearly[rtest,thtest]//.consts];
Print[testBp=Bpfp[rtest,thtest]//.consts];
Print[fakemu=testBp^2/(testrhofp*c^2)//.consts];
Print[mufp[rtest,thtest]/fakemu//.consts];
Print[rho0nearly[10^(15),thfinal]//.consts];
]


(* Plot rho0 at a particular angle *)
If[doplot==1,
tbl=Table[{x,(Log[10,rho0nearly[10^x,thpick]//.consts])},{ploti,mini,maxi}];
ListPlot[tbl,Joined->True,PlotStyle->Black]
]


(* Write down final true Bphi that uses stationary condition so consistent beyond monopole part -- overwrites original Bphi that is only used to get foot point mu and uphi, and the foot point value shouldn't change *)
(*Bphi[r_,th_, theconsts_]:=(Bpnearly[r,th,theconsts]/up[r,th,theconsts])*(uphi[r,th,theconsts]-mygammafinal[r,th,theconsts]*Rfunc[r,th,theconsts]*omegaf[r,th,theconsts])*)
(* use \mu to get Bphi so constrain it to be constant.  If repeatedly use \Phi, won't correct so that all invariants are constant *)
Bphinearly[r_,th_, theconsts_]:=-(mufp[r,th,theconsts]-mygammafinal[r,th,theconsts])*c^2/(Phi1fp[r,th,theconsts]*Rfunc[r,th,theconsts]*omegaf[r,th,theconsts])


(* test *)
If[dotest==1,
Print[rtest=rfp//.consts];
Print[thtest=thfpofrth[rtest,1.0]//.consts];
Print[Bphinearly[10^(10),0.02]//.consts];
Print[Bphinearly[10^(15),0.02]//.consts];
Print[Bphinearly[rtest,1.0]//.consts];
Print[Bphistart[rtest,1.0]//.consts];
Print[Bphinearly[rtest,1.4]//.consts];
Print[Bphistart[rtest,1.4]//.consts];
]


(* Plot Bphi at a particular angle *)
If[doplot==1,
tbl1=Table[{x,(Log[10,-Bphistart[10^x,thpick]//.consts])},{ploti,mini,maxi}];
tbl2=Table[{x,(Log[10,-Bphinearly[10^x,thpick]//.consts])},{ploti,mini,maxi}];
p1=ListPlot[tbl1,Joined->True,PlotStyle->Red];
p2=ListPlot[tbl2,Joined->True,PlotStyle->Black];
Show[{p1,p2}]
]


(* other useful relations *)
udotBnearly[r_,th_, theconsts_]:=uphi[r,th,theconsts]*Bphinearly[r,th,theconsts]+up[r,th,theconsts]*Bpnearly[r,th,theconsts]
Bsqnearly[r_,th_, theconsts_]:=Bphinearly[r,th,theconsts]^2+Bpnearly[r,th,theconsts]^2
bsqnearly[r_,th_, theconsts_]:=(Bsqnearly[r,th,theconsts]+(udotBnearly[r,th,theconsts]/c)^2)/mygammafinal[r,th,theconsts]^2
(* bsq/2 not bsq/(8*Pi) since all quantities converted to HL units already *)
(*Pm[r_,th_, theconsts_]:=bsqnearly[r,th,theconsts]/2*)



If[1==0,
(* Correct B's to force |b|(\theta)=constant *)
(* fcorr is expensive, so store results *)
fcorr[r_,th_,theconsts_]:=fcorr[r,th,theconsts]=Module[{foo,thvar,thf,thetaout,Phitot,numer,denom,integrandphi,integranddenom,result,myr,thfpout},
(* Assuming thetaout=pi/2 !! *)
myr=r//.theconsts;
thfpout=Pi/2;
thetaout=thofr[myr,thfpout]//.theconsts;
(* total flux *)
integrandphi[thf_?NumericQ]:=(Brnearly[myr,thf,theconsts]*myr^2*Sin[thf])//.theconsts;
Phitot=NIntegrate[integrandphi[thvar],{thvar,0,thetaout},AccuracyGoal->Infinity,PrecisionGoal->4,WorkingPrecision->15];
numer=Phitot/Sqrt[bsqnearly[myr,th,theconsts]]//.theconsts;
integranddenom[thf_?NumericQ]:=(Brnearly[myr,thf]*myr^2*Sin[thf]/Sqrt[bsqnearly[myr,thf,theconsts]])//.theconsts;
(* denom takes a very long time *)
Print["start computing denom"];
denom=NIntegrate[integranddenom[thvar],{thvar,0,thetaout},AccuracyGoal->Infinity,PrecisionGoal->1,WorkingPrecision->3];
Print["finished computing denom"];
result=(numer/denom)//.theconsts;
(* return *)
result
];

];
If[1==1,
fcorr[r_,th_,theconsts_]:=1;
];

(* now correct *)
(* assume Bphifp and Bpfp are roughly fixed, else need to iterate on other things and more painful *)
Bh[r_,th_,theconsts_]:=Bhnearly[r,th,theconsts]*fcorr[r,th,theconsts];
Br[r_,th_,theconsts_]:=Brnearly[r,th,theconsts]*fcorr[r,th,theconsts];
Bphi[r_,th_,theconsts_]:=Bphinearly[r,th,theconsts]*fcorr[r,th,theconsts];
(* Notice that ur,uh,up don't depend upon f (theta) since when using rho0 the correction would cancel with other B, so those don't change *)
(* now correct dependent things computed or used so far *)
Bp[r_,th_,theconsts_]:=Sqrt[Br[r,th,theconsts]^2+Bh[r,th,theconsts]^2];
rho0[r_,th_,theconsts_]:=Bp[r,th,theconsts]/(up[r,th,theconsts]*Phi1fp[r,th,theconsts]);
udotB[r_,th_,theconsts_]:=uphi[r,th,theconsts]*Bphi[r,th,theconsts]+up[r,th,theconsts]*Bp[r,th,theconsts];
Bsq[r_,th_,theconsts_]:=Bphi[r,th,theconsts]^2+Bp[r,th,theconsts]^2;
bsq[r_,th_,theconsts_]:=(Bsq[r,th,theconsts]+(udotB[r,th,theconsts]/c)^2)/mygammafinal[r,th,theconsts]^2;
(* done with corrections for |b|=const (\theta) *)



mutest[r_,th_,theconsts_]:=mygammafinal[r,th,theconsts]-Phi1fp[r,th,theconsts]*omegaf[r,th,theconsts]*Rfunc[r,th,theconsts]*Bphi[r,th,theconsts]/c^2
dpowermavsthdtheta[r_?NumericQ,th_?NumericQ,theconsts_]:=Module[{result},
result=2*Pi*r^2*Sin[th]*mygammafinal[r,th,theconsts]*rho0[r,th,theconsts]*c^2*up[r,th,theconsts]//.theconsts;
result
];
omegaftest[r_,th_, theconsts_]:=omegaf[r,th,theconsts]
lambdatest[r_,th_,theconsts_]:=(Rfunc[r,th,theconsts]*(uphi[r,th,theconsts]-Phi1fp[r,th,theconsts]*Bphi[r,th,theconsts]))/c
Phi1test[r_,th_,theconsts_]:=Bp[r,th,theconsts]/(rho0[r,th,theconsts]*up[r,th,theconsts])
Phi2test[r_,th_,theconsts_]:=Bphi[r,th,theconsts]/(rho0[r,th,theconsts]*(uphi[r,th,theconsts]-mygammafinal[r,th,theconsts]*Rfunc[r,th,theconsts]*omegaf[r,th,theconsts]))
sigmatest[r_,th_,theconsts_]:=-Phi1fp[r,th,theconsts]*Rfunc[r,th,theconsts]*omegaf[r,th,theconsts]*Bphi[r,th,theconsts]/(c^2*mygammafinal[r,th,theconsts])
(* below gives issue with args being less than MachinePrecision=WorkingPrecision *)
dpowervsthdtheta[r_?NumericQ,th_?NumericQ,theconsts_]:=Module[{result},
result=2*Pi*r^2*Sin[th]*mutest[r,th,theconsts]*rho0[r,th,theconsts]*c^2*up[r,th,theconsts]//.theconsts;
result
];
powervsth[r_,thf_,theconsts_]:=Module[{result,th},
result=NIntegrate[dpowervsthdtheta[r,th,theconsts],{th,0,thf},AccuracyGoal->Infinity,PrecisionGoal->2,WorkingPrecision->10];
result
];
powermavsth[r_,thf_,theconsts_]:=Module[{result,th},
result=NIntegrate[dpowermavsthdtheta[r,th,theconsts],{th,0,thf},AccuracyGoal->Infinity,PrecisionGoal->2,WorkingPrecision->10];
result
];





If[dotestcons==1,
(* Ensure conservation along field lines: use thofr[r,thfp] for theta with fixed thfp *)
(* Note, did not insert thofr[] into test functions because super slow due to crazy replacements *)
thfp=1.0//.consts;
thfp=(Pi/2)//.consts;
rtest=rfp//.consts;
Print[powervsth[rtest,Pi/2,consts]];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[mufp[rtest,thtest]//.consts];
rtest=rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[mutest[rtest,thtest,consts]//.consts];
rtest=10*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[mutest[rtest,thtest,consts]//.consts];
rtest=10^5*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[mutest[rtest,thtest,consts]//.consts];
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[mutest[rtest,thtest,consts]//.consts];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[omegaffp[rtest,thtest]//.consts];
rtest=rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[omegaftest[rtest,thtest,consts]//.consts];
rtest=10*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[omegaftest[rtest,thtest,consts]//.consts];
rtest=10^5*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[omegaftest[rtest,thtest,consts]//.consts];
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[omegaftest[rtest,thtest,consts]//.consts];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[lambdafp[rtest,thtest]//.consts];
rtest=rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[lambdatest[rtest,thtest,consts]//.consts];
rtest=10*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[lambdatest[rtest,thtest,consts]//.consts];
rtest=10^5*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[lambdatest[rtest,thtest,consts]//.consts];
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[lambdatest[rtest,thtest,consts]//.consts];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi1fp[rtest,thtest]//.consts];
rtest=rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi1test[rtest,thtest,consts]//.consts];
rtest=10*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi1test[rtest,thtest,consts]//.consts];
rtest=10^5*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi1test[rtest,thtest,consts]//.consts];
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi1test[rtest,thtest,consts]//.consts];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi2fp[rtest,thtest]//.consts];
rtest=rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi2test[rtest,thtest,consts]//.consts];
rtest=10*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi2test[rtest,thtest,consts]//.consts];
rtest=10^5*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi2test[rtest,thtest,consts]//.consts];
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi2test[rtest,thtest,consts]//.consts];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[sigmatest[rtest,thtest,consts]//.consts];
rtest=rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[sigmatest[rtest,thtest,consts]//.consts];
rtest=10*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[sigmatest[rtest,thtest,consts]//.consts];
rtest=10^5*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[sigmatest[rtest,thtest,consts]//.consts];
rtest=10^(14)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[sigmatest[rtest,thtest,consts]//.consts];
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[sigmatest[rtest,thtest,consts]//.consts];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[udotB[rtest,thtest,consts]//.consts];
Print[Bsq[rtest,thtest,consts]//.consts];
Print[bsq[rtest,thtest,consts]//.consts];
Print[v3p[rtest,thtest]//.consts];
Print[(bsq[rtest,thtest,consts]/(rho0[rtest,thtest,consts]*c^2))//.consts];
]


(* test *)
If[dotestcons==1,
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[udotB[rtest,thtest,consts]//.consts];
Print[Bsq[rtest,thtest,consts]//.consts];
Print[bsq[rtest,thtest,consts]//.consts];
Print[v3p[rtest,thtest,consts]//.consts];
Print[(bsq[rtest,thtes,constst]/(rho0[rtest,thtest,consts]*c^2))//.consts];
]
