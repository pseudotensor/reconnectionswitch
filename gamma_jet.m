(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* see also gamma_jet _superwrapper.nb *)


AutoGeneratedPackage->Button[Automatic, Inherited, BaseStyle -> "Link", ButtonData -> "paclet:ref/Automatic"]


InitializationCell->True


(* IF ADD NEW CELLS, MUST MAKE THEM INITIALZATION CELL BY GOING TO CELL->CELL PROPERTIES->INITIALZATION CELL *)


(* Setup which things to do *)
doplot=0
dotest=0
dotestcons=0


myMax0[x_]:=Max[x,0];
myMax1[x_]:=Max[x,1];
specialMax[x_]:=Max[x,10^(-1)*c^2];
(*
(* test *)
myMax0[x_]:=x;
myMax1[x_]:=x;
specialMax[x_]:=x;
*)


(* original mueq=2500 *)
(* 50000 gives 10X necessary for Ljet=1E14 and thfp=pi/2 *)
(* 20000 gives 1X for Ljet=1E14 and thfp=pi/2 *)


(* NOTE: consts not setup here if called from gamma_jet _wrapper and then gamma_jet.nb just sets up functions only, not evaluating anything *)
(* if want to test this file by itself, then run below "consts" first *)
(*consts={M->3*msun,rl->G*M/c^2,tl->rl/c,mueq->10000,C0->3,C1->2,C2->0.4,msun->1.989*10^(33), lsun->3.89*10^(33),rsun->695500*10^3*100,G->6.672*10^(-8) ,c->2.99792458*10^(10),nucoll->3/4,rmono->3*10^(10),Br0gauss->10^(15), Br0->Br0gauss/Sqrt[4*Pi],rfp->rl ,rfinal->10^(15),thfinal->0.02,Bphi0->Br0*1.00}*)


(* Uniform omega, vp, rho0 at foot point for now *)
omegafp0[thfp_]:=(1/4)/tl
vpfp0[thfp_]:=1/2*c
rho0fp0[thfp_]:=Br0gauss^2/(8*Pi*mueq*c^2)


If[dotest==1,
(rl/10^5)//.consts
]


(* Set A_\phi *)
(* Probably should have log collimation for monopole *Log[1+r/rfp]^(1/3) *)
(*Aphimono[r_,th_]:=Aphicoll[rmono,th]*Log[1+r/rfp]^(1/2)/Log[1+rmono/rfp]^(1/2)*)
(*Aphimono[r_,th_]:=Aphicoll[rmono,th]*(Exp[Log[1+r/rfp]^(1/3)]/Exp[Log[1+rmono/rfp]^(1/3)])^2*)
(* have to change whichsol below to pick correct root when solving for thfp (r,th) *)
Aphimono[r_,th_]:=Aphicoll[rmono,th]


Aphicoll[r_,th_]:=(r/rfp)^nucoll*(1-Cos[th])

(* setup temp final A_\phi *)
Aphitemp[r_,th_]:=1/Sqrt[(1/Aphicoll[r,th]^2+1/Aphimono[r,th]^2)];
(* normalize vector potential *)
tempaphitemp[r_,th_]=D[Aphitemp[r,th],th];
Brtemp[r_,th_]:=Evaluate[tempaphitemp[r,th]]/(r^2*Sin[th])
(* Br0 is Br at pole: below is kludge because of mathematica bug/inconsistent behavior *)
normaphi[r_,th_]=Limit[Evaluate[Brtemp[rfp,thth]//.{th->thth}],thth->0];
Aphi[r_,th_]:=FullSimplify[(Br0/normaphi[r,th])*Aphitemp[r,th],{r>0,nucoll>=0,rfp>0,th>=0}]
(* set old A_\phi *)
Aphiold[r_,th_]:=(Br0/normaphi[r,th])*If[r<Evaluate[rmono],Evaluate[Aphicoll[r,th]],Evaluate[Aphimono[r,th]]];


(* test *)
If[dotest==1,
Print[Br0/normaphi[r,th]//.consts];
Print[Aphiold[rfinal,thfinal]//.consts];
Print[Aphi[rfinal,thfinal]//.consts];
]


If[doplot==1,
(* Below is for all plots that follow *)
lowerx=IntegerPart[Log[10,rl]//.consts];
upperx=IntegerPart[Log[10,10^(16)]//.consts];
maxi=20;
mini=1;
Clear[ploti];
x=lowerx+(upperx-lowerx)/(maxi-mini)*(ploti-mini);
thpick=0.02;
]


(* Plot Aphi *)
If[doplot==1,
theth=0.02;
toplot1=Log[10,Aphiold[r,theth]//.consts//.{r->10^x}];
toplot2=Log[10,Aphi[r,theth]//.consts//.{r->10^x}];
lowerx=Log[10,rl//.consts];
upperx=Log[10,10^(16)];
Plot[{toplot1,toplot2},{ploti,mini,maxi}]
]


(* Setup field line trajectory *)
Clear[thfp];
(* NOTE: used to have //.consts below *)
functh=(Aphi[rfp,thfp]==Aphi[r,th]);
Print["Before Solve[functh,th]"];
solsfuncth=Solve[functh,th];
whichsol=2;
tempthofr[r_,thfp_]=FullSimplify[Evaluate[solsfuncth[[whichsol,1,2]]],{r>0,nucoll>=0,rfp>0,th>=0,rmono>0}];
thofr[r_,thfp_]:=Evaluate[tempthofr[r,thfp]];
(* below not used anymore *)
thofrold[r_,thfp_]:=If[r<rmono,ArcCos[1-rfp^nucoll*(1-Cos[thfp])/r^nucoll],ArcCos[1-rfp^nucoll*(1-Cos[thfp])/rmono^nucoll]];


(* test *)
If[dotest==1,
thofr[rfinal,1.0]//.consts;
thofrold[rfinal,1.0]//.consts;
]


(* test *)
If[dotest==1,
Print[thofr[rfinal,1.0]//.consts];
Print[thofr[10^(12),1.0]//.consts];
Print[thofr[10^(15),1.0]//.consts];
Print[thofr[rfp,1.0]//.consts];
];


(* Plot thofr *)
If[doplot==1,
thethfp=1.0;
toplot=Log[10,thofr[r,thethfp]//.consts//.{r->10^x}];
lowerx=Log[10,rl//.consts];
upperx=Log[10,10^(16)];
Plot[toplot,{ploti,mini,maxi}]
]


(* setup thfp : assume rfp constant.  This is used to trace back to foot point from given r,th *)
Clear[thfp]
(* NOTE: used to have //.consts below *)
functh=(Aphi[rfp,thfp]==Aphi[r,th]);
Print["Before Solve[functh,thfp]"];
solsfuncth2=Solve[functh,thfp];
whichsol=2;
tempthfpofrth[r_,th_]=FullSimplify[Evaluate[solsfuncth2[[whichsol,1,2]]],{r>0,nucoll>=0,rfp>0,th>=0,rmono>0}];
(* below should always have related r,th pair plugged into it corresponding to a single point in space *)
(* Don't mix up and use thfp=thfpofrth[rfp,th] unless one has func[rfp,thfpofrth[rfp,th]] *)
thfpofrth[r_,th_]:=Evaluate[tempthfpofrth[r,th]];
(* below is not used anymore *)
thfpofrthold[r_,th_]:=If[r<rmono,ArcCos[1-r^nucoll*(1-Cos[th])/rfp^nucoll],ArcCos[1-rmono^nucoll*(1-Cos[th])/rfp^nucoll]]


(* test *)
If[dotest==1,
Print[thfpofrth[rfinal,thfinal]//.consts];
Print[thfpofrthold[rfinal,thfinal]//.consts];
Print[thfpofrth[rfp,0.5]//.consts];
Print[thfpofrth[rfp,1.0]//.consts];
Print[thfinal*180/Pi//.consts];
]


(* Set omegaf *)
(* Note that omegaf is conserved along field lines, so omegaf can be used for foot point or full function value *)
omegaf[r_,th_]:= omegafp0[thfpofrth[r,th]]


(* test *)
If[dotest==1,
Print[rfp*(omegaf[10^15,thfinal]//.consts)/c//.consts];
]


(* Setup field -- now use vector potential *)
(* Write down final Br *)
Brcoll[r_,th_]:= Br0 *(r/rfp)^(nucoll-2) 
Brmono[r_,th_]:= Brcoll[rmono,th] *(r/rmono)^(0-2) 
Brold[r_,th_]:=If[r<Evaluate[rmono],Evaluate[Brcoll[r,th]],Evaluate[Brmono[r,th]]];
(* below presumes Br0 is polar value and that A_\phi already normalized *)
dAphidh[r_,th_]=Evaluate[D[Aphi[r,th],th]];
tempBr[r_,th_]=FullSimplify[Evaluate[dAphidh[r,th]]/(r^2*Sin[th]),{r>0,nucoll>=0,rfp>0,th>=0,rmono>0}];
Br[r_,th_]:=Evaluate[tempBr[r,th]];


(* test *)
If[dotest==1,
Print[Limit[Br[rfp,thth],thth->0]//.consts];
Print[1.0*Br0//.consts];
Print[(Br0-Limit[Br[rfp,thth],thth->0])//.consts];
]


(* test *)
If[dotest==1,
Print[Br[10^(15),thfinal]//.consts];
Print[Brold[10^(15),thfinal]//.consts];
]


(* Plot Br at a particular angle *)
If[doplot==1,
toplot=Log[10,Br[r,th]//.consts//.{r->10^x,th->0.05}];
lowerx=Log[10,rl//.consts];
upperx=Log[10,10^(16)];
Plot[toplot,{ploti,mini,maxi}]
]


(* Write down final Bh *)
Bhcoll[r_,th_]:= Br0*(-nucoll*(r/rfp)^(nucoll-2)*Tan[th/2])
Bhmono[r_,th_]:=0
Bhold[r_,th_]:=If[r<Evaluate[rmono],Evaluate[Bhcoll[r,th]],Evaluate[Bhmono[r,th]]];
dAphidr[r_,th_]=Evaluate[D[Aphi[r,th],r]];
tempBh[r_,th_]=FullSimplify[-(r)*Evaluate[dAphidr[r,th]]/(r^2*Sin[th]),{r>0,nucoll>=0,rfp>0,th>=0,rmono>0}];
Bh[r_,th_]:=Evaluate[tempBh[r,th]];


(* test *)
If[dotest==1,
Print[Bhold[10^(10),0.1]//.consts];
Print[Bh[10^(10),0.1]//.consts];
]


(* Plot Bh at a particular angle *)
If[doplot==1,
toplot1=Log[10,-Bhold[r,th]//.consts//.{r->10^x,th->0.05}];
toplot2=Log[10,-Bh[r,th]//.consts//.{r->10^x,th->0.05}];
lowerx=Log[10,rl//.consts];
upperx=Log[10,10^(16)];
Plot[{toplot1,toplot2},{ploti,mini,maxi}]
]


(* Write down final Bp *)
tempBp[r_,th_]=FullSimplify[Sqrt[Br[r,th]^2+Bh[r,th]^2],{r>0,nucoll>=0,rfp>0,th>=0,rmono>0}];
Bp[r_,th_]:=Evaluate[tempBp[r,th]];


(* test *)
If[dotest==1,
Print[Bp[10^(15),thfinal]//.consts];
]


(* Plot Bp at a particular angle *)
If[doplot==1,
toplot1=Log[10,Br[r,th]//.consts//.{r->10^x,th->0.05}];
toplot2=Log[10,Bp[r,th]//.consts//.{r->10^x,th->0.05}];
lowerx=Log[10,rl//.consts];
upperx=Log[10,10^(16)];
Plot[{toplot1,toplot2},{ploti,mini,maxi}]
]


(* Write down final Bphistart: Actually only used to determine foot point Bphi -- can tweek *)
(* Apparently true pitch angle alpha=arctan (|Brhat/Bphihat|) is smaller than standad result compared to at large radii *)
(* Well, making Bphi0=2Br0 kills the solution at 10rl *)
Bphistartcoll[r_,th_]:=(Bphi0/Br0)*Br0*(-2*rfp*omegaf[r,th]/c)*(r/rfp)^(nucoll-1)*Tan[th/2]
Bphistartmono[r_,th_]:=Bphistartcoll[rmono,th] *(r/rmono)^(0-1) 
Bphistart[r_,th_]:=If[r<Evaluate[rmono],Evaluate[Bphistartcoll[r,th]],Evaluate[Bphistartmono[r,th]]];


(* test *)
If[dotest==1,
Print[Bphistart[10^(10),0.1]//.consts];
]


(* Plot Bphistart at a particular angle *)
If[doplot==1,
thpick=0.02;
toplot=Log[10,-Bphistart[r,th]//.consts//.{r->10^x,th->thpick}];
lowerx=Log[10,rl//.consts];
upperx=Log[10,10^(16)];
Plot[toplot,{ploti,mini,maxi}]
]


(* Setup foot point velocities and MHD invariants to project-outward the solution along the given field *)
(* Free parameters are really: Bphistart@fp, omegaf@fp, vp@fp, Bp@fp, rho0@fp, and (Bphistart/Bp)@fp determines unique torque *)
(* Note that omegaffp and maybe Bphifp have some problem with recursion using thfpofrth if kept as formula instead of numerical value *)
Clear[Rfp,omegaffp,Bphifp,Bpfp,vphifp,vsqfp,gammafp,uphifp,vpfp]
vpfp[r_,th_]:=vpfp0[thfpofrth[r,th]]
rho0fp[r_,th_]:=rho0fp0[thfpofrth[r,th]]
(*omegaffp[r_,th_]:=omegaf[rfp,th]*)
(* omegaf[r,th] already uses thfpofrth[r,th], so can't duplicate *)
omegaffp[r_,th_]:=omegaf[rfp,thfpofrth[r,th]]

Rfp[r_,th_]:=rfp*Sin[thfpofrth[r,th]]
Bphifp[r_,th_]:=Bphistart[rfp,thfpofrth[r,th]]
Bpfp[r_,th_]:=Bp[rfp,thfpofrth[r,th]]
vphifp[r_,th_]:=(omegaffp[r,th]*Rfp[r,th]+Bphifp[r,th]*vpfp[r,th]/Bpfp[r,th])
vsqfp[r_,th_]:=(vpfp[r,th]^2+vphifp[r,th]^2)
gammafp[r_,th_]:=1/Sqrt[1-(vsqfp[r,th]/c^2)]
upfp[r_,th_]:=gammafp[r,th]*vpfp[r,th]
uphifp[r_,th_]:=vphifp[r,th]*gammafp[r,th]
(*rho0fp[r_,th_]:=-Bpfp[r,th]*omegaffp[r,th]*Rfp[r,th]*Bphifp[r,th]/(mu-gammafp[r,th])/upfp[r,th]*)
(* Note that \Phi, \lambda, and \mu are conserved along field lines, so can be used anywhere \Phi, \lambda, and \mu full functions needed *)
(* Am I sure I want to use poloidal field and velocity and not r,th? *)
Phi1fp[r_,th_]:=Bpfp[r,th]/(rho0fp[r,th]*upfp[r,th])
Phi2fp[r_,th_]:=Bphifp[r,th]/(rho0fp[r,th]*(uphifp[r,th]-gammafp[r,th]*Rfp[r,th]*omegaffp[r,th]))
lambdafp[r_,th_]:=(Rfp[r,th]*(uphifp[r,th]-Phi1fp[r,th]*Bphifp[r,th]))/c
mufp[r_,th_]:=gammafp[r,th]-Phi1fp[r,th]*omegaffp[r,th]*Rfp[r,th]*Bphifp[r,th]/c^2


(* test *)
If[dotest==1,
Print[(1/c)*Rfp[rfinal,thfinal]*omegaffp[rfinal,thfinal]//.consts];
Print[(1/c)*rfp*omegaffp[rfinal,thfinal]//.consts];
Print[gammafp[rfp,thfpofrth[rfp,1.5]]//.consts];
Print[myrho0=rho0fp[rfp,thfpofrth[rfp,1.5]]//.consts];
Print[myBp0=Bpfp[rfp,thfpofrth[rfp,1.5]]//.consts];
Print[fakemu=myBp0^2/(myrho0*c^2)//.consts];
Print[mufp[rfp,thfpofrth[rfp,1.5]]//.consts];
]


(* Setup 1st asymptotic *)
Clear[R,Rfunc,gamma1,gamma2]
R=r*Sin[th];
Rfunc[r_,th_]:=r*Sin[th]
gamma1dep[r_,th_]:=Sqrt[myMax0[(omegaf[r,th]*Rfunc[r,th]/c)^2-(omegaffp[r,th]*Rfp[r,th]/c)^2]]
gamma1[r_,th_]:=Sqrt[myMax1[gamma0^2 + gamma1dep[r,th]^2]]

(* Setup 2nd asymptotic -- but avoid division by zero *)
nu[r_]:=If[r>rmono,10^(-30),nucoll]
gamma2[r_,th_]:=(2/th)*Sqrt[myMax0[C0/((2-nu[r])*nu[r])]]

(* get final force-free result *)
eqgammaff=1/gammaff^2 ==1/gamma1[r,th]^2 +1/gamma2[r,th]^2;
Print["Before Solve[eqgammaff,gammaff]"];
solsgammaff=Solve[eqgammaff,gammaff];
mygammaff[r_,th_]:=Evaluate[solsgammaff[[2,1,2]]](* Obtain semi-final collimating solution for Lorentz factor *)
mysemigammacoll[r_,th_]:=1/(1/mufp[r,th] + 1/Evaluate[mygammaff[r,th]])


(* Test *)
If[dotest==1,
Print[gamma1[10^(10),0.02]//.consts];
Print[(gamma0-gamma1[rfp,thfpofrth[rfp,0.02]]//.consts)];
]


(* Test *)
If[dotest==1,
rtest=10^(10);
thtest=thofr[rtest,Pi/2];
Print[gamma2[10^(10),0.2]//.consts];
Print[gamma2[10^(10),thtest]//.consts];
]


(* Find/Set gamma0 *)
(* Use findroot because depends non-trivially on r,th *)
(* Use findroot instead of Nsolve to force single solution that is positive and real *)
(* Have to push consts here since needs to resolve to number when doing findroot *)
(*eqgamma0=(gammafp[r,th]==mysemigammacoll[rfp,thfpofrth[r,th]]);
mygamma0old[rr_,thth_]:=FindRoot[eqgamma0//.{r->rr,th->thth}//.consts,{gamma0,2}][[1,2]]*)
(* NO, of course, can solve for gamma0 directly in terms of things *)
mygamma0[r_,th_]:=Sqrt[myMax1[1/( (1/gammafp[r,th]-1/mufp[r,th])^2-1/gamma2[rfp,thfpofrth[r,th]]^2) - gamma1dep[rfp,thfpofrth[r,th]]^2]]
(* The max is used only in rare cases, such as at very small foot point angles where this approximation doesn't apply *)


(* test *)
If[dotest==1,
Print[mygamma0[rfp,1.0]//.consts];
myr=rfp//.consts;
Print[mygamma0[myr,1.0]//.consts];

testr=10^(15);
testth=0.02;
Print[mygamma0[testr,testth]//.consts];
Print[mygamma0[testr,testth]//.consts];
]


(* test *)
If[dotest==1,
testr=rfp//.consts;
testth=Pi/2;
Print[mygamma0[testr,testth]//.consts];
Print[(mysemigammacoll[testr,testth]//.consts)//.{gamma0->mygamma0[testr,testth]}//.consts];
Print[gammafp[testr,testth]//.consts];
]


(* Obtain true final collimating solution for Lorentz factor *)
mygammacoll[r_,th_]:=myMax1[mysemigammacoll[r,th]//.{gamma0->mygamma0[r,th]}]


(* test *)
If[dotest==1,
Print[mygammacoll[rfinal,thfinal]//.consts];
thtest=1.0;
thtest=thfpofrth[rfp,thtest]//.consts;
(* warning: super expensive to stick in thfpofrth into below directly *)
Print[mygammacoll[rfp,thtest]//.consts];
Print[mygammacoll[10^(10),thfinal]//.consts];
]


(* Setup monopole jet solution *)
thjc=th;
(*rc=mufpfunc^(1/3)/(omegaffunc/c*Sin[thjc]^(5/3));*)
(*eqgamma2m=
gamma2m==C1*(mufpfunc-gamma2m)^(1/3)*Log[1+C2*r/rc]^(1/3)/Sin[thjc]^(2/3);*)
gammac=(mufpfunc/Sin[thjc]^2)^(1/3);
eqgamma2m=
gamma2m==C1*((mufpfunc-gamma2m)/Sin[thjc]^2*Log[1+C2*r*omegaffunc/c*Sin[thjc]/gammac])^(1/3);
(*eqgamma2m=
gamma2m==C1*((mu-gamma2m)/Sin[thjc]^2)^(1/3)*)


(* Solve for monopole gamma2 *)
Print["Before Solve[eqgamma2m,gamma2m]"];
solsmygamma2m=Solve[eqgamma2m,gamma2m];
(* never clear solsmygamma2m since used during runtime to find correct root *)
Clear[mygamma2m];
(* need to determine which is correct root *)

(* Well, below is ok, but don't know Ljet and thetajet here when running solution! *)
(*
allrootsnum=solsmygamma2m//.{mufpfunc->mufp[r,th],omegaffunc->omegaf[r,th]}//.consts//.{r->Ljet,th->thetajet};
dimallroots=Dimensions[allrootsnum][[1]];
allrootsnumreal=Table[Abs[Re[allrootsnum[[iroots,1,2]]]],{iroots,1,dimallroots}];
allrootsnumimaginary=Table[Abs[Im[allrootsnum[[iroots,1,2]]]],{iroots,1,dimallroots}];
(* choose root with smallest absolute imaginary part -- not 1 or \mu is always reference value *)
BADIMAGINARY=Infinity;
For[iroots=1,iroots<=dimallroots,
If[allrootsnumimaginary[[iroots]]<BADIMAGINARY,BADIMAGINARY=allrootsnumimaginary[[iroots]],chosenroot=iroots;];
iroots++;
];
mygamma2m[r_,th_]:=Evaluate[solsmygamma2m[[1,1,2]]//.{mufpfunc->mufp[r,th],omegaffunc->omegaf[r,th]}]
*)


Print["Before mygamma2m"];
mygamma2m[rinput_?NumericQ,thinput_?NumericQ,localconsts_]:=Module[{foo,allrootsnum,dimallroots,allrootsnumreal,allrootsnumimaginary,BADIMAGINARY,iroots,chosenroot,result},
allrootsnum=solsmygamma2m/.{mufpfunc->mufp[rinput,thinput],omegaffunc->omegaf[rinput,thinput]}//.localconsts//.{r->rinput,th->thinput};
dimallroots=Dimensions[allrootsnum][[1]];
allrootsnumreal=Table[Abs[Re[allrootsnum[[iroots,1,2]]]],{iroots,1,dimallroots}];
allrootsnumimaginary=Table[Abs[Im[allrootsnum[[iroots,1,2]]]],{iroots,1,dimallroots}];
(* choose root with smallest absolute imaginary part -- not 1 or \mu is always reference value *)
BADIMAGINARY=Infinity;
For[iroots=1,iroots<=dimallroots,
If[allrootsnumimaginary[[iroots]]<BADIMAGINARY,BADIMAGINARY=allrootsnumimaginary[[iroots]];chosenroot=iroots;];
iroots++;
];
(*
Print["chosenroot=",chosenroot];
Print["allrootsnumreal="allrootsnumreal];
*)
result=myMax1[allrootsnumreal[[chosenroot]]];
(* return *)
result
];

(* 1 not generally correct root *)
(*
mygamma2m[r_,th_,consts_]:=Evaluate[solsmygamma2m[[1,1,2]]//.{mufpfunc->mufp[r,th],omegaffunc->omegaf[r,th]}]
*)





(* Obtain final monopole solution for Lorentz factor *)
(*eqgammamono=1/gammamono^2 ==1/gamma1^2 +1/gamma2m^2;
solsgammamono=Solve[eqgammamono,gammamono]
mysemigammamono[r_,th_]:=Evaluate[solsgammamono[[2,1,2]]//.{gamma1->gamma1[r,th],gamma2m->mygamma2m[r,th]}]*)
(* below use of mygamma2m assumes consts are set to be numbers *)
mysemigammamonotemp[r_,th_]:=1/Sqrt[1/gamma1[r,th]^2+1/mygamma2m[r,th,consts]^2]
(*mysemigammamono[r_,th_]:=1/(1/mufp[r,th]+1/mysemigammamonotemp[r,th])*)
(* Don't use reciprical sum for monopole since should already be limited and would cause efficiency to always be 1/2 at most! *)
(* So only place strict limit -- as consistent with paper anyways *)
mysemigammamono[r_,th_]:=Max[Min[mufp[r,th],mysemigammamonotemp[r,th]],1];


(* Find/Set gamma0 for monopole solution *)
(*eqgammamono0=(gammafp[r,th]==mysemigammamono[rfp,thfpofrth[r,th]]);
mygammamono0old[rr_,thth_]:=FindRoot[Evaluate[eqgammamono0//.{r->rr,th->thth}//.consts],{gamma0,2}][[1,2]]*)
(* below use of mygamma2m assumes consts are set to be numbers *)
mygammamono0[r_,th_]:=Module[{result,myrfp,mytheta,resultsq},
myrfp=rfp//.consts; (* needed so mygamma2m gets a numerical value for rfp *)
mytheta=thfpofrth[r,th]//.consts;
resultsq=1/( (1/gammafp[r,th]-1/mufp[r,th])^2-1/mygamma2m[myrfp,mytheta,consts]^2) - gamma1dep[myrfp,thfpofrth[r,th]]^2;
result=Sqrt[myMax1[resultsq]];
(* return *)
result
];
(* don't mix monopole with \n u limit. -- well, need limit still near pole *)


(* test*)
If[dotest==1,
testr=rfp//.consts;
testth=0.5;
gammafp[testr,testth]//.consts;
]


(* test *)
If[dotest==1,
testr=rfp//.consts;
testth=0.5;
Print[mygammamono0old[testr,testth]//.consts];
Print[mygammamono0[testr,testth]//.consts];
testth=Evaluate[thfpofrth[testr,testth]//.consts];
Print[mygammamono0[testr,testth]//.consts];
Print[(mysemigammamono[testr,testth]//.consts)//.{gamma0->mygammamono0[testr,testth]}//.consts];
Print[gammafp[testr,testth]//.consts];
]


(* Obtain true final monopole solution for Lorentz factor *)
mygammamono[r_,th_]:=myMax1[mysemigammamono[r,th]//.{gamma0->mygammamono0[r,th]}]


(* Test *)
If[dotest==1,
Print[mygammamono[10^(10),thfinal]//.consts];
]


(* Write down final gamma that includes collimating and monopole branches *)
mygammafinal[r_,th_]:=If[r<Evaluate[rmono],Evaluate[mygammacoll[r,th]],Evaluate[mygammamono[r,th]]];


(* Test *)
If[dotest==1,
Print[mygammafinal[1.0*10^(10),thfinal]//.consts];
rtest=rfp//.consts;
thtest=thfpofrth[rfp,0.5]//.consts;
Print[(mygammafinal[rtest,thtest]-gammafp[rtest,thtest])//.consts];
]


(* Plot \Gamma at a particular angle *)
If[doplot==1,
mufptbl=Table[{x,(Log[10,mufp[10^x,thpick]//.consts])},{ploti,mini,maxi}];
gammatbl=Table[{x,(Log[10,(mygammafinal[10^x,thpick]//.consts)])},{ploti,mini,maxi}];
p1=ListPlot[mufptbl,Joined->True,PlotStyle->Red];
p2=ListPlot[gammatbl,Joined->True,PlotStyle->Black];
Show[{p1,p2}]
]


(* Setup u_\phi using angular momentum conservation *)
uphi[r_,th_]:=(myMax0[mygammafinal[r,th]-gammafp[r,th]]+Rfp[r,th]*omegaffp[r,th]*uphifp[r,th]/c^2)/((Rfunc[r,th]*omegaf[r,th])/c^2)


(* test *)
If[dotest==1,
Print[(1/c)uphi[10^(15),0.01]//.consts];
rtest=rfp//.consts;
thtest=thfpofrth[rfp,1.0]//.consts;
Print[(1/c)*uphi[rtest,thtest]//.consts];
]


(* Plot u_\phi/c at a particular angle *)
If[doplot==1,
tbl=Table[{x,(Log[10,(1/c)*uphi[10^x,thpick]//.consts])},{ploti,mini,maxi}];
ListPlot[tbl,Joined->True,PlotStyle->Black]
]


(* Setup u_p *)
vpother=uppother/sgamma
vphiother=uphother/sgamma
vsqother=vpother^2+vphiother^2
myeq=sgamma^2==1/(1-vsqother/c^2)
Print["Before Solve[myeq,sgamma]"];
solssgamma=Solve[myeq,sgamma]
mygammaofu=solssgamma[[2,1,2]]
Print["Before Solve[myeq,uppother]"];
solsuppother=Solve[myeq,uppother]


(* force up to not be super small so no division by 0 later *)
up[r_,th_]:=ReleaseHold[Sqrt[specialMax[(Hold[mygammafinal[r,th]]^2-1)*c^2-Hold[uphi[r,th]]^2]]];
(*up[r_,th_]:=ReleaseHold[Sqrt[(Hold[mygammafinal[r,th]]^2-1)*c^2-Hold[uphi[r,th]]^2]]*)


(* test*)
If[dotest==1,
Print[(1/c)*up[10^(15),thfinal]//.consts];
rtest=rfp//.consts;
thtest1=thfpofrth[rfp,1.0]//.consts;
Print[(1/c)*up[rtest,thtest1]//.consts];
thtest2=thfpofrth[rfp,0.5]//.consts;
Print[(1/c)*up[rtest,thtest2]//.consts];
Print[(1/c//.consts)*(gammafp[rtest,thtest1]//.consts)*(vpfp[rtest,1.0]//.consts)];
Print[(1/c//.consts)*(gammafp[rtest,thtest2]//.consts)*(vpfp[rtest,0.5]//.consts)];
]


(* Plot u_p/c at a particular angle *)
If[doplot==1,
tbl=Table[{x,(Log[10,(1/c)*up[10^x,thpick]//.consts])},{ploti,mini,maxi}];
ListPlot[tbl,Joined->True,PlotStyle->Black]
]


(* setup rho0 using \Phi1 *)
(*rho0[r_,th_]:=rho0fp[r,th]*(Bp[r,th]/Bp[rfp,thfpofrth[r,th]])*(up[rfp,thfpofrth[r,th]]/up[r,th])*)
rho0[r_,th_]:=Bp[r,th]/(up[r,th]*Phi1fp[r,th])


(* Setup ur and uh *)
ur[r_,th_]:=Br[r,th]/(rho0[r,th]*Phi1fp[r,th])
uh[r_,th_]:=Bh[r,th]/(rho0[r,th]*Phi1fp[r,th])


(* test *)
If[dotest==1,
rtest=rfp//.consts;
thtest=thfpofrth[rfp,1.0]//.consts;
Print[testrhofp=rho0[rtest,thtest]//.consts];
Print[testBp=Bpfp[rtest,thtest]//.consts];
Print[fakemu=testBp^2/(testrhofp*c^2)//.consts];
Print[mufp[rtest,thtest]/fakemu//.consts];
Print[rho0[10^(15),thfinal]//.consts];
]


(* Plot rho0 at a particular angle *)
If[doplot==1,
tbl=Table[{x,(Log[10,rho0[10^x,thpick]//.consts])},{ploti,mini,maxi}];
ListPlot[tbl,Joined->True,PlotStyle->Black]
]


(* Write down final true Bphi that uses stationary condition so consistent beyond monopole part -- overwrites original Bphi that is only used to get foot point mu and uphi, and the foot point value shouldn't change *)
(*Bphi[r_,th_]:=(Bp[r,th]/up[r,th])*(uphi[r,th]-mygammafinal[r,th]*Rfunc[r,th]*omegaf[r,th])*)
(* use \mu to get Bphi so constrain it to be constant.  If repeatedly use \Phi, won't correct so that all invariants are constant *)
Bphi[r_,th_]:=-(mufp[r,th]-mygammafinal[r,th])*c^2/(Phi1fp[r,th]*Rfunc[r,th]*omegaf[r,th])


(* test *)
If[dotest==1,
Print[rtest=rfp//.consts];
Print[thtest=thfpofrth[rtest,1.0]//.consts];
Print[Bphi[10^(10),0.02]//.consts];
Print[Bphi[10^(15),0.02]//.consts];
Print[Bphi[rtest,1.0]//.consts];
Print[Bphistart[rtest,1.0]//.consts];
Print[Bphi[rtest,1.4]//.consts];
Print[Bphistart[rtest,1.4]//.consts];
]


(* Plot Bphi at a particular angle *)
If[doplot==1,
tbl1=Table[{x,(Log[10,-Bphistart[10^x,thpick]//.consts])},{ploti,mini,maxi}];
tbl2=Table[{x,(Log[10,-Bphi[10^x,thpick]//.consts])},{ploti,mini,maxi}];
p1=ListPlot[tbl1,Joined->True,PlotStyle->Red];
p2=ListPlot[tbl2,Joined->True,PlotStyle->Black];
Show[{p1,p2}]
]


(* other useful relations *)
udotB[r_,th_]:=uphi[r,th]*Bphi[r,th]+up[r,th]*Bp[r,th]
Bsq[r_,th_]:=Bphi[r,th]^2+Bp[r,th]^2
bsq[r_,th_]:=(Bsq[r,th]+(udotB[r,th]/c)^2)/mygammafinal[r,th]^2
(* bsq/2 not bsq/(8*Pi) since all quantities converted to HL units already *)
(*Pm[r_,th_]:=bsq[r,th]/2*)
v3p[r_,th_]:=up[r,th]/mygammafinal[r,th]


mutest[r_,th_]:=mygammafinal[r,th]-Phi1fp[r,th]*omegaf[r,th]*Rfunc[r,th]*Bphi[r,th]/c^2
dpowermavsthdtheta[r_?NumericQ,th_?NumericQ,theconsts_]:=Module[{result},
result=2*Pi*r^2*Sin[th]*mygammafinal[r,th]*rho0[r,th]*c^2*up[r,th]//.theconsts;
result
];
omegaftest[r_,th_]:=omegaf[r,th]
lambdatest[r_,th_]:=(Rfunc[r,th]*(uphi[r,th]-Phi1fp[r,th]*Bphi[r,th]))/c
Phi1test[r_,th_]:=Bp[r,th]/(rho0[r,th]*up[r,th])
Phi2test[r_,th_]:=Bphi[r,th]/(rho0[r,th]*(uphi[r,th]-mygammafinal[r,th]*Rfunc[r,th]*omegaf[r,th]))
sigmatest[r_,th_]:=-Phi1fp[r,th]*Rfunc[r,th]*omegaf[r,th]*Bphi[r,th]/(c^2*mygammafinal[r,th])
(* below gives issue with args being less than MachinePrecision=WorkingPrecision *)
dpowervsthdtheta[r_?NumericQ,th_?NumericQ,theconsts_]:=Module[{result},
result=2*Pi*r^2*Sin[th]*mutest[r,th]*rho0[r,th]*c^2*up[r,th]//.theconsts;
result
];
powervsth[r_,thf_,theconsts_]:=Module[{result,th},
result=NIntegrate[dpowervsthdtheta[r,th,theconsts],{th,0,thf},AccuracyGoal->Infinity,PrecisionGoal->2,WorkingPrecision->10];
result
];
powermavsth[r_,thf_,theconsts_]:=Module[{result,th},
result=NIntegrate[dpowermavsthdtheta[r,th,theconsts],{th,0,thf},AccuracyGoal->Infinity,PrecisionGoal->2,WorkingPrecision->10];
result
];





If[dotestcons==1,
(* Ensure conservation along field lines: use thofr[r,thfp] for theta with fixed thfp *)
(* Note, did not insert thofr[] into test functions because super slow due to crazy replacements *)
thfp=1.0//.consts;
thfp=(Pi/2)//.consts;
rtest=rfp//.consts;
Print[powervsth[rtest,Pi/2,consts]];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[mufp[rtest,thtest]//.consts];
rtest=rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[mutest[rtest,thtest]//.consts];
rtest=10*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[mutest[rtest,thtest]//.consts];
rtest=10^5*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[mutest[rtest,thtest]//.consts];
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[mutest[rtest,thtest]//.consts];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[omegaffp[rtest,thtest]//.consts];
rtest=rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[omegaftest[rtest,thtest]//.consts];
rtest=10*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[omegaftest[rtest,thtest]//.consts];
rtest=10^5*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[omegaftest[rtest,thtest]//.consts];
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[omegaftest[rtest,thtest]//.consts];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[lambdafp[rtest,thtest]//.consts];
rtest=rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[lambdatest[rtest,thtest]//.consts];
rtest=10*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[lambdatest[rtest,thtest]//.consts];
rtest=10^5*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[lambdatest[rtest,thtest]//.consts];
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[lambdatest[rtest,thtest]//.consts];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi1fp[rtest,thtest]//.consts];
rtest=rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi1test[rtest,thtest]//.consts];
rtest=10*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi1test[rtest,thtest]//.consts];
rtest=10^5*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi1test[rtest,thtest]//.consts];
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi1test[rtest,thtest]//.consts];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi2fp[rtest,thtest]//.consts];
rtest=rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi2test[rtest,thtest]//.consts];
rtest=10*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi2test[rtest,thtest]//.consts];
rtest=10^5*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi2test[rtest,thtest]//.consts];
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[Phi2test[rtest,thtest]//.consts];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[sigmatest[rtest,thtest]//.consts];
rtest=rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[sigmatest[rtest,thtest]//.consts];
rtest=10*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[sigmatest[rtest,thtest]//.consts];
rtest=10^5*rl//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[sigmatest[rtest,thtest]//.consts];
rtest=10^(14)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[sigmatest[rtest,thtest]//.consts];
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[sigmatest[rtest,thtest]//.consts];
]


(* test *)
If[dotestcons==1,
rtest=rfp//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[udotB[rtest,thtest]//.consts];
Print[Bsq[rtest,thtest]//.consts];
Print[bsq[rtest,thtest]//.consts];
Print[v3p[rtest,thtest]//.consts];
Print[(bsq[rtest,thtest]/(rho0[rtest,thtest]*c^2))//.consts];
]


(* test *)
If[dotestcons==1,
rtest=10^(15)//.consts;thtest=thofr[rtest,thfp]//.consts;
Print[udotB[rtest,thtest]//.consts];
Print[Bsq[rtest,thtest]//.consts];
Print[bsq[rtest,thtest]//.consts];
Print[v3p[rtest,thtest]//.consts];
Print[(bsq[rtest,thtest]/(rho0[rtest,thtest]*c^2))//.consts];
]
