(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* see also gamma_jet _superwrapper.nb *)


AutoGeneratedPackage->Button[Automatic, Inherited, BaseStyle -> "Link", ButtonData -> "paclet:ref/Automatic"]





InitializationCell->True


(* IF ADD NEW CELLS, MUST MAKE THEM INITIALZATION CELL BY GOING TO CELL->CELL PROPERTIES->INITIALZATION CELL *)


(* Compute reconnection transition radius and other quantities *)
(* Used with gamma_jet _wrapper.nb or gamma_jet _wrapper _ 1value.nb *)


(* TO test this file, can do:

getconstants;
getPUNQ;

...and then try some function calls.
*)


(*$MinPrecision=5; (* allowed for print outs *)*)
lowestprec=30; (* might not specify precision, but using machine precision may not be enough.  Also, even if use more prec in some steps, the machine prec values will truncate those more precise values.  This is especially a problem for FindRoot *)
slowprec=15; (* Used for some special cases where still ok to use lower prec but can't use lowestprec *)
(*slowprec=MachinePrecision;*)

(* CAREFUL: Using high WorkingPrecision can lead to FindRoot offsetting indep's by too small a value to show up as new function value *)
myprecfindroot=MachinePrecision;

(* default is not to include model-dependent dissipation *)
includediss=0;

RELTOLAum=0.2;
(* for what Aum and greater to actually do full solution *)
Aumtrigger=10.0;

lowestnpairsperne=10^(-5);

(* sufficient range for all known models, but can change this in sed script and make narrower *)
globallTlow=8;
globallThigh=17;

(*
pairsintprec={WorkingPrecision->lowestprec,AccuracyGoal->Infinity,PrecisionGoal->4};
synchintprec={WorkingPrecision->lowestprec,AccuracyGoal->Infinity,PrecisionGoal->2};
pairsnumintprec={WorkingPrecision->lowestprec};
*)

(* about 2X as fast to use WorkingPrecision->15 instead of lowestprec=30 compared to above *)
(* WorkingPrecision->MachinePrecision is even 20% faster than ->15 *)
(* but using "MachinePrecision fails to give non-zero answer sometimes -- odd *)

(*
pairsintprec={WorkingPrecision->MachinePrecision,AccuracyGoal->Infinity,PrecisionGoal->4};
synchintprec={WorkingPrecision->MachinePrecision,AccuracyGoal->Infinity,PrecisionGoal->2};
pairsnumintprec={WorkingPrecision->MachinePrecision};
pairsnumintprecetae={WorkingPrecision->lowestprec};
(* required to control precision in getting Y_e *)
pairsnumintprecyefun={WorkingPrecision->lowestprec};
pairrateintprec={WorkingPrecision->MachinePrecision,AccuracyGoal->Infinity,PrecisionGoal->4};
*)
pairsintprec={WorkingPrecision->16,AccuracyGoal->Infinity,PrecisionGoal->4};
synchintprec={WorkingPrecision->16,AccuracyGoal->Infinity,PrecisionGoal->2};
pairsnumintprec={WorkingPrecision->16};
pairsnumintprecetae={WorkingPrecision->lowestprec};
(* required to control precision in getting Y_e *)
pairsnumintprecyefun={WorkingPrecision->lowestprec};
pairrateintprec={WorkingPrecision->16,AccuracyGoal->Infinity,PrecisionGoal->4};


(* most accurate -- to within 5% takes same time as first case above and more accurate in detail, but final results seem to be same so far *)
(*
pairsintprec={WorkingPrecision->lowestprec};
synchintprec={WorkingPrecision->lowestprec};
pairsnumintprec={WorkingPrecision->lowestprec};
*)


(*pairsnumintprec={WorkingPrecision->lowestprec,AccuracyGoal->Infinity,PrecisionGoal->15};*)




(* Constants of Nature *)
getconstants:=Module[
{foo},

(* Cabibbo angle *)
(*
s=1;
g=1;
cm=1;
*)

thetac=SetPrecision[13.04*Pi/180,lowestprec];
costhetac=SetPrecision[Cos[thetac],lowestprec];
AU=SetPrecision[149597870.691*10^2,lowestprec];
msun=SetPrecision[1.989*10^(33),lowestprec];
lsun=SetPrecision[3.89*10^(33),lowestprec];
rsun=SetPrecision[695500*10^3*100,lowestprec];
G=SetPrecision[6.672*10^(-8) ,lowestprec];
c=SetPrecision[2.99792458*10^(10) ,lowestprec];
ergPmev=SetPrecision[1.60217649*10^(-6),lowestprec];
h=SetPrecision[4.13566733*10^(-15)*10^(-6)*ergPmev,lowestprec];
hbar=SetPrecision[h/(2*Pi),lowestprec];
mn=SetPrecision[1.674927211*10^(-24),lowestprec];
mp=SetPrecision[1.672621637*10^(-24),lowestprec];
QE=SetPrecision[(mn-mp)*c^2,lowestprec];
me=SetPrecision[9.10938215*10^(-31)*1000,lowestprec];
mealso=SetPrecision[0.510998910*ergPmev/c^2,lowestprec];
(*mb=SetPrecision[(mn+mp)/2,lowestprec];*)
avo=SetPrecision[6.0221367*10^(23),lowestprec];
amu=SetPrecision[1/avo,lowestprec];
mu=SetPrecision[amu,lowestprec];
mb=SetPrecision[mu,lowestprec];
kb=SetPrecision[1.380658*10^(-16),lowestprec]; (* erg/K *)
(*Print["arad"],lowestprec];*)
arad=SetPrecision[8*Pi^5*kb^4/(15*c^3*h^3),lowestprec];
arad=SetPrecision[Pi^2*kb^4/(15*(hbar*c)^3),lowestprec];
sigmasb=SetPrecision[arad*c/4,lowestprec];
q=SetPrecision[4.8029*10^(-10),lowestprec];
secPyr=SetPrecision[(60*60*24*365.25),lowestprec];
Ry=SetPrecision[1.09678*10^5,lowestprec];
RyE=SetPrecision[me*q^4/(2*hbar^2),lowestprec];
fsc=SetPrecision[q^2/(hbar*c),lowestprec];
radiuse=SetPrecision[q^2/(me*c^2),lowestprec];
radiusp=SetPrecision[q^2/(mp*c^2),lowestprec];
alpha=SetPrecision[q^2/(hbar*c),lowestprec];
km=SetPrecision[10^3*100,lowestprec];
pc=SetPrecision[3.086*10^18,lowestprec];
Mpc=SetPrecision[10^6*pc,lowestprec];
rgalaxies=SetPrecision[3*Mpc,lowestprec];
ly=SetPrecision[1/3.261*pc,lowestprec];
h0=SetPrecision[71*km/s/Mpc,lowestprec];
sigmatdiff=SetPrecision[radiuse^2,lowestprec];
sigmat=SetPrecision[(8*Pi/3)*(alpha*hbar/(me*c))^2,lowestprec];
sigmat2=SetPrecision[(8*Pi/3)*(q^4/(me^2*c^4)),lowestprec];
sigmakngen=SetPrecision[
(2*Pi*q^4)/(me^2*c^4)*((1+alphakn)/(alphakn^2)*(2*(1+alphakn)/(1+2*alphakn)-1/alphakn*Log[1+2*alphakn])+1/(2*alphakn)*Log[1+2*alphakn]-(1+3*alphakn)/(1+2*alphakn)^2)//.{alphakn->(h*freqgamma)/(me*c^2)},lowestprec];

sigmat-Limit[sigmakn,freqgamma->0];
rl=SetPrecision[G*M/c^2,lowestprec];
tl=SetPrecision[rl/c,lowestprec];
];


(* not called by normal procedure unless uncomment it in gamma_jet _wrapper.nb *)
setupvaluesothertest:=Module[
{foo},
Ljet=5*10^(14);
(*Ljet=10^(25);*)
(*Ljet=rl;*)
mythfp=Pi/2;
(* assumption below *)
Clear[Lp,Lpnum,Lpmod,Lpmodnum];
mylmode=1;
mymmode=0;

(* ensure precision is kept *)
Ljet=SetPrecision[Ljet,lowestprec];
myfakemu=SetPrecision[myfakemu,lowestprec];
thebr0gauss=SetPrecision[thebr0gauss,lowestprec];
mynu=SetPrecision[mynu,lowestprec];
myrmono=SetPrecision[myrmono,lowestprec];
mythfp=SetPrecision[mythfp,lowestprec];
mylmode=SetPrecision[mylmode,lowestprec];
mymmode=SetPrecision[mymmode,lowestprec];

];





(* setup values from jet solution so don't have to repeat expensive jet calculations *)
setupvalues:=Module[
{foo},
Unprotect[thetajet,gammavalue,rhobvalue,rhobingoing,bsqvalue,bsqTvalue,bsqgaussvalue,bsqgaussTvalue,bgaussvalue,bgaussTvalue,Tvalue,Bphivalue,omegafvalue,Rjet,Rjetmod,Rjetmodnum,gammavalue,Lp,Lpmod,Lpnum,Lpmodnum,Pm,Um];



thetajet=thofr[Ljet,mythfp]//.consts;
omegafvalue=omegaf[Ljet,thetajet]//.consts;
gammavalue=mygammafinal[Ljet,thetajet]//.consts;

(* get geometrical results first *)
Rjet=Ljet*Sin[thetajet];
(* Don't modify Lp with Rjetmod, just assume lmode restricted to lmode>gammavalue*thetajet *)
Lp=1/(lmode/(Pi*Rjet) + mmode*omegafvalue/(gammavalue*2*Pi*c))//.consts;
Lpnum=Lp//.consts;
(* modifications to Rjet and Lp *)
(* vrecguess only valid in fast reconnection regime, need to iterate to see if fast or slow! *)
(* TODO *)
vrecguess=vrecguessoc*c;
Lpmod=1/(gammavalue*Sin[thetajet]/Rjet + 2*vrecguess/(c*Lp));
Lpmodnum=Lpmod//.consts;
Rjetmod=Rjet/(gammavalue*Sin[thetajet]);
Rjetmodnum=Rjetmod//.consts;

(* choose based upon which gamma_jet {_new} file used *)
If[1==0,
(* now rest of results *)
rhobvalue=rho0[Ljet,thetajet,consts]//.consts;
(* bsqvalue, Bphivalue, and Brvalue in HL units! *)

bsqvalue=bsq[Ljet,thetajet,consts]//.consts;
Bphivalue=Bphi[Ljet,thetajet,consts]//.consts;

bsqTvalue=bsq[Ljet,thetajet,consts]//.consts;
BphiTvalue=Bphi[Ljet,thetajet,consts]//.consts;

bsqplasmavalue=bsq[Ljet,thetajet,consts]//.consts;
Bphiplasmavalue=Bphi[Ljet,thetajet,consts]//.consts;
];
If[1==1,
(* now rest of results *)
rhobvalue=rho0[Ljet,thetajet]//.consts;
(* bsqvalue, Bphivalue, and Brvalue in HL units! *)

bsqvalue=bsq[Ljet,thetajet]//.consts;
Bphivalue=Bphi[Ljet,thetajet]//.consts;

bsqTvalue=bsq[Ljet,thetajet]//.consts;
BphiTvalue=Bphi[Ljet,thetajet]//.consts;

bsqplasmavalue=bsq[Ljet,thetajet]//.consts;
Bphiplasmavalue=Bphi[Ljet,thetajet]//.consts;
];

powerjet=powervsth[Ljet,thetajet,consts]//.consts;
powermajet=powermavsth[Ljet,thetajet,consts]//.consts;

dpowerjetdtheta=dpowervsthdtheta[Ljet,thetajet,consts]//.consts;
dpowermajetdtheta=dpowermavsthdtheta[Ljet,thetajet,consts]//.consts;


Print["Powerjet=",powerjet];
Print["Powermajet=",powermajet];

Print["dPowerjetdtheta=",dpowerjetdtheta];
Print["dPowermajetdtheta=",dpowermajetdtheta];

(* check if jet solution good *)
If[Re[gammavalue]<10^(10)*Im[gammavalue],

Print["gammavalue is imaginary: gammavalue=",gammavalue];
Abort[];
Interrupt[];

, (* else *)

(* force jet stuff to be real even if small imaginary part *)
thetajet=Re[thetajet];
gammavalue=Re[gammavalue];
rhobvalue=Re[rhobvalue];
bsqvalue=Re[bsqvalue];
Bphivalue=Re[Bphivalue];
bsqTvalue=Re[bsqTvalue];
BphiTvalue=Re[BphiTvalue];
bsqplasmavalue=Re[bsqplasmavalue];
Bphiplasmavalue=Re[Bphiplasmavalue];
omegafvalue=Re[omegafvalue];
powerjet=Re[powerjet];
powermajet=Re[powermajet];
dpowerjetdtheta=Re[dpowerjetdtheta];
dpowermajetdtheta=Re[dpowermajetdtheta];
];


 (* aux jet quantities needed by reconnection model *)

(* bsqvalue is in HL units *)
(* These determine temperature, which is sensitive to very small Pm when very small T *)
Pm=bsqTvalue/2;
Um=Pm;

rhobingoing=rhobvalue;

bsqgaussvalue=bsqvalue*(4*Pi);
bgaussvalue=Sqrt[bsqgaussvalue];
bsqgaussTvalue=bsqTvalue*(4*Pi);
bgaussTvalue=Sqrt[bsqgaussTvalue];
bsqgaussplasmavalue=bsqplasmavalue*(4*Pi);
bgaussplasmavalue=Sqrt[bsqgaussplasmavalue];

Tvalue=2*10^4; (* cold input -- don't go below 10^4 and esp don't make 0 since expressions aren't written as limits or some expressions actually diverge (e.g. free-free) *)




(* ensure precision kept *)
thetajet=SetPrecision[thetajet,lowestprec];
gammavalue=SetPrecision[gammavalue,lowestprec];
rhobvalue=SetPrecision[rhobvalue,lowestprec];
rhobingoing=SetPrecision[rhobingoing,lowestprec];

bsqvalue=SetPrecision[bsqvalue,lowestprec];
bsqgaussvalue=SetPrecision[bsqgaussvalue,lowestprec];
bgaussvalue=SetPrecision[bgaussvalue,lowestprec];
Bphivalue=SetPrecision[Bphivalue,lowestprec];

bsqTvalue=SetPrecision[bsqTvalue,lowestprec];
bsqgaussTvalue=SetPrecision[bsqgaussTvalue,lowestprec];
bgaussTvalue=SetPrecision[bgaussTvalue,lowestprec];
BphiTvalue=SetPrecision[BphiTvalue,lowestprec];

bsqplasmavalue=SetPrecision[bsqplasmavalue,lowestprec];
bsqgaussplasmavalue=SetPrecision[bsqgaussplasmavalue,lowestprec];
bgaussplasmavalue=SetPrecision[bgaussplasmavalue,lowestprec];
Bphiplasmavalue=SetPrecision[Bphiplasmavalue,lowestprec];

Tvalue=SetPrecision[Tvalue,lowestprec];
omegafvalue=SetPrecision[omegafvalue,lowestprec];

Rjet=SetPrecision[Rjet,lowestprec];
Lp=SetPrecision[Lp,lowestprec];
Lpnum=SetPrecision[Lpnum,lowestprec];

Rjetmod=SetPrecision[Rjetmod,lowestprec];
Lpmod=SetPrecision[Lpmod,lowestprec];
Lpmodnum=SetPrecision[Lpmodnum,lowestprec];

Pm=SetPrecision[Pm,lowestprec];
Um=SetPrecision[Um,lowestprec];


(* other jet things not needed for the reconnection model but are useful in final plots *)
muvalue=mutest[Ljet,thetajet]//.consts;

urvalue=ur[Ljet,thetajet]//.consts;
uhvalue=uh[Ljet,thetajet]//.consts;
upvalue=up[Ljet,thetajet]//.consts;
uphivalue=uphi[Ljet,thetajet]//.consts;

(* in HL units! *)
Brvalue=Br[Ljet,thetajet]//.consts;
Bhvalue=Bh[Ljet,thetajet]//.consts;
Bpvalue=Bp[Ljet,thetajet]//.consts;

(*
Bphi=Bphi[Ljet,thetajet]//.consts;
Bp=Bp[Ljet,thetajet]//.consts;
Br=Br[Ljet,thetajet]//.consts;
Bh=Bh[Ljet,thetajet]//.consts;
up=up[Ljet,thetajet]//.consts;
ur=ur[Ljet,thetajet]//.consts;
uh=uh[Ljet,thetajet]//.consts;
uphi=uphi[Ljet,thetajet]//.consts;
*)

udotBvalue=(Bpvalue*upvalue+Bphivalue*uphivalue);
Btvalue=0;
utvalue=gammavalue*c;
btvalue=(Btvalue+udotBvalue/c*utvalue/c)/gammavalue;
bpvalue=(Bpvalue+udotBvalue/c*upvalue/c)/gammavalue;
brvalue=(Brvalue+udotBvalue/c*urvalue/c)/gammavalue;
bhvalue=(Bhvalue+udotBvalue/c*uhvalue/c)/gammavalue;
bphivalue=(Bphivalue+udotBvalue/c*uphivalue/c)/gammavalue;


Protect[thetajet,gammavalue,rhobvalue,rhobingoing,bsqvalue,bsqTvalue,bsqgaussvalue,bsqgaussTvalue,bgaussvalue,bgaussTvalue,Tvalue,Bphivalue,omegafvalue,Rjet,Rjetmod,Rjetmodnum,gammavalue,Lp,Lpmod,Lpnum,Lpmodnum,Pm,Um];
];


(* Note that instances where solsT or similar things are used is because want to make it easier on FindRoot to find solution for T without the entire set of complications.  As long as heads in right direction then iteration will work *)
setupiterguesses:=Module[
{foo,mynpairs,myT},

(* temporary, jut sets-up solsT below and not otherwise used *)
mynpairs=ne[rhobingoing];
myT=(Pm/arad)^(1/4); (* assumes radiation dominated, which typically is *)
mynpairs=SetPrecision[mynpairs,lowestprec];
myT=SetPrecision[myT,lowestprec];

(* ITERATED for T,npairs loop *)
solsT={T->myT,npairs->mynpairs};
solsTrad=solsT; (* for radiation terms *)

(* ITERATED for plasma loop, but not T,npairs FindRoot *)
rhobcenter=rhobingoing;(* effectively holds Aum (=1 here), the compression ratio *)
(* netotforomegape is for inside current layer *)
netotforomegape=ne[rhobcenter]+npairs//.solsT; (* initial guess, not generally simply ne+npairs ! *)
gammae=1.01;
(* need to set guess for Tdelta that goes into netotforompegape *)
Sfake=10^(20); (* typical Lundquist number *)
Deltaspt=Sfake^(-1/2)*Lpnum;

(* other things used to set fsolssp *)
myie=(3/2)*(rhobcenter*T*kb/mb)//.consts//.solsT;
myu4vel=0.01;
myb=0.001;

(* ensure precision *)
netotforomegape=SetPrecision[netotforomegape,lowestprec];
Deltaspt=SetPrecision[Deltaspt,lowestprec];
gammae=SetPrecision[gammae,lowestprec];
myie=SetPrecision[myie,lowestprec];
myu4vel=SetPrecision[myu4vel,lowestprec];
myb=SetPrecision[myb,lowestprec];
(* done with things with constants *)


(* now do non-constant assignments, which includes things that should be updated after iterated quantities are iterated *)
fsolssp={d->Lpnum,ux->myu4vel,rhoc->rhobcenter,iec->myie,rhoout->rhobcenter,ieout->myie,Bx->myb,uy->myu4vel};


(* setup iterator arrays: for positions: in,center,out,in-center,center-out *)
Titer={0,0,0,0,0,0};
npairsiter=Titer;

(* store iterators for each position in SP layer *)
storeiter[0];
storeiter[1];
storeiter[2];
storeiter[3];
storeiter[4];
storeiter[5];
];


(* store iterator for any position in SP layer *)
storeiter[which0_]:=Module[
{foo,which=which0},
Titer[[which+1]]=T//.solsT;
npairsiter[[which+1]]=npairs//.solsT;
];


(* get set of independent variables for a given position in the SP layer *)
(* Note that Q@center should be used for emission from face, while Q@out can be used for emission from sides *)
(* Q@in is not used for emission since want to have that part remain cold as it really is at face, while the rest can be hot with little error in averaging T *)
chooseposition[which0_]:=Module[
{foo,which=which0,Trad,myT,mynpairs,gammaout,bxout},

(* choose iterator *)
myT=Titer[[which+1]];
mynpairs=npairsiter[[which+1]];

(* REVERSION: rhobrad \sim rhobvalue with no rhoc or rhobcenter since assume current layer is much smaller than radiation region and radiation comes from distributed region in steady-state *)

(* in -- NOT distributed for radiation or pairs *)
If[which==0,
rhobnorm=rhobingoing;
bgaussnorm=bgaussTvalue;
solsT={T->myT,npairs->mynpairs};
rhobrad=rhobingoing;
Trad=Tvalue;
solsTrad=solsT; (* no different *)
bgaussrad=bgaussTvalue;
];
(* center -- distributed for radiation and also for non-radiative magnetic field *)
If[which==1,
rhobnorm=rhoc//.fsolssp; (* to be used for everything except directly Q *)
solsT={T->myT,npairs->mynpairs};
rhobrad=(1/2)*(rhobingoing+rhoc)//.fsolssp; (* assume by rhobrad mean to be used for Q *)
rhobrad=rhobingoing; (* reversion *)
(*Trad=(1/2)*(Tvalue+Tc)//.fsolssp;  (* assume by Trad mean to be used for Q *)*)
(* Assume Tc is good for central temperature.  As if rest of region is heated up to same temperature *)
solsTrad=solsT; (* no different *)
bgaussrad=(1/2)*(bgaussTvalue+0)//.fsolssp; (* assume by central mean non-zero field, which in SP language is mostly bbarx *)
bgaussrad=bgaussTvalue; (* reversion *)
bgaussnorm=bgaussrad; (* don't use exactly zero -- assume distributed *)
];
(* out -- distributed for radiation and also for non-radiative magnetic field *)
If[which==2,
rhobnorm=rhoout//.fsolssp; (* to be used for everything except directly Q *)
solsT={T->myT,npairs->mynpairs};
rhobrad=(1/2)*(rhoc+rhoout)//.fsolssp; (* assume by rhobrad mean to be used for Q *)
rhobrad=rhobout//.fsolssp; (* reversion *)
Trad=(1/2)*(Tc+Tout)//.fsolssp;  (* assume by Trad mean to be used for Q *)
solsTrad={T->Trad,npairs->mynpairs};
gammaout=Sqrt[1+uy^2]//.fsolssp;
bxout=Abs[Bx/gammaout//.fsolssp];
bgaussrad=(1/2)*(0+bxout)//.fsolssp; (* assume by central mean non-zero field, which in SP language is mostly bbarx *)
bgaussrad=bxout//.fsolssp; (* reversion *)
bgaussnorm=bgaussrad; (* don't use exactly zero for bc, assume distributed *)
];
(* between in and center -- for radiation term in SP solution *)
If[which==3,
rhobrad=(1/2)*(rhobingoing+rhoc)//.fsolssp; (* assume by rhobrad mean to be used for Q *)
rhobrad=rhobingoing//.fsolssp; (* reversion *)
rhobnorm=rhobrad;
(*Trad=0.5*(Tvalue+Tc)//.fsolssp;  (* assume by Trad mean to be used for Q *)*)
(* Assume Tc is good for central temperature.  As if rest of region is heated up to same temperature *)
Trad=Tc//.fsolssp;  (* assume by Trad mean to be used for Q *)
solsTrad={T->Trad,npairs->mynpairs};
solsT=solsTrad;
bgaussrad=(1/2)*(bgaussTvalue+0)//.fsolssp; (* assume by central mean non-zero field, which in SP language is mostly bbarx *)
bgaussrad=bgaussTvalue; (* reversion *)
bgaussnorm=bgaussrad; (* don't use exactly zero -- assume distributed *)
];
(* between center and out -- for radiation term in SP solution *)
If[which==4,
rhobrad=(1/2)*(rhoc+rhoout)//.fsolssp; (* assume by rhobrad mean to be used for Q *)
rhobrad=rhoout//.fsolssp; (* reversion *)
rhobnorm=rhobrad;
Trad=(1/2)*(Tc+Tout)//.fsolssp;  (* assume by Trad mean to be used for Q *)
solsTrad={T->Trad,npairs->mynpairs};
solsT=solsTrad;
gammaout=Sqrt[1+uy^2]//.fsolssp;
bxout=Abs[Bx/gammaout//.fsolssp];
bgaussrad=(1/2)*(0+bxout)//.fsolssp; (* assume by central mean non-zero field, which in SP language is mostly bbarx *)
bgaussrad=bxout//.fsolssp; (* reversion *)
bgaussnorm=bgaussrad; (* don't use exactly zero for bc, assume distributed *)
];
(* center -- true center -- completely undistributed except for mangetic field *)
If[which==5,
rhobnorm=rhoc//.fsolssp; (* to be used for everything except directly Q *)
solsT={T->myT,npairs->mynpairs};
rhobrad=rhobnorm;
solsTrad=solsT;
(* b must remain distributed somewhat, so assume field goes from external value to 0 within layer, so that typical value is average of those two values *)
bgaussrad=(1/2)*(bgaussTvalue+0)//.fsolssp; (* assume by central mean non-zero field, which in SP language is mostly bbarx *)
bgaussrad=bgaussTvalue; (* reversion *)
bgaussnorm=bgaussrad; (* don't use exactly zero -- assume distributed *)
];


(* return value *)
{rhobnorm,bgaussnorm,solsT,rhobrad,bgaussrad,solsTrad}
];


(* New version that gets temperatures using functions of things *)
getfullPUNQ:=Module[
{foo,solsguess,solstrial,solsTrial,var10,var20,level1,level2,nlevel1,nlevel2,Tguess,npairsguess,ii,Aum,Aumold,totalAiter},

(* CHOICES: whichsplevel and which *)

(* get general functions *)
getPUNQ;

(* get temperatures *)


(* CENTER *)
If[doprintdebug==1 ,Print["full center"];];
(* 0 = simplest assume SP  ;  1 = Uzdensky McKinney 2010  ; 2 = Full SP rel layer solution *)
whichsplevel=1;
(*which=1;*)
which=5; (* 1 and 5 are the same if whichsplevel==0 *)
fullset=chooseposition[which];
{rhobnorm,bgaussnorm,solsT,rhobrad,bgaussrad,solsTrad}=fullset;


(* Get T, npairs, and Aum *)
totalAiter=5;
(* don't have new rhobcenter yet, and want A computed witih both new T and new rhob, so need to iterate to get converged A *)
Aumold=rhobcenter/rhobingoing;
For[ii=1,ii<=totalAiter,

(* get T and npairs and maybe rhobcenter (i.e. Aum) *)
solsTtrial=gettemperaturewrapper[rhobnorm,rhobrad,bgaussnorm,bgaussrad];
(* update T and npairs variables -- needed before getAum *)
iterateindeps;

(* see if need to do silly iteration or already have solution when npairs=0 *)
(* the below conditional still allows entrance when computed Aum, such as when no change.  But this redundancy is not expensive *)
If[Abs[(rhobcenter-rhobingoing)/rhobingoing]>10^(-10) && Abs[npairsrad-0]<10^(-10),
ii=totalAiter+1; (* jump out since apparently already solved for rhobcenter *)

, (* else *)

(* get rhobcenter.  rhobcenter is then used in chooseposition below that effectively iterates all "norms" and "rads" used in rest of code. *)
getAum;
Aum=rhobcenter/rhobingoing;

(* jump out since no big change for small changes in Aum and just takes lots of time and don't have general 3D method coded *)
(* just leave Aum at the <10 value and don't try to resolve for T and npairs *)
If[Aum<Aumtrigger,ii=totalAiter+1;]; 

(* limit update *)
If[Aum/Aumold>2,Aum=Aumold*2];
If[Aum/Aumold<1/2,Aum=Aumold/2];
rhobcenter=rhobingoing*Aum;

If[doprintdebug==1,Print["Aum=",Aum," Aumold=",Aumold];];

If[Abs[Aum-Aumold]/Aumold<RELTOLAum,ii=totalAiter+1;,ii=ii+1;];
Aumold=Aum;


If[ii==totalAiter,Print["Maxed out Aum iterations, so rhobcenter left at rhobcenter=",rhobcenter];];
]; (* End if getting Aum here through silly iteration that barely or doesn't work *)

];


(* OTHER POSITIONS TO DO LATER *)


(* return did ok by passing back 1 *)
1
];


iterateindeps:=Module[
{foo},

(* ITERATED *)
solsT=solsTtrial;
solsTrad=solsT;

myie=Ug[rhobnorm,rhobrad,Tnorm,bgaussnorm,bgaussrad,npairsnorm]; (* rough due to ambiguity of Tnorm vs. Trad and npairsnorm vs. npairsrad *)
myu4vel=0.01; (* not updated really until vrel updated *)
myb=0.001; (* not updated really until Deltaspt updated *)
(* update fsolssp so used in chooseposition *)
fsolssp={d->Lpnum,ux->myu4vel,rhoc->rhobcenter,iec->myie,rhoout->rhobcenter,ieout->myie,Bx->myb,uy->myu4vel};

(* SAVE result for rest of code *)
storeiter[which];(* only stores T and npairs, but not used right now *)

(* update norms and rads and solT's *)
{rhobnorm,bgaussnorm,solsT,rhobrad,bgaussrad,solsTrad}=chooseposition[which];
Tnorm=solsT[[1,2]];
npairsnorm=solsT[[2,2]];
solsTrad[[1,2]];
Trad=solsTrad[[1,2]];
npairsrad=solsTrad[[2,2]];
(* now use rhobnorm, bgaussnorm, solsT, rhobrad, bgaussrad, solsTrad and Tnorm,npairsnorm,Trad,npairsrad in plasma part of math code *)

];


(* get P, U, (N), and Q for a given set of independent variables *)
getPUNQ:=Module[
{foo},
Unprotect[Pbaryon,Ubaryon,Pe,Ue,nb,Ye,np,nn,ne,Pg,Ug,Qtot,nuexpfactorother,Xnuc0other,Xnucother,nuexpfactor,Xnuc0,Xnuc];
Clear[Pbaryon,Ubaryon,Pe,Ue,nb,Ye,np,nn,ne,Pg,Ug,Qtot,nuexpfactorother,Xnuc0other,Xnucother,nuexpfactor,Xnuc0,Xnuc];
(* baryons *)
rho10[rhob_]:=rhob/10^(10);
rho13[rhob_]:=rhob/10^(13);
T11[T_]:=T/10^11;
Tmev[T_]:=(kb*T/ergPmev);

nuexpfactorother=SetPrecision[7.074,lowestprec];
Xnuc0other[rhob0_,T0_]:=Module[{T=T0,rhob=rhob0},26*Tmev[T]^(9/8)*rho10[rhob]^(-3/4)*Exp[-nuexpfactorother/Tmev[T]]];
Xnucother[rhob_,T_]:=If[Tmev[T]<10^(-10) || Xnuc0other[rhob,T]<0 ,0,If[Xnuc0other[rhob,T]>1 ,1,Xnuc0other[rhob,T]]];

(* avoid Underflow in Exp[-nu], so don't let nu become too large *)
nuexpfactor[T_]:=Min[SetPrecision[0.8209,lowestprec]/T11[T],10^(5)];
Xnuc0[rhob0_,T0_]:=Module[{T=T0,rhob=rhob0},296*T11[T]^(9/8)*rho10[rhob]^(-3/4)*Exp[-nuexpfactor[T]]];
Xnuc[rhob_,T_]:=If[Tmev[T]<10^(-10) || Xnuc0[rhob,T]<0 ,0,If[Xnuc0[rhob,T]>1 ,1,Xnuc0[rhob,T]]];

(* assume baryons and electrons compressed in center of layer *)
(*
Pbaryon[rhob_,T_]:=rhob*T*kb/mb;
Ubaryon[rhob_,T_]:=(3/2)*Pbaryon[rhob,T];
*)
(* account for photodissintegration to-from alphas and free nucleons *)
mN=(mn+mp)/2;
Ebin=(283/10)*ergPmev;
Eratio=Ebin/(4*mN*c^2);
Ubaryon[rhob_,T_]:=rhob*(3*kb*T)/(8*mN)*((3-Eratio)*Xnuc[rhob,T]+1)/(1-Eratio);
Pbaryon[rhob_,T_]:=(5/3-1)*Ubaryon[rhob,T];

nb[rhob_]:=rhob/mb;

(* nucleons are degenerate if this is greater than unity *)
degennuc[rhob_,T_]:=nb[rhob]/((kb*T/(hbar*c))^3/Pi^2);

(* ye=1/2 *)
Ye=1/2;Ye=SetPrecision[Ye,lowestprec];
np[rhob_]:=nb[rhob]*Ye;
nn[rhob_]:=nb[rhob]*Ye;
ne[rhob_]:=np[rhob];

Pe[rhob_,T_]:=ne[rhob]*kb*T;
FactorT[T_]:=Min[(kb*T)/(me*c^2),1];
FactorU[T_]:=(3/2)*(1-FactorT[T])+FactorT[T]*3;
Ue[rhob_,T_]:=FactorU[T]*Pe[rhob,T];
(* column depth unaffected by rhobcenter due to total mass conservation, so directly probe background density rather than input density *)
neint[x_]:=(rhobingoing/mb)*Ye*x;
netotint[npairs_,x1_,x2_]:=(rhobingoing/mb)*Ye*x1+npairs*x2;
nbint[x_]:=(rhobingoing/mb)*x;
(* radiation *)
getUPNrad;
(* pairs *)
getUPNpairs;
(* neutrinos *)
getQneutrino;
(* totals *)
(* Notice that "rad" version used for all radiation terms *)
(* Note that rhobcenter compression will occur for all "rhob" terms that aren't "rad"-based *)
(* Notice that neutrinos are *not* distributed and so don't use "rad" since emission should dominate from within current layer *)
Pg[rhob_,rhobrad_,T_,bgauss_,bgaussrad_,npairs_]:=Prad[rhobrad,T,bgaussrad,npairs]+Ppairs[rhobrad,T,bgaussrad,npairs]+Pbaryon[rhob,T]+Pe[rhob,T]+Pnu[rhob,T,bgauss,npairs];
Ug[rhob_,rhobrad_,T_,bgauss_,bgaussrad_,npairs_]:=Urad[rhobrad,T,bgaussrad,npairs]+Upairs[rhobrad,T,bgaussrad,npairs]+Ubaryon[rhob,T]+Ue[rhob,T]+Unu[rhob,T,bgauss,npairs];
Qmag[rhob_,T_,bgauss_,npairs_]:=Module[{Qbterm,rdiss,vrdiss,result},
(* model specific *)
rdiss=5.3*10^(13);
vrdiss=0.02*c//.consts;
(* heating term, so negative cooling *)
Qbterm=-2*(bgauss^2/(4*Pi))*(vrdiss/Lpnum);
result=If[includediss==1 && Ljet>rdiss,Qbterm,0];
(* return *)
result
];

Qtot[rhob_,rhobrad_,T_,bgauss_,bgaussrad_,npairs_]:=Qrad[rhobrad,T,bgaussrad,npairs]+Qnu[rhob,T,bgauss,npairs];

(* ABOVE Ug and Pg must be free of any T assignment using solsT since have to solve for T explicitly using FindRoot *)
Protect[Pbaryon,Ubaryon,Pe,Ue,nb,Ye,np,nn,ne,Pg,Ug,Qtot,nuexpfactorother,Xnuc0other,Xnucother,nuexpfactor,Xnuc0,Xnuc];
];


(* Get photon U, P, n, and Q *)
getUPNrad:=Module[
{foo},
Unprotect[Nscal,Nscam,Nscalayers,sigmakn,sigmaB,El1,eeB0,eeB,sigmaes,dtauradscads,tauradsca,Hsca,Nabslayers,urad0,Frad0,dtauradabsds,tauradabs,Habs,tauradtot,damptaurad,Urad,Prad,damptaurad2,Frad,Qrad,nrad,nrad0,gammaeeff2,Eeeff2,peeff2,pphoton2,dpphotoneff,xpphotoneff,scatterfactor2,neeff,neinteff,npairseff];
(* see if radiation is trapped over Lpnum to see what is heating gas *)
(*Print["taurad"];*)
(* Need Klein-Nishina? *)
(* http://www.irs.inms.nrc.ca/EGSnrc/pirs701/node33.html *)
(* http://www.springerlink.com/content/013232u344rl7397/ *)
(* NOTE: below uses Lpnum, but if only looking at layer, should be Deltasp, but don't have that yet! *)
(* below ne in radiation opacity should include electrons and positrons in flow, but don't have positrons yet, so have to iterate! *)
(*Nscallimit=(Rjetmod/Hsca+2);
Nscal=Min[lmode-1,Nscallimit]//.consts;
*)
Nscal=lmode-1//.consts;
Nscam=If[mmode==0,0,1]//.consts;
Nscalayers=Max[Nscal,Nscam];
(* stupid, npairs is cumulative already as used everywhere else, so force 1 here for simplicity and reversibility *)
Numscalayers=1; 

sigmakn[T_]:=sigmat/(1+(3*me*c^2/(8*kb*T))^(-1));
sigmaB[T_,bgauss_]:=sigmat/(1 + ( (Sqrt[5]*Pi*me*c^2*kb*T)/(hbar*c*q*bgauss) )^(-2) );
(* Don't let get smaller than 10^(-5) electron masses *)
El1[bgauss_]:=10^(-5)*me*c^2 + ( (me*c^2)^2+2*hbar*c*q*bgauss)^(1/2) - me*c^2;
eeB0[bgauss_]:=Exp[-Min[me*c^2/(El1[bgauss]),10^4]];
eeB[bgauss_]:=If[eeB0[bgauss]=!=Underflow[],eeB0[bgauss],0];
sigmaes[T_,bgauss_]:=sigmaB[T,bgauss]*eeB[bgauss]+sigmakn[T]*(1-eeB[bgauss]);

(* effective scatters *)
Eeeff2[rhob_,T_]:=me*c^2+Ue[rhob,T]/ne[rhob]; (* effective particle energy that changes around me c^2 *)
peeff2[rhob_,T_]:=Sqrt[Eeeff2[rhob,T]^2/c^2-me^2*c^2]; (* peeff2 = gammaeeff2*me*ve2 *)
pphoton2[T_]:=(3*kb*T)/c; (* 4/3 thermal particle *)
dpphotoneff[rhob_,T_,bgauss_,npairs_]:=Min[peeff2[rhob,T],pphoton2[T]];
xpphotoneff[rhob_,T_,bgauss_,npairs_]:=(dpphotoneff[rhob,T,bgauss,npairs]/pphoton2[T]);
scatterfactor2[rhob_,T_,bgauss_,npairs_]:=Min[xpphotoneff[rhob,T,bgauss,npairs]^2,xpphotoneff[rhob,T,bgauss,npairs]];
neeff[rhob_,T_,bgauss_,npairs_]:=ne[rhob]*scatterfactor2[rhob,T,bgauss,npairs];
neinteff[rhob_,T_,bgauss_,npairs_]:=neint[Rjetmod]*scatterfactor2[rhob,T,bgauss,npairs];
npairseff[rhob_,T_,bgauss_,npairs_]:=(npairs)*scatterfactor2[rhob,T,bgauss,npairs];

(* dtauradscads not really used *)
dtauradscads[rhob_,T_,bgauss_,npairs_]:=sigmaes[T,bgauss]*(neinteff[rhob,T,bgauss,npairs]/Rjetmod+npairseff[rhob,T,bgauss,npairs])//.consts;
columndepthsca[rhob_,T_,bgauss_,npairs_]:=npairseff[rhob,T,bgauss,npairs]*Nscalayers*Lpmodnum +neinteff[rhob,T,bgauss,npairs];
tauradsca[rhob_,T_,bgauss_,npairs_]:=sigmaes[T,bgauss]*columndepthsca[rhob,T,bgauss,npairs]//.consts;
(* Hsca not really used *)
Hsca[rhob_,T_,bgauss_,npairs_]:=(tauradsca[rhob,T,bgauss,npairs]/dtauradscads[rhob,T,bgauss,npairs])//.consts;

(* ABS *)
(* !! don't use netoteff since sigmaff and sigmasynch used netot and want terms to cancel !! *)
Nabslayers=Nscalayers;
urad0[T_]:=arad*T^4;
nrad0[T_]:=urad0[T]/(4*kb*T);
Frad0[T_]:=c*urad0[T];
getsigmaphoton; (* computes sigmaff and sigmasynch *)
(* used netot below since ele+pos are emitting paricles and just removes division by netot in sigma's *)
dtauradabsds[rhob_,T_,bgauss_,npairs_]:=netot[rhob,npairs]*(sigmaff[rhob,T,bgauss,npairs]+sigmasynch[rhob,T,bgauss,npairs]) + npairs*sigmapairs2gamma[rhob,T,bgauss,npairs];
columndepthabs[rhob_,npairs_]:=npairs*Nabslayers*Lpmodnum+neint[Rjetmod];
(* note that division by netot[rhob,npairs] does not use netotint since just removed netot from dtauradabsds *)
tauradabs[rhob_,T_,bgauss_,npairs_]:=columndepthabs[rhob,npairs]*(sigmaff[rhob,T,bgauss,npairs]+sigmasynch[rhob,T,bgauss,npairs]) + npairs*Nabslayers*Lpmodnum*sigmapairs2gamma[rhob,T,bgauss,npairs];
(* below is basically sigma*L for each correct term since here only electrons emit *)
Habs[rhob_,T_,bgauss_,npairs_]:=(tauradabs[rhob,T,bgauss,npairs]/dtauradabsds[rhob,T,bgauss,npairs])//.consts;
(* total *)
tauradtot[rhob_,T_,bgauss_,npairs_]:=(tauradabs[rhob,T,bgauss,npairs]+tauradsca[rhob,T,bgauss,npairs]);
damptaurad[rhob_,T_,bgauss_,npairs_]:=(3*tauradtot[rhob,T,bgauss,npairs]+2*Sqrt[3])/(3*tauradtot[rhob,T,bgauss,npairs]+2*Sqrt[3]+2/tauradabs[rhob,T,bgauss,npairs]);

Urad[rhob_,T_,bgauss_,npairs_]:=urad0[T]*damptaurad[rhob,T,bgauss,npairs];
nrad[rhob_,T_,bgauss_,npairs_]:=nrad0[T]*damptaurad[rhob,T,bgauss,npairs];
Prad[rhob_,T_,bgauss_,npairs_]:=Urad[rhob,T,bgauss,npairs]/3;

damptaurad2[rhob_,T_,bgauss_,npairs_]:=(1/3)/(tauradtot[rhob,T,bgauss,npairs]/2+1/Sqrt[3]+1/(3*tauradabs[rhob,T,bgauss,npairs]));
Frad[rhob_,T_,bgauss_,npairs_]:=Frad0[T]*damptaurad2[rhob,T,bgauss,npairs];
Qrad[rhob_,T_,bgauss_,npairs_]:=Module[{frad,habs,result},
frad=Frad[rhob,T,bgauss,npairs];
habs=Habs[rhob,T,bgauss,npairs];
result=frad/habs;
If[doprintdebug==1,Print["Qrad: ",frad," ",habs," ",result];];
(* return *)
result
];

Protect[Nscal,Nscam,Nscalayers,sigmakn,sigmaB,El1,eeB0,eeB,sigmaes,dtauradscads,tauradsca,Hsca,Nabslayers,urad0,Frad0,dtauradabsds,tauradabs,Habs,tauradtot,damptaurad,Urad,Prad,damptaurad2,Frad,Qrad,nrad,nrad0,gammaeeff2,Eeeff2,peeff2,pphoton2,dpphotoneff,xpphotoneff,scatterfactor2,neeff,neinteff,npairseff];
];





getUPNpairs:=Module[
{foo},
Unprotect[e10,e1,e20,e2,uapairs0,ubpairs0,ucpairs0,udpairs0,Upairs0qed,Ppairs0qed,npairs0qed,npairs0,Upairs0,Ppairs0];
(* wrong way to get pair density *)
(*
omegag=(q*bgaussrad)/(gammae*me*c);
Tg=2*Pi/omegag;
taupairpne=Min[taupairL,taurad*Max[1,Tann/Tg]];
damptaupair=(3*taupairpne+2*Sqrt[3])/(3*taupairpne+2*Sqrt[3]+2/taupairpne);
Ppairs=arad*T^4*(7/12)*Exp[-me*c^2/(kb*T)]*damptaupair;
Upairs=Ppairs/(4/3-1);
*)
Clear[npairs0qed];
(* pair density in new paper revision assuming chemical equilibrium with photons *)
Clear[e10,e1,e20,e2];
e10[T_]:=Exp[-Min[me*c^2/(kb*T),10^4]];
e1[T_]:=If[Evaluate[e10[T]]=!=Underflow[],Evaluate[e10[T]],0];
e20[T_,bgauss_]:=Exp[-Min[kb*T/(El1[bgauss]),10^4]];
e2[T_,bgauss_]:=If[e20[T,bgauss]=!=Underflow[],e20[T,bgauss],0];
Clear[uapairs0,ubpairs0,ucpairs0,udpairs0];
uapairs0[T_,bgauss_]:=(7/4)*urad0[T]*e1[T]*(1-e2[T,bgauss]);
ubpairs0[T_,bgauss_]:=2^(1/2)/Pi^(3/2)*(me*c^2)^4/(hbar*c)^3*(kb*T/(me*c^2))^(3/2)*e1[T]*(1-e2[T,bgauss]);
ucpairs0[T_,bgauss_]:=(1/12)*hbar*c*q*bgauss/(hbar*c)^3*(kb*T)^2*e1[T]*e2[T,bgauss];
udpairs0[T_,bgauss_]:=(hbar*c*q*bgauss)*(me*c^2)^2/((2*Pi^3)^(1/2)*(hbar*c)^3)*(kb*T/(me*c^2))^(1/2)*e1[T]*e2[T,bgauss];
Upairs0qed[T_,bgauss_]:=uapairs0[T,bgauss]+ubpairs0[T,bgauss]+ucpairs0[T,bgauss]+udpairs0[T,bgauss];
Ppairs0qed[T_,bgauss_]:=uapairs0[T,bgauss]/3+2*ubpairs0[T,bgauss]/3+ucpairs0[T,bgauss]/3+2*udpairs0[T,bgauss]/3;
(* number density of pairs is indirectly (due to pg=pm) related to magnetic field strength. So below a certain magnetic field strength there should be few pairs *)

(* TRUE-ITERATED -- solved with T now since otherwise simple overall iteration and only solving for T led to flip-flop behavior and never converged.
So below is used as equation instead when calling gettemperature *)
(* FactorN = (gamma-1) : 2/3 -> 1/3 as T gets higher *)
(*FactorN[T_]:=(2/3)*(1-FactorT[T])+FactorT[T]*(1/3);
npairs0qed[T_,bgauss_]:=FactorN[T]*Upairs0qed[T,bgauss]/(kb*T);
*)

(* Just use P = n k T *)
npairs0qed[T_,bgauss_]:=Ppairs0qed[T,bgauss]/(kb*T);

(* if in non-QED regime, use more accurate solution *)
(* But this forces ?pairs to not be function of T -- problem if photon radiation term wasn't there probably *)
getUPNpairsnoqed;

Clear[npairs0,Upairs0,Ppairs0];

(* SUPERDEBUG *)
methodpairs0=2;
(* 1 = only simple *)
(* 2 = combine -- most accurate *)

If[methodpairs0==2,
npairs0[rhob_,T_,bgauss_]:=If[e2[T,bgauss]<0.1,npairs0noqed[rhob,T],npairs0qed[T,bgauss]];
Upairs0[rhob_,T_,bgauss_]:=If[e2[T,bgauss]<0.1,Upairs0noqed[rhob,T],Upairs0qed[T,bgauss]];
Ppairs0[rhob_,T_,bgauss_]:=If[e2[T,bgauss]<0.1,Ppairs0noqed[rhob,T],Ppairs0qed[T,bgauss]];
];

If[methodpairs0==1,
npairs0[rhob_,T_,bgauss_]:=npairs0qed[T,bgauss];
Upairs0[rhob_,T_,bgauss_]:=Upairs0qed[T,bgauss];
Ppairs0[rhob_,T_,bgauss_]:=Ppairs0qed[T,bgauss];
];

(* get final pair results using opacity effects *)
getpairsopacitystuff;

Protect[e10,e1,e20,e2,uapairs0,ubpairs0,ucpairs0,udpairs0,Upairs0qed,Ppairs0qed,npairs0qed,npairs0,Upairs0,Ppairs0];
];


getpairsopacitystuff:=Module[
{foo},

Unprotect[gammaeeff,Eeeff,nradeff,dtaupairsscads,taupairssca,Hpairssca,Fpairs0,dtaupairsabsds,taupairsabs,Hpairsabs,taupairstot,damptaupairs,Upairs,npairsfunc,Ppairs,damptaupairs2,Fpairs,Qpairs,dtaunumpairsabsds,taunumpairsabs,Hnumpairsabs,taunumpairstot,damptaunumpairs,damptaunumpairs2,Fnumpairs,Rpairs,peeff,pphoton,dpeeff,xpeeff];

(* get optically thin rates *)
getthinpairs;

veffpairsold[rhob_,T_,bgauss_,npairs_]:=Module[{result,bottom,gammae,ve,top},
gammae=1+Ue[rhob,T]/ne[rhob]/(me*c^2);
ve=c*Sqrt[1-1/gammae^2];
top=Rpairs2gamma[rhob,T,bgauss,npairs];
bottom=Rgg2pairs[rhob,T,bgauss,npairs]+Rge2pairs[rhob,T,bgauss,npairs];
(* below causes division by zero, so avoid this form *)
(*result=(c/bottom + ve/top)/(1/bottom+1/top);*)
(* multiply numer and denon by top*bottom *)
result=(c*top + ve*bottom)/(top+bottom);
(* return *)
result
(* return c since otherwise too noisy *)
(* verified that is c over all of relevant parameter space *)
(* or is it always ve? *)
(*ve*)
(* actually, that factor is not stream velocity and is included in form for sigma as <sigma v>/c for effective absorption or emission *)
];

veffpairsold2[rhob_,T_,bgauss_,npairs_]:=Module[{result,bottom,gammae,ve,top},
(* return *)
c
];

veffpairs[rhob_,T_,bgauss_,npairs_]:=Module[{result,bottom,gammae,ve,top},
gammae=1+Ue[rhob,T]/ne[rhob]/(me*c^2);
ve=c*Sqrt[1-1/gammae^2];
(* return *)
ve
];

(* Get effective number density of photons that can scatter pairs *)
Eeeff[rhob_,T_]:=me*c^2+Ue[rhob,T]/ne[rhob]; (* effective particle energy that changes around me c^2 *)
peeff[rhob_,T_]:=Sqrt[Eeeff[rhob,T]^2/c^2-me^2*c^2]; (* peeff = gammaeeff*me*ve *)
(* could use urad/nrad here since not recursively defined, but keep approximation level consistent.  Well, go ahead and use... *)
(*pphoton[rhob_,T_,bgauss_,npairs_]:=(3*kb*T)/c; (* 4/3 gamma, thermal photon *)*)
pphoton[rhob_,T_,bgauss_,npairs_]:=(Urad[rhob,T,bgauss,npairs]/nrad[rhob,T,bgauss,npairs])/c;
dpeeff[rhob_,T_,bgauss_,npairs_]:=Min[peeff[rhob,T],pphoton[rhob,T,bgauss,npairs]];
xpeeff[rhob_,T_,bgauss_,npairs_]:=(dpeeff[rhob,T,bgauss,npairs]/peeff[rhob,T]);
nradeff[rhob_,T_,bgauss_,npairs_]:=nrad[rhob,T,bgauss,npairs]*Min[xpeeff[rhob,T,bgauss,npairs]^2,xpeeff[rhob,T,bgauss,npairs]];


(* scatter opacity *)
(* Coulomb uses npairs/2 since Debye screening only applies to opposite charges, which dominates *)
taupairssca[rhob_,T_,bgauss_,npairs_]:=(sigmaes[T,bgauss]*nradeff[rhob,T,bgauss,npairs]*Lpmodnum + sigmacoul[rhob,T,bgauss,npairs/2]*netotint[npairs/2,Rjetmod,Lpmodnum])//.consts;
dtaupairsscads[rhob_,T_,bgauss_,npairs_]:=(sigmaes[T,bgauss]*nradeff[rhob,T,bgauss,npairs]+sigmacoul[rhob,T,bgauss,npairs/2]*(neint[Rjetmod]/Rjetmod + npairs/2))//.consts;
Hpairssca[rhob_,T_,bgauss_,npairs_]:=taupairssca[rhob,T,bgauss,npairs]/dtaupairsscads[rhob,T,bgauss,npairs];


(* ENERGY abs opacity *)
Fpairs0[rhob_,T_,bgauss_,npairs_]:=veffpairs[rhob,T,bgauss,npairs]*Upairs0[rhob,T,bgauss];
(* if npairs small, then npairs0 can be 0 due to small errors and need to avoid division by zero such that result is same as when end up multiplying by npairs0 Upairs0 or Ppairs0 as 0 at end *)
(* this also helps speed in this limit *)
dtaupairsabsds[rhob_,T_,bgauss_,npairs_]:=Module[{tempnpairs0,dtau,result},
tempnpairs0=npairs0[rhob,T,bgauss];
dtau[rhobx_,Tx_,bgaussx_,npairsx_]:=Q2pairs[rhobx,Tx,bgaussx,npairsx]/(veffpairs[rhobx,Tx,bgaussx,npairsx]*Upairs0[rhobx,Tx,bgaussx]);
result=If[tempnpairs0<lowestnpairsperne*ne[rhob],10^(-50),dtau[rhob,T,bgauss,npairs]];
(* return *)
result
];
taupairsabs[rhob_,T_,bgauss_,npairs_]:=dtaupairsabsds[rhob,T,bgauss,npairs]*Lpmodnum;
Hpairsabs[rhob_,T_,bgauss_,npairs_]:=Lpmodnum;
(* total *)
taupairstot[rhob_,T_,bgauss_,npairs_]:=(taupairsabs[rhob,T,bgauss,npairs]+taupairssca[rhob,T,bgauss,npairs]);
damptaupairs[rhob_,T_,bgauss_,npairs_]:=(3*taupairstot[rhob,T,bgauss,npairs]+2*Sqrt[3])/(3*taupairstot[rhob,T,bgauss,npairs]+2*Sqrt[3]+2/taupairsabs[rhob,T,bgauss,npairs]);

(* NUMBER abs opacity *)
Fnumpairs0[rhob_,T_,bgauss_,npairs_]:=veffpairs[rhob,T,bgauss,npairs]*npairs0[rhob,T,bgauss];
dtaunumpairsabsds[rhob_,T_,bgauss_,npairs_]:=Module[{tempnpairs0,dtau,result},
tempnpairs0=npairs0[rhob,T,bgauss];
dtau[rhobx_,Tx_,bgaussx_,npairsx_]:=R2pairs[rhobx,Tx,bgaussx,npairsx]/(veffpairs[rhobx,Tx,bgaussx,npairsx]*npairs0[rhobx,Tx,bgaussx]);
result=If[tempnpairs0<lowestnpairsperne*ne[rhob],10^(-50),dtau[rhob,T,bgauss,npairs]];
(* return *)
result
];
taunumpairsabs[rhob_,T_,bgauss_,npairs_]:=dtaunumpairsabsds[rhob,T,bgauss,npairs]*Lpmodnum;
Hnumpairsabs[rhob_,T_,bgauss_,npairs_]:=Lpmodnum;
(* total *)
taunumpairstot[rhob_,T_,bgauss_,npairs_]:=(taunumpairsabs[rhob,T,bgauss,npairs]+taupairssca[rhob,T,bgauss,npairs]);
damptaunumpairs[rhob_,T_,bgauss_,npairs_]:=(3*taunumpairstot[rhob,T,bgauss,npairs]+2*Sqrt[3])/(3*taunumpairstot[rhob,T,bgauss,npairs]+2*Sqrt[3]+2/taunumpairsabs[rhob,T,bgauss,npairs]);


Clear[npairsfunc,Upairs,Ppairs];
Upairs[rhob_,T_,bgauss_,npairs_]:=Upairs0[rhob,T,bgauss]*damptaupairs[rhob,T,bgauss,npairs];
Ppairs[rhob_,T_,bgauss_,npairs_]:=Ppairs0[rhob,T,bgauss]*damptaupairs[rhob,T,bgauss,npairs];
 (* npairs should be left as free variable *)
(* note npairsfunc (so npairs) uses number energy density rates *)
npairsfunc[rhob_,T_,bgauss_,npairs_]:=npairs0[rhob,T,bgauss]*damptaunumpairs[rhob,T,bgauss,npairs];


(* ENERGY *)
damptaupairs2[rhob_,T_,bgauss_,npairs_]:=(1/3)/(taupairstot[rhob,T,bgauss,npairs]/2+1/Sqrt[3]+1/(3*taupairsabs[rhob,T,bgauss,npairs]));
Fpairs[rhob_,T_,bgauss_,npairs_]:=Fpairs0[rhob,T,bgauss,npairs]*damptaupairs2[rhob,T,bgauss,npairs];
Qpairs[rhob_,T_,bgauss_,npairs_]:=Module[{fpairs,hpairsabs,result},
fpairs=Fpairs[rhob,T,bgauss,npairs];
hpairsabs=Hpairsabs[rhob,T,bgauss,npairs];
result=fpairs/hpairsabs;
If[doprintdebug==1,Print["Qpairs: ",fpairs," ",hpairsabs," ",result];];
(* return *)
result
];

(* NUMBER *)
damptaunumpairs2[rhob_,T_,bgauss_,npairs_]:=(1/3)/(taunumpairstot[rhob,T,bgauss,npairs]/2+1/Sqrt[3]+1/(3*taunumpairsabs[rhob,T,bgauss,npairs]));
Fnumpairs[rhob_,T_,bgauss_,npairs_]:=Fnumpairs0[rhob,T,bgauss,npairs]*damptaunumpairs2[rhob,T,bgauss,npairs];
Rpairs[rhob_,T_,bgauss_,npairs_]:=Module[{fnumpairs,hnumpairsabs,result},
fnumpairs=Fnumpairs[rhob,T,bgauss,npairs];
hnumpairsabs=Hnumpairsabs[rhob,T,bgauss,npairs];
result=fnumpairs/hnumpairsabs;
If[doprintdebug==1,Print["Rpairs: ",fnumpairs," ",hnumpairsabs," ",result];];
(* return *)
result
];


(* old way *)
(*
Clear[npairsfunc,Upairs,Ppairs];
npairsfunc[rhob_,T_,bgauss_,npairs_]:=npairs0[rhob,T,bgauss]*damptaurad[rhob,T,bgauss,npairs]; (* npairs should be left as free variable *)
Upairs[rhob_,T_,bgauss_,npairs_]:=Upairs0[rhob,T,bgauss]*damptaurad[rhob,T,bgauss,npairs];
Ppairs[rhob_,T_,bgauss_,npairs_]:=Ppairs0[rhob,T,bgauss]*damptaurad[rhob,T,bgauss,npairs];
*)

Protect[gammaeeff,Eeeff,nradeff,dtaupairsscads,taupairssca,Hpairssca,Fpairs0,dtaupairsabsds,taupairsabs,Hpairsabs,taupairstot,damptaupairs,Upairs,npairsfunc,Ppairs,damptaupairs2,Fpairs,Qpairs,dtaunumpairsabsds,taunumpairsabs,Hnumpairsabs,taunumpairstot,damptaunumpairs,damptaunumpairs2,Fnumpairs,Rpairs,peeff,pphoton,dpeeff,xpeeff];

];


getthinpairs:=Module[
{foo},

Unprotect[CE,Phi,sigmagg2pairs,Theta3,xipairs,sigmage2pair,ngam,fg,pge,pgg,fgx,isone,Rgg2pairs,Rge2pairs,Ree2pairs,R2pairs,Egam,Ee2,Qgg2pairs,Qge2pairs,Qee2pairs,Q2pairs,gammam1pairs2,Eepairs2];

(* pair or electron energy without rest-mass *)
Ee2[rhob_,T_,npairs_]:=Ue[rhob,T]/ne[rhob];
Egam[rhob_,T_,bgauss_,npairs_]:=Urad[rhob,T,bgauss,npairs]/nrad[rhob,T,bgauss,npairs];


CE[mug_,T_]:=Exp[-mug/(kb*T)];
Phi[eg_]:=me*c^2/eg;
sigmagg2pairs[eg_,mug_]:=Module[{myphi,result},
myphi[egx_]:=Pi*radiuse^2*Phi[egx]^2*((2+2*Phi[egx]^2-Phi[egx]^4)*ArcCosh[1/Phi[egx]]-(1+Phi[egx]^2)*(1-Phi[egx]^2)^(1/2));
result=If[Phi[eg]<1,myphi[eg],0];
(* return *)
result
];
(*xipairs[eg_]:=eg/(kb*T)*)
Theta3[T_]:=kb*T/(me*c^2);
xipairs[eg_,T_]:=1/(Theta3[T]*Phi[eg]);
sigmaxipairs[xi_,mug_,T_]:=sigmagg2pairs[xi*kb*T,mug];
ClearAll[halfsigmavgg];
halfsigmavgg[mug_?NumericQ,nmax_?NumericQ,lmax_?NumericQ,T_?NumericQ]:=halfsigmavgg[mug,nmax,lmax,T]=Module[{n,l,x},
Re[c*Sum[(1/(Sqrt[n*l]*CE[mug,T]^(n+1)))*NIntegrate[sigmaxipairs[x,mug,T]*x^4*BesselK[1,2*Sqrt[n*l]*x],{x,0,Infinity},Evaluate[pairrateintprec[[1]]]],{n,1,nmax},{l,1,lmax}]]
];
(* Then Rgg = ng0^2*sigmavgg/2 *)
(* integral part already accounts for low-energy vs. high-energy photons *)
(* Weaver equation 30 and 31 show Rgg is npairs/2 rate *)
Rgg2pairs[rhob_,T_,bgauss_,npairs_]:=2*nrad[rhob,T,bgauss,npairs]^2*halfsigmavgg[0,2,2,T];
(* 0.5 is to get average energy per pairs *)
Qgg2pairs[rhob_,T_,bgauss_,npairs_]:=0.5*(2*Egam[rhob,T,bgauss,npairs])*nrad[rhob,T,bgauss,npairs]^2*halfsigmavgg[0,2,2,T];


(* omega = Eg/(me*c^2) *)
sigmage2pair[omega_?NumericQ]:=Module[{parta,partb,partc,partd,prefactor,result},
prefactor=(sigmat*3*alpha/(8*Pi));
parta[w_]:=(5.6+20.4*(omega-4)-10.9*(omega-4)^2-3.6*(omega-4)^3+7.4*(omega-4)^4)*10^(-3)*(omega-4)^2;
partb[w_]:=0.582814-0.29842*omega+0.04354*omega^2-0.0012977*omega^3;
partc[w_]:=(3.1247-1.3397*omega+0.14612*omega^2)/(1+0.4648*omega+0.016683*omega^2);
partd[w_]:=(84*Log[2*omega]-218)/27+(-1.333*Log[2*omega]^3+3.863*Log[2*omega]^2-11*Log[2*omega]+27.9)/omega;
result=If[omega<=4,0,If[omega>4&&omega<=4.6,parta[omega],If[omega>4.6&&omega<=6.0,partb[omega],If[omega>6.0&&omega<=14,partc[omega],partd[omega]]]]];
result=result*prefactor;
(* return *)
result
];
(* test *)
(*Plot[sigmage2pair[x],{x,0,20}]*)

ngam[mug_,nmax_,T_]:=Module[
{n},
16*Pi*(kb*T)^3/(h*c)^3*Sum[1/(n^3*CE[mug,T]^n),{n,1,nmax}]
];
fg[pg_,mug_,nmax_,T_]:=8*Pi*me*c^2/((h*c)^3*ngam[mug,nmax,T])*(pg*c)^2/(CE[mug,T]*Exp[pg*c/(kb*T)]-1);
(* p for electron *)
pge[eg_]:=(eg^2-me^2*c^4)/c^2;
(* p for photon *)
pgg[eg_]:=eg/c;
(* fgenx is x that is Eg/(me*c^2) *)
fgx[x_?NumericQ,mug_?NumericQ,nmax_?NumericQ,T_?NumericQ]:=fg[pgg[x*me*c^2],mug,nmax,T];
(* below should be 1 if did right thing *)
isone[T_]:=Module[
{x},
NIntegrate[fgx[x,0,3,T],{x,0,Infinity}]
];

(* x = Eg/(me*c^2) *)
(* ,AccuracyGoal->Infinity,PrecisionGoal->4]*)
(*
sigmaveg[mug_,nmax_,T_]:=(sigmat*c)/(2*BesselK[2,1/Theta3[T]])*NIntegrate[fgx[x,mug,nmax,T]/x^2*NIntegrate[xr*sigmage2pair[xr]/sigmat*Exp[-(x/xr+xr/x)/(2*Theta3[T])],{xr,4,Infinity},AccuracyGoal->Infinity,PrecisionGoal->4],{x,0,Infinity},AccuracyGoal->Infinity,PrecisionGoal->4]
*)
ClearAll[sigmaveg];
sigmaveg[mug_?NumericQ,nmax_?NumericQ,T_?NumericQ]:=sigmaveg[mug,nmax,T]=Module[
{x,xr},
(sigmat*c)/(2*BesselK[2,1/Theta3[T]])*NIntegrate[fgx[x,mug,nmax,T]/x^2*xr*sigmage2pair[xr]/sigmat*Exp[-(x/xr+xr/x)/(2*Theta3[T])],{xr,4,Infinity},{x,0,Infinity},Evaluate[pairrateintprec[[1]]]]
];
(* then Rge=sigmaveg*ne*ng0 *)
(* integral part already accounts for low-energy vs. high-energy photons *)
(* factor of 2 accounts for fact that original paper gives rate of npairs/2 not npairs, and we use this in Kirchhoff's law using total npairs *)
Rge2pairs[rhob_,T_,bgauss_,npairs_]:=2*(ne[rhob]+npairs)*nrad[rhob,T,bgauss,npairs]*sigmaveg[0,2,T];
(* 0.5 accounts for average energy per pair since used 2* above *)
(* original rate is for rate of creating nplus = npairs/2 and already modified it to be for each e^+ e^-, so do NOT multiply again by 2 *)
Qge2pairs[rhob_,T_,bgauss_,npairs_]:=0.5*(Ee2[rhob,T,npairs]+Egam[rhob,T,bgauss,npairs])*(ne[rhob]+npairs)*nrad[rhob,T,bgauss,npairs]*sigmaveg[0,2,T];


Clear[sigmavee2pairs];
sigmavee2pairs[T_]:=Module[{result,myresult},
result[Tx_]:=8.4*10^(-6)*sigmat*c*(Log[Theta3[Tx]])^3;
myresult=If[Theta3[T]>=1,result[T],0];
(* return *)
myresult
];
(* then Ree=sigmavee*netot^2 *)
Ree2pairs[rhob_,T_,bgauss_,npairs_]:=2*(ne[rhob]+npairs)^2*sigmavee2pairs[T];
Qee2pairs[rhob_,T_,bgauss_,npairs_]:=0.5*(2*Ee2[rhob,T,npairs])*(ne[rhob]+npairs)^2*sigmavee2pairs[T];

(* total optically thin pair creation rate *)
R2pairs[rhob_,T_,bgauss_,npairs_]:=Rgg2pairs[rhob,T,bgauss,npairs]+Rge2pairs[rhob,T,bgauss,npairs]+Ree2pairs[rhob,T,bgauss,npairs];

(* total optically thin pair creation rate *)
Q2pairs[rhob_,T_,bgauss_,npairs_]:=Qgg2pairs[rhob,T,bgauss,npairs]+Qge2pairs[rhob,T,bgauss,npairs]+Qee2pairs[rhob,T,bgauss,npairs];


Protect[CE,Phi,sigmagg2pairs,Theta3,xipairs,sigmage2pair,ngam,fg,pge,pgg,fgx,isone,Rgg2pairs,Rge2pairs,Ree2pairs,R2pairs,Egam,Ee2,Qgg2pairs,Qge2pairs,Qee2pairs,Q2pairs,gammam1pairs2,Eepairs2];

];


(* full pairs without QED *)
getUPNpairsnoqed:=Module[
{foo,x},
Unprotect[myprecnoqed,mecsq,getUPNpairsnoqedprefactor,Yeprec,nbprec,Ee,Yefun,myetae,npairs0noqed,negen,Ppairs0noqed,Upairs0noqed,fplus,fminus];
(* Problem is NIntegrate is inaccurate.  If try changing Workprecision or Accuracygoal, then gets crazy answers -- maybe precision needs to be forced for entire expression? *)

Clear[neplus,neminus,peplus,peminus,ueplus,ueminus]; (* storing these, so don't protect *)

Clear[Ee,fplus,fminus,negen,x,etae];
myprecnoqed=lowestprec;
mecsq=SetPrecision[(me*c^2),myprecnoqed];
getUPNpairsnoqedprefactor=SetPrecision[1/(Pi^2*(hbar*c)^3),myprecnoqed];
Yeprec=SetPrecision[Ye,myprecnoqed];
nbprec[rhob_]:=SetPrecision[nb[rhob],myprecnoqed];
Clear[Ee,fplus,fminus,Yefun,myetae];
Ee[x_]:=Sqrt[x^2+mecsq^2];
(* enforce precision regardless of how small Exp results in so other operations using the result are correct *)
fplus[x_,etae_,T_]:=SetPrecision[1/(Exp[Ee[x]/(kb*T)+etae]+1),lowestprec];
fminus[x_,etae_,T_]:=SetPrecision[1/(Exp[Ee[x]/(kb*T)-etae]+1),lowestprec];
neplus[etae_?NumericQ,T_?NumericQ,precarg_]:=neplus[etae,T,precarg]=getUPNpairsnoqedprefactor*NIntegrate[x^2*fplus[x,etae,T],{x,0,Infinity},Evaluate[precarg[[1]]]];
(* ,AccuracyGoal->Infinity,PrecisionGoal->15];*)
neminus[etae_?NumericQ,T_?NumericQ,precarg_]:=neminus[etae,T,precarg]=getUPNpairsnoqedprefactor*NIntegrate[x^2*fminus[x,etae,T],{x,0,Infinity},Evaluate[precarg[[1]]]];
(* ,AccuracyGoal->Infinity,PrecisionGoal->15];*)
Yefun[etae_,rhob_,T_,precarg_]:=(neminus[etae,T,precarg]-neplus[etae,T,precarg])/nbprec[rhob];
(* Yefun is a function we are passing, not a value *)
myetae[rhob_,T_]:=SetPrecision[getetae[Yefun,Yeprec,rhob,T,slowprec],lowestprec];
myetaetrue[rhob_,T_]:=SetPrecision[getetaeslow[Yefun,Yeprec,rhob,T,slowprec],lowestprec];
(*myetae[rhob_,T_]:=0; (* SUPERDEBUG: hack assuming always non-degen since too slow otherwise *)*)

Clear[npairs0noqed];
(* npairs is total number of electrons+positrons without non-pair part*)
(* subtract off non-pair producing part *)
(* and truncate so pairs don't go below 0 when few pairs and subtraction term not accurate *)
npairs0noqed[rhob_,T_]:=Max[-ne[rhob]+neplus[myetae[rhob,T],T,pairsnumintprec]+neminus[myetae[rhob,T],T,pairsnumintprec],0]; 
npairs0noqedtrue[rhob_,T_]:=Max[-ne[rhob]+neplus[myetaetrue[rhob,T],T,pairsnumintprec]+neminus[myetaetrue[rhob,T],T,pairsnumintprec],0]; 

(* n_e in thermal equilibrium *)
negen[rhob_,T_,precarg_]:=Yefun[myetae[rhob,T],rhob,T,precarg]*nbprec[rhob];

(* now get p and u *)
Clear[Ppairs0noqed];
peplus[etae_?NumericQ,rhob_?NumericQ,T_?NumericQ]:=peplus[etae,rhob,T]=(getUPNpairsnoqedprefactor/3)*NIntegrate[x^4/Ee[x]*fplus[x,etae,T],{x,0,Infinity},Evaluate[pairsintprec[[1]]]];
(* AccuracyGoal->Infinity,PrecisionGoal->4*)
peminus[etae_?NumericQ,rhob_?NumericQ,T_?NumericQ]:=peminus[etae,rhob,T]=
(getUPNpairsnoqedprefactor/3)*NIntegrate[x^4/Ee[x]*fminus[x,etae,T],{x,0,Infinity},Evaluate[pairsintprec[[1]]]];
(* ,AccuracyGoal->Infinity,PrecisionGoal->4*)
(* subtract off non-pair producing part *)
(* and truncate so pairs don't go below 0 when few pairs and subtraction term not accurate *)
Ppairs0noqed[rhob_,T_]:=Max[peplus[myetae[rhob,T],rhob,T]+peminus[myetae[rhob,T],rhob,T]-Pe[rhob,T],0];
Ppairs0noqedtrue[rhob_,T_]:=Max[peplus[myetaetrue[rhob,T],rhob,T]+peminus[myetaetrue[rhob,T],rhob,T]-Pe[rhob,T],0];

Clear[Upairs0noqed];
ueplus[etae_?NumericQ,rhob_?NumericQ,T_?NumericQ]:=ueplus[etae,rhob,T]=getUPNpairsnoqedprefactor*NIntegrate[x^2*Ee[x]*fplus[x,etae,T],{x,0,Infinity},Evaluate[pairsintprec[[1]]]];
(* AccuracyGoal->Infinity,PrecisionGoal->4*)
ueminus[etae_?NumericQ,rhob_?NumericQ,T_?NumericQ]:=ueminus[etae,rhob,T]=getUPNpairsnoqedprefactor*NIntegrate[x^2*Ee[x]*fminus[x,etae,T],{x,0,Infinity},Evaluate[pairsintprec[[1]]]];
(* ,AccuracyGoal->Infinity,PrecisionGoal->4*)
(* subtract off non-pair producing part *)
(* and truncate so pairs don't go below 0 when few pairs and subtraction term not accurate *)
Upairs0noqed[rhob_,T_]:=Max[ueplus[myetae[rhob,T],rhob,T]+ueminus[myetae[rhob,T],rhob,T]-Ue[rhob,T],0];
Upairs0noqedtrue[rhob_,T_]:=Max[ueplus[myetaetrue[rhob,T],rhob,T]+ueminus[myetaetrue[rhob,T],rhob,T]-Ue[rhob,T],0];

Protect[myprecnoqed,mecsq,getUPNpairsnoqedprefactor,Yeprec,nbprec,Ee,Yefun,myetae,npairs0noqed,negen,Ppairs0noqed,Upairs0noqed,fplus,fminus];
(* return that no problems *)
1
];
(* KM02 with Jon correction and noted good approx even for non-degen *)
Clear[npp,QQ,mue,kbT,hbarc];
solsmue=Solve[npp*Exp[(QQ-mue)/(kbT)]==1/(3*Pi^2)*(mue/(hbarc))^3,mue];
mymue=solsmue[[3,1,2]];
tempmuefunc[kbT_,QQ_,hbarc_,npp_]=Evaluate[mymue];
muefunc[kbT_,QQ_,hbarc_,npp_]=Evaluate[tempmuefunc[kbT,QQ,hbarc,npp]];

ClearAll[getetae]; (* to clear old stored results *)
(* gives only VERY approximate order of magnitude result.  Can be off near boundary of \eta=1 *)
getetae[Ye0_,Yenum0_,rhob_,T_,myprec0_]:=getetae[Ye0,Yenum0,rhob,T,myprec0]=Module[
{foo,QQ,mue,etae,npp,kbT},
QQ=(mn-mp)*c^2;
(*QQ=0; *)(* bad estimate *)
npp=rhob/mp;
kbT=kb*T;
mue=muefunc[kbT,QQ,hbar*c,npp];
etae=mue/(kbT);
If[etae<QQ/(kbT),etae=0;];
(* return *)
SetPrecision[etae,lowestprec]
];
(* see if nucleons are degenerate assuming beta-equilibrium *)
ClearAll[Yebeta];
Yebeta[rhob_,T_,etae_]:=Module[
{foo,QQ,kbT,QQtilde,nponn,Yebeta},
QQ=(mn-mp)*c^2;
kbT=kb*T;
QQtilde=QQ/kbT;
nponn=Exp[QQtilde-etae];
(* limit to 1/2 *)
Yebeta=Min[1/(1+1/nponn),1/2];
(* return *)
Yebeta
];

(* find closest solution in list to x0 for list[[ii,2]] and does linear interpolation to get result of list[[ii,1]]\approx x0 *)
findelement[x0_,list_]:=Module[{ii,dist,dist0,whichii,avgpoint,numele,intercept,slope},
numele=Dimensions[list][[1]];
If[numele==1,
dist=0;
whichii=1;
avgpoint=list[[1,1]];
];
If[numele>1,
(* find element *)
dist0=10^(100);
For[ii=1,ii<=numele,
dist=Abs[x0-list[[ii,2]]];
If[dist<dist0,dist0=dist;whichii=ii;];
(*Print["ii=",ii," dist=",dist," whichii=",whichii];*)
ii++;
];
(* interpolate to get better root *)
If[whichii!=1,
If[whichii==numele||list[[whichii,2]]>x0 && list[[whichii-1,2]]<x0 ||list[[whichii,2]]<x0 && list[[whichii-1,2]]>x0 ,
slope=(list[[whichii,2]]-list[[whichii-1,2]])/(list[[whichii,1]]-list[[whichii-1,1]]);
intercept=list[[whichii,2]];
avgpoint=(x0-intercept)/slope+list[[whichii,1]];
];
];
If[whichii!=numele,
If[whichii==1||list[[whichii,2]]>x0 && list[[whichii+1,2]]<x0 ||list[[whichii,2]]<x0 && list[[whichii+1,2]]>x0 ,
slope=(list[[whichii,2]]-list[[whichii+1,2]])/(list[[whichii,1]]-list[[whichii+1,1]]);
intercept=list[[whichii,2]];
avgpoint=(x0-intercept)/slope+list[[whichii,1]];
];
];
];
(*avgpoint=list[[whichii,1]];*)
(* return *)
{dist0,whichii,avgpoint}
];
MakeYelist[Yenum_,rhob_,T_,leta0_,leta1_,num_]:=Module[
{foo,leta,yeresult},
(*
p1=LogPlot[Ye[10^leta,rhob,T],{leta,leta0,leta1},PlotPoints->5*num/300];
solslist=p1[[1,1,3,2,1]];
(* didn't find solution, so try larger range *)
If[Dimensions[p1[[1]]][[1]]==0||Dimensions[p1[[1,1]]][[1]]==0||solslist[[1,2]]>lYenum,
p1=LogPlot[Ye[10^leta,rhob,T],{leta,-25,4},PlotPoints->5];
solslist=p1[[1,1,3,2,1]];
];
*)
leta=Table[leta0+(leta1-leta0)*ii/(num-1),{ii,0,num-1}];

(* compute and check for affect of precision until get result *)
yeresult[eta_,precarg_]:=Module[{lowestprec0,ye},
ye=Yefun[eta,rhob,T,precarg];
If[yeresult<=10^(-50),lowestprec0=lowestprec;lowestprec=lowestprec0+10;ye=Yefun[eta,rhob,T,precarg];lowestprec=lowestprec0;];
If[yeresult<=10^(-50),lowestprec0=lowestprec;lowestprec=lowestprec0+20;ye=Yefun[eta,rhob,T,precarg];lowestprec=lowestprec0;];
If[yeresult<=10^(-50),lowestprec0=lowestprec;lowestprec=lowestprec0+30;ye=Yefun[eta,rhob,T,precarg];lowestprec=lowestprec0;];
(* return *)
ye
];
Yetable=Table[{leta[[ii]],Log[10,yeresult[10^leta[[ii]],pairsnumintprecyefun]]},{ii,1,num}];
(* return *)
Yetable
];
ClearAll[gensols];
gensols[Yenum_,rhob_,T_]:=gensols[Yenum,rhob,T]=Module[
{foo,leta,lYenum,yelist,lowestprec0},
lYenum=Log[10,Yenum];

lowestprec0=lowestprec;
lowestprec=10;
yelist=MakeYelist[Yenum,rhob,T,-4,3,100];

If[yelist[[1,2]]>lYenum,
Print["Yebad30=",yelist[[1,2]]];
lowestprec=30;
yelist=MakeYelist[Yenum,rhob,T,-25,-3.5,100];
];
If[yelist[[1,2]]>lYenum,
(* if gets here, then just assume user will set \etae to 0 or FindRoot will be ok with that *)
yelist={{-30,lYenum}};
];
lowestprec=lowestprec0;
(* return *)
yelist
];

ClearAll[getetaeslow]; (* to clear old stored results *)
getetaeslow[Ye0_,Yenum0_,rhob_,T_,myprec0_]:=getetaeslow[Ye0,Yenum0,rhob,T,myprec0]=Module[
{foo,Ye=Ye0,Yenum=Yenum0,myprec=myprec0,etae,myetae0,eqdiff,solsetae0,error0,etae0,solsetae,error,ii,numetae,randometae,etae0list,p1,solslist,letaguess,etaguess,lyenum},

Print["inside getetae=",myprec, " ",myprec0];
solsetae={etae->1};
eqdiff[etaevar_?NumericQ,rhob2_?NumericQ,T2_?NumericQ]:=(Yenum-Ye[etaevar,rhob2,T2,pairsnumintprecetae])/Yenum;
(* random error *)
error=10^(100);

(* find good guess *)
Print["Before gensols"];
(* generates log10 of Yefun *)
solslist=gensols[Yenum,rhob,T];
Print["Before findelement"];
lyenum=Log[10,Yenum];
letaguess=findelement[lyenum,solslist][[3]];
etaguess=10^letaguess;

(*
(*etae0list={10^(-15),10^(-10),10^(-5),10^(-1),10^(0),10^(1),10^(2),10^(3)};*)
etae0list={10^(-15),10^(-5),10^(-2),10^(-1),10^(1),10^(3)};
etae0list=SetPrecision[etae0list,lowestprec];
numetae=Dimensions[etae0list][[1]];
*)

etae0list={etaguess};
Print["etaguess=",etaguess];
numetae=1;

For[ii=1,ii<=numetae,
etae0=etae0list[[ii]]; (* pick *)
(* compute *)
(* CAREFUL: Using high WorkingPrecision can lead to FindRoot offsetting indep's by too small a value to show up as new function value *)
solsetae0=FindRoot[eqdiff[etaevar,rhob,T]==0,{etaevar,etae0},WorkingPrecision->myprec];
myetae0=solsetae0[[1,2]];
error0=Abs[eqdiff[myetae0,rhob,T]];
If[myetae0>0&&error0<error,solsetae=solsetae0;error=error0;];If[doprintdebug==1,Print["etae0=",solsetae0[[1,2]]];Print[error0];];
(* iterate to next or stop if error small enough that believe the result *)
RELTOL=10^(-6);
If[error<RELTOL,ii=numetae+1;,ii++;];
];
If[doprintdebug==1,Print["Finalsoletae"];Print[solsetae[[1,2]]];Print["Finalerror"];Print[error];];
(* return value itself *)
SetPrecision[solsetae[[1,2]],lowestprec]
];


getQneutrino:=Module[
{foo},
Unprotect[Qnucapnondeg,Qnucapdeg,Qnucap,Qnupair,Qnubrem,Qnuplasmon,Qnu0,Qnucapnondegfactor,Qnucapdegfactor,Qnupairfactor,Qnubremfactor,Qnuplasmonfactor,gammaplasmon];
Clear[Qnucapnondeg,Qnucapdeg,Qnucap,Qnupair,Qnubrem,Qnuplasmon,Qnu0,Qnupairfactor,Qnubremfactor,Qnuplasmonfactor,gammaplasmon];

Unprotect[Ypp,Ynn,alphaa,sinTwsq,CVe,Csp,Csn,sigmanuN,sigma0nu,sigma0prime,sigmanueCA,sigmanue,taunusca,dtaunuscads,Hnusca,unu0,nnu0,Fnu0,nnu,sigmacap,sigmabrem,sigmapair,sigmaplasmon,taunuabs,dtaunuabsds,Hnuabs,taunutot,damptaunu,Unu,nnutrue,Pnu,damptaunu2,Fnu,Qnu,Unue,nnuetrue,Pnue,Fnue,Qnue,massbfree,gammabfreeeff,Ebfreeeff,pbfreeeff,pneutrino,dpneutrinoeff,xpneutrinoeff,scatterfactor3,nbfreeeff,nbfreeinteff,Eeeff3,peeff3,dpneutrinoeff2,xpneutrinoeff2,scatterfactor4,neeff2,neinteff2,npairseff2];
Clear[Ypp,Ynn,alphaa,sinTwsq,CVe,Csp,Csn,sigmanuN,sigma0nu,sigma0prime,sigmanueCA,sigmanue,taunusca,dtaunuscads,Hnusca,unu0,nnu0,Fnu0,nnu,sigmacap,sigmabrem,sigmapair,sigmaplasmon,taunuabs,dtaunuabsds,Hnuabs,taunutot,damptaunu,Unu,nnutrue,Pnu,damptaunu2,Fnu,Qnu,Unue,nnuetrue,Pnue,Fnue,Qnue,massbfree,gammabfreeeff,Ebfreeeff,pbfreeeff,pneutrino,dpneutrinoeff,xpneutrinoeff,scatterfactor3,nbfreeeff,nbfreeinteff,Eeeff3,peeff3,dpneutrinoeff2,xpneutrinoeff2,scatterfactor4,neeff2,neinteff2,npairseff2];

Qnucapnondegfactor=SetPrecision[(92/10)*10^(33),lowestprec];
Qnucapnondeg[rhob_,T_,bgauss_,npairs_]:=Qnucapnondegfactor*T11[T]^6*(rho10[rhob]*Xnuc[rhob,T])*(damptaupairs[rhob,T,bgauss,npairs]);
Qnucapdegfactor=SetPrecision[(11/10)*10^(31),lowestprec];
Qnucapdeg[rhob_,T_,bgauss_,npairs_]:=Qnucapdegfactor*myetae[rhob,T]^9*T11[T]^9*(damptaupairs[rhob,T,bgauss,npairs]);
(* interpolate using etae up to 1 *)
Qnudegenfactor[rhob_,T_]:=Min[myetae[rhob,T],1];
Qnucap[rhob_,T_,bgauss_,npairs_]:=Qnudegenfactor[rhob,T]*Qnucapdeg[rhob,T,bgauss,npairs]+(1-Qnudegenfactor[rhob,T])*Qnucapnondeg[rhob,T,bgauss,npairs];

Qnupairfactor=SetPrecision[(48/10)*10^(33),lowestprec];
Qnupair[rhob_,T_,bgauss_,npairs_]:=Qnupairfactor*T11[T]^9*(damptaupairs[rhob,T,bgauss,npairs])^2;

Qnubremfactor=SetPrecision[(3/2)*10^(33),lowestprec];
Qnubrem[rhob_,T_,bgauss_,npairs_]:=Qnubremfactor*T11[T]^(55/10)*(Xnuc[rhob,T]*rho13[rhob])^2;

Qnuplasmonfactor=SetPrecision[(3/2)*10^(32),lowestprec];
(* limit gammap so don't get underflow *)
gammaplasmon[rhob_,T_]:=Max[(5565/1000)*10^(-2)*((Pi^2+3*myetae[rhob,T]^2)/3)^(1/2),10^(-5)];
Qnuplasmon[rhob_,T_,bgauss_,npairs_]:=Qnuplasmonfactor*T11[T]^9*gammaplasmon[rhob,T]^6*Exp[-gammaplasmon[rhob,T]]*(1+gammaplasmon[rhob,T])*(2+gammaplasmon[rhob,T]^2/(1+gammaplasmon[rhob,T]))*(damptaurad[rhob,T,bgauss,npairs]*damptaupairs[rhob,T,bgauss,npairs]);

(* total optically thin energy density rate *)
Qnu0[rhob_,T_,bgauss_,npairs_]:=Qnucap[rhob,T,bgauss,npairs]+Qnupair[T,bgauss,npairs]+Qnubrem[rhob,T,bgauss,npairs]+Qnuplasmon[rhob,T,bgauss,npairs];


(* optical depth effects *)
nbfree[rhob_,T_]:=Xnuc[rhob,T]*nb[rhob];
(* below integral assumes T holds throughout jet and that most of integral-density is outside layers.  Good approx unless Aum\sim L/\delta *)
nbfreeint[T_,x_]:=(Xnuc[rhobingoing/mb,T]*nbint[x]);

(* effective scatters for baryons as bath *)
massbfree[rhob_,T_]:=mb*(Xnuc[rhob,T]+(1-Xnuc[rhob,T])*4);
(* assume baryons always non-rel *)
gammabfreeeff[rhob_,T_]:=1+(3/2)*(kb*T)/(massbfree[rhob,T]*c^2);
Ebfreeeff[rhob_,T_]:=gammabfreeeff[rhob,T]*massbfree[rhob,T]*c^2;
pbfreeeff[rhob_,T_]:=Sqrt[Ebfreeeff[rhob,T]^2/c^2-massbfree[rhob,T]^2*c^2]; (* pbfreeeff = gammabfreeeff2*mbfree*vbfree *)
pneutrino[T_]:=(3*kb*T)/c; (* 4/3 thermal particle *)
dpneutrinoeff[rhob_,T_,bgauss_,npairs_]:=Min[pbfreeeff[rhob,T],pneutrino[T]];
xpneutrinoeff[rhob_,T_,bgauss_,npairs_]:=(dpneutrinoeff[rhob,T,bgauss,npairs]/pneutrino[T]);
scatterfactor3[rhob_,T_,bgauss_,npairs_]:=Min[xpneutrinoeff[rhob,T,bgauss,npairs]^2,xpneutrinoeff[rhob,T,bgauss,npairs]];
nbfreeeff[rhob_,T_,bgauss_,npairs_]:=nbfree[rhob,T]*scatterfactor3[rhob,T,bgauss,npairs];
nbfreeinteff[rhob_,T_,bgauss_,npairs_]:=nbfreeint[T,Rjetmod]*scatterfactor3[rhob,T,bgauss,npairs];

(* effective scatters for electrons and pairs as bath *)
Eeeff3[rhob_,T_]:=me*c^2+Ue[rhob,T]/ne[rhob]; (* effective particle energy that changes around me c^2 *)
peeff3[rhob_,T_]:=Sqrt[Eeeff3[rhob,T]^2/c^2-me^2*c^2]; (* peeff3 = gammaeeff3*me*ve3 *)
dpneutrinoeff2[rhob_,T_,bgauss_,npairs_]:=Min[peeff3[rhob,T],pneutrino[T]];
xpneutrinoeff2[rhob_,T_,bgauss_,npairs_]:=(dpneutrinoeff2[rhob,T,bgauss,npairs]/pneutrino[T]);
scatterfactor4[rhob_,T_,bgauss_,npairs_]:=Min[xpneutrinoeff2[rhob,T,bgauss,npairs]^2,xpneutrinoeff2[rhob,T,bgauss,npairs]];
neeff2[rhob_,T_,bgauss_,npairs_]:=ne[rhob]*scatterfactor4[rhob,T,bgauss,npairs];
neinteff2[rhob_,T_,bgauss_,npairs_]:=neint[Rjetmod]*scatterfactor4[rhob,T,bgauss,npairs];
npairseff2[rhob_,T_,bgauss_,npairs_]:=(npairs)*scatterfactor4[rhob,T,bgauss,npairs];

(* scattering *)
Ypp=Ye;
Ynn=1-Ypp;
alphaa=125/100;
sinTwsq=23/100;
CVe=1/2+2*sinTwsq;
Csp=(4*(CVe-1)^2+5*alphaa^2)/24;
Csn=(1+5*alphaa^2)/24;
(* nbfreeeff10 not used *)
nbfreeeff10[rhob_,T_,bgauss_,npairs_]:=nbfreeeff[rhob, T, bgauss, npairs]/10^(10);
sigmanuN[rhob_,T_]:=((77/10)*10^(-7)*mb/10^(10))*(Csp*Ypp+Csn*Ynn)*T11[T]^2;
sigma0nu=(17/10)*10^(-44);
sigma0prime=(3/2)*sigma0nu;
sigmanueCA[CA_,rhob_,T_,bgauss_,npairs_]:=(sigma0prime*(1+myetae[rhob,T]/4)*((CVe+CA)^2+(1/3)*(CVe-CA)^2)*(kb*T/(me*c^2))^2);
(* only take scattering for normal electron neutrinos *)
sigmanue[rhob_,T_,bgauss_,npairs_]:=sigmanueCA[1/2,rhob,T,bgauss,npairs];
taunusca[rhob_,T_,bgauss_,npairs_]:=sigmanuN[rhob,T]*nbfreeinteff[rhob, T, bgauss,npairs]+sigmanue[rhob,T,bgauss,npairs]*(npairseff2[rhob,T,bgauss,npairs]*Nscalayers*Lpmodnum+neinteff2[rhob,T,bgauss,npairs]);
(* below is just an approximation -- I don't know how it should be constrained unlike absorption *)
dtaunuscads[rhob_,T_,bgauss_,npairs_]:=sigmanuN[rhob,T]*(nbfreeinteff[rhob, T, bgauss,npairs]/Rjetmod)+sigmanue[rhob,T,bgauss,npairs]*(npairseff2[rhob, T, bgauss, npairs]*Nscalayers+neinteff2[rhob,T,bgauss,npairs]/Rjetmod);
Hnusca[rhob_,T_,bgauss_,npairs_]:=(taunusca[rhob,T,bgauss,npairs]/dtaunuscads[rhob,T,bgauss,npairs])//.consts;

(* absorption *)
(* don't use "effective" density of scatterers *)
unu0[T_]:=(7/8)*arad*T^4;
nnu0[T_]:=(1/3)*(arad/kb)*T^3;
Fnu0[T_]:=c*unu0[T];
(* APPROXIMATION: below is rough approximation only roughly valid when neurtrinos are optically thick.  Only makes opacity larger than would be *)
(* This is done to avoid having to solve the nnu equation with T and npairs *)
(*nnu[rhob_,T_,bgauss_,npairs_]:=nrad[rhob,T,bgauss,npairs];*)
(* By setting nnu = npairs, always have effective scattering number instead of nnu of ineffective low-enery neutrinos -- although neutrinos tend to always have energy m_e c^2 + k_b T, so doesn't matter *)
nnu[rhob_,T_,bgauss_,npairs_]:=10^(-50)+npairs*Min[1,taunusca[rhob,T,bgauss,npairs]];
(* 1/nb below is approx since really involves p and n in separate processes,but Y_e=1/2, so ok *)
sigmacap[rhob_,T_,bgauss_,npairs_]:=(1/nbfree[rhob, T])*Qnucap[rhob,T,bgauss,npairs]/(c*unu0[T]);
sigmabrem[rhob_,T_,bgauss_,npairs_]:=(1/nbfree[rhob, T])*Qnubrem[rhob,T,bgauss,npairs]/(c*unu0[T]);
(* absorber is neutrino, not baryon or pairs *)
sigmapair[rhob_,T_,bgauss_,npairs_]:=(1/(nnu[rhob,T,bgauss,npairs]))*Qnupair[rhob,T,bgauss,npairs]/(c*unu0[T]);
sigmaplasmon[rhob_,T_,bgauss_,npairs_]:=(1/(nnu[rhob,T,bgauss,npairs]))*Qnuplasmon[rhob,T,bgauss,npairs]/(c*unu0[T]);
taunuabs[rhob_,T_,bgauss_,npairs_]:=(sigmacap[rhob,T,bgauss,npairs]+sigmabrem[rhob,T,bgauss,npairs])*(nbfreeint[ T,Rjetmod]) + (sigmapair[rhob,T,bgauss,npairs]+sigmaplasmon[rhob,T,bgauss,npairs])*(nnu[rhob,T,bgauss,npairs]*Nabslayers*Lpmodnum);
(* below is equivalent to \Sum Q0 / (c u0nu)  as is must be to work in the optically thin limit *)
dtaunuabsds[rhob_,T_,bgauss_,npairs_]:=(nbfree[rhob, T]*sigmacap[rhob,T,bgauss,npairs]+nbfree[rhob, T]*sigmabrem[rhob,T,bgauss,npairs]+nnu[rhob,T,bgauss,npairs]*sigmapair[rhob,T,bgauss,npairs]+nnu[rhob,T,bgauss,npairs]*sigmaplasmon[rhob,T,bgauss,npairs]);
Hnuabs[rhob_,T_,bgauss_,npairs_]:=(taunuabs[rhob,T,bgauss,npairs]/dtaunuabsds[rhob,T,bgauss,npairs])//.consts;

(* total *)
taunutot[rhob_,T_,bgauss_,npairs_]:=(taunuabs[rhob,T,bgauss,npairs]+taunusca[rhob,T,bgauss,npairs]);

(* densities *)
damptaunu[rhob_,T_,bgauss_,npairs_]:=(3*taunutot[rhob,T,bgauss,npairs]+2*Sqrt[3])/(3*taunutot[rhob,T,bgauss,npairs]+2*Sqrt[3]+2/taunuabs[rhob,T,bgauss,npairs]);
Unue[rhob_,T_,bgauss_,npairs_]:=unu0[T]*damptaunu[rhob,T,bgauss,npairs];
nnuetrue[rhob_,T_,bgauss_,npairs_]:=nnu0[T]*damptaunu[rhob,T,bgauss,npairs];
Pnue[rhob_,T_,bgauss_,npairs_]:=Unu[rhob,T,bgauss,npairs]/3;

(* fluxes *)
damptaunu2[rhob_,T_,bgauss_,npairs_]:=(1/3)/(taunutot[rhob,T,bgauss,npairs]/2+1/Sqrt[3]+1/(3*taunuabs[rhob,T,bgauss,npairs]));
Fnue[rhob_,T_,bgauss_,npairs_]:=Fnu0[T]*damptaunu2[rhob,T,bgauss,npairs];
Qnue[rhob_,T_,bgauss_,npairs_]:=Fnu[rhob,T,bgauss,npairs]/Hnuabs[rhob,T,bgauss,npairs];


(* hack for mu and tau neutrinos *)
Unu[rhob_,T_,bgauss_,npairs_]:=Unue[rhob,T,bgauss,npairs]*(1+damptaunu[rhob,T,bgauss,npairs]*2);
nnutrue[rhob_,T_,bgauss_,npairs_]:=nnuetrue[rhob,T,bgauss,npairs]*(1+damptaunu[rhob,T,bgauss,npairs]*2);
Pnu[rhob_,T_,bgauss_,npairs_]:=Pnue[rhob,T,bgauss,npairs]*(1+damptaunu[rhob,T,bgauss,npairs]*2);

Fnu[rhob_,T_,bgauss_,npairs_]:=Fnue[rhob,T,bgauss,npairs]*(1+damptaunu2[rhob,T,bgauss,npairs]*2);
Qnu[rhob_,T_,bgauss_,npairs_]:=Module[{qnue,damp,result},
qnue=Qnue[rhob,T,bgauss,npairs];
damp=damptaunu2[rhob,T,bgauss,npairs];
result=qnue*(1+damp*2);
If[doprintdebug==1,Print["Qnu: ",qnue," ",damp," ",result];];
(* return *)
result
];

(* SUPERDEBUG *)
(*
Unu[rhob_,T_,bgauss_,npairs_]:=0;
nnutrue[rhob_,T_,bgauss_,npairs_]:=0;
Pnu[rhob_,T_,bgauss_,npairs_]:=0;
Qnu[rhob_,T_,bgauss_,npairs_]:=0;
*)


Protect[Qnucapnondeg,Qnucapdeg,Qnucap,Qnupair,Qnubrem,Qnuplasmon,Qnu0,Qnucapnondegfactor,Qnucapdegfactor,Qnupairfactor,Qnubremfactor,Qnuplasmonfactor,gammaplasmon];

Protect[Ypp,Ynn,alphaa,sinTwsq,CVe,Csp,Csn,sigmanuN,sigma0nu,sigma0prime,sigmanueCA,sigmanue,taunusca,dtaunuscads,Hnusca,unu0,nnu0,Fnu0,nnu,sigmacap,sigmabrem,sigmapair,sigmaplasmon,taunuabs,dtaunuabsds,Hnuabs,taunutot,damptaunu,Unu,nnutrue,Pnu,damptaunu2,Fnu,Qnu,Unue,nnuetrue,Pnue,Fnue,Qnue,massbfree,gammabfreeeff,Ebfreeeff,pbfreeeff,pneutrino,dpneutrinoeff,xpneutrinoeff,scatterfactor3,nbfreeeff,nbfreeinteff,Eeeff3,peeff3,dpneutrinoeff2,xpneutrinoeff2,scatterfactor4,neeff2,neinteff2,npairseff2];
];


getsigmaphoton:=Module[
{foo},
getsigmaff;
getsigmasynch;

Unprotect[Theta2,numminus,numplus,Rpairs2gamma,sigmapairs2gammanumber,gammapairs,Eepairs,Qpairs2gamma,sigmapairs2gamma];

Theta2[T_]:=kb*T/(me*c^2);
numplus[rhob_,npairs_]:=(ne[rhob]+npairs-ne[rhob])/2;
numminus[rhob_,npairs_]:=(ne[rhob]+npairs+ne[rhob])/2;
(* original paper gives rate for npairs/2 and we want for npairs, so multiply by 2 *)
Rpairs2gamma[rhob_,T_,bgauss_,npairs_]:=2*(3/8)*sigmat*c*numplus[rhob,npairs]*numminus[rhob,npairs]*(1+2*Theta2[T]^2/(Log[1.12*Theta2[T]+1.3]))^(-1);

sigmapairs2gammanumber[rhob_,T_,bgauss_,npairs_]:=Rpairs2gamma[rhob,T,bgauss,npairs]/((10^(-30)+npairs)*c*nrad0[T]);

(* original rate is for rate of creating nplus = npairs/2 and already modified it to be for each e^+ e^-, so do NOT multiply again by 2 *)
(* energy is in mass + kinetic energy *)
Eepairs[rhob_,T_]:=me*c^2+Ue[rhob,T]/ne[rhob];
Qpairs2gamma[rhob_,T_,bgauss_,npairs_]:=Eepairs[rhob,T]*Rpairs2gamma[rhob,T,bgauss,npairs];

sigmapairs2gamma[rhob_,T_,bgauss_,npairs_]:=Qpairs2gamma[rhob,T,bgauss,npairs]/((10^(-30)+npairs)*c*urad0[T]);


Protect[Theta2,numminus,numplus,Rpairs2gamma,sigmapairs2gammanumber,gammapairs,Eepairs,Qpairs2gamma,sigmapairs2gamma];

];
getsigmaff:=Module[
{foo},
Unprotect[Z,netot,Q1ff,sigmaff0,factorsigmaff,sigmaff,Q0ff];

Z=1; (* protons *)
netot[rhob_,npairs_]:= ne[rhob] + npairs; (* unsure if total or just ne or something more complicated *)
Q1fffactor1=SetPrecision[1.4*10^(-27),lowestprec];
Q1fffactor2=SetPrecision[4.4*10^(-10),lowestprec];
(* was using np[rhob], but then didn't account for pair collisions *)
(* only had one 1+QT factor, but not squared for pairs *)
Q1ff[rhob_,T_,npairs_]:=Q1fffactor1*T^(1/2)*Z^2*netot[rhob,npairs]^2*(1+Q1fffactor2*T)^2;
(* divide out emitting particles so sigma is per particle density per length so that when integrate over density of emitting particles along length get back optical depth *)
sigmaff0[rhob_,T_,npairs_]:=Q1ff[rhob,T,npairs]/(netot[rhob,npairs]*c*urad0[T]);
(*nbsigmaff0[rhob_,T_,npairs_]:=Q1ff[rhob,T,npairs]/(c*urad0[T]);*)
(*sigmaff0[rhob_,T_,npairs_]:=nbsigmaff0[rhob,T,npairs]/nb[rhob];*)
factorsigmaff[T_,bgauss_]:=10^(-30)+(Sqrt[5]*Pi*me*c^2*kb*T)/(hbar*c*q*bgauss);
sigmaff[rhob_,T_,bgauss_,npairs_]:=sigmaff0[rhob,T,npairs]/(1 + (factorsigmaff[T,bgauss])^(-2) );
(* force not to be direct function of T so can easily solve for T per iteration *)
(*localTrad=T//.solsTrad;*)
(* don't allow to go below 10^4 K for this term since makes no sense for free-free *)
(*localsolsTrad={T->10^4+localTrad};*)
(*nbsigmaff=(nb*sigmaff)//.localsolsTrad;*)
(* try including Temperature (T) dependence *)
(*nbsigmaff[rhob_,T_,bgauss_,npairs_]:=nb[rhob]*sigmaff[rhob,T+10^4,bgauss,npairs];*)
(* so Kirchhoff's law defines Q0ff through nb*sigmaff = Q0ff/(c*urad0) , but not used *)
(* Q0ff not used except perhaps as diagnostic *)
Q0ff[rhob_,T_,bgauss_,npairs_]:=sigmaff[rhob,T,bgauss,npairs]*(netot[rhob,npairs]*c*urad0[T]); 

Protect[Z,netot,Q1ff,sigmaff0,factorsigmaff,sigmaff,Q0ff];
];


(* see plancklaw.nb *)
Unprotect[betax,sinpart,tempresultclass,Thetadep,resultclass];

Clear[betax,sinpart,tempresultclass,resultclass];
betax[gamma_]:=Sqrt[1-1/gamma^2];
(* Sinth is to mock what happens after correct integration, but still this doesn't account for pitch angles correctly.  Right? *)
sinpart=1;
(* sinpart=Integrate[Sin[th],{th,0,Pi}] *)
tempresultclass[Thetax_]=Module[{gammax},Evaluate[sinpart*Integrate[gammax^2*betax[gammax]*(gammax^2-1)*Exp[-gammax/Thetax],{gammax,1,Infinity},Assumptions->Re[Thetax]>0]]];
Clear[Thetadep];
Thetadep[T_]:=10^(-6)+(kb*T)/(me*c^2);
resultclass[T_]:=Evaluate[tempresultclass[Thetadep[T]]];

Protect[betax,sinpart,tempresultclass,Thetadep,resultclass];

getsigmasynch:=Module[
{foo},
Unprotect[Bc,Brat,beta,fgamfullfree,fgamfullfixedT,Q0synch,Q1synch,sigmasynch0,factorsigmasynch,sigmasynch,Q0synch];

Bc=(me^2*c^3)/(q*hbar);
Brat[bgauss_]:=bgauss/Bc;
(* gamma^2 = 1/(1-beta^2) *)
(* 1-beta^2 = 1/gamma^2 *)
(* beta^2 = 1-1/gamma^2 *)
(* classical = Brat <<1 and omega <<gamma *)
beta[gamma_]:=Sqrt[1-1/gamma^2];
(* below Exp is only part that mixes gamma and temperature and needs to be integrated to constant for simplicity of integration so root finding for temperature is simple *)
fgamfullfree[T_]:=1/(Thetadep[T]*BesselK[2,1/Thetadep[T]]);
fgamfullfixedT[gamma_,T_]:=gamma^2*beta[gamma]*Exp[-gamma/Thetadep[T]];
(* stupid to go below 10^4 K *)
(*
fgamfullfreeforint=(fgamfullfree)/(fgamfullfree//.solsTrad)*(Thetadep);
fgamfullfixedTforint=(fgamfullfixedT)*(fgamfullfree//.solsTrad)/(Thetavalue);
*)
(* get Q0synch *)
getclassSynch;
getclassSynchnew; (* alternate version *)
getQEDSynch;
getqedSynchultrarel ; (* ultra rel QED version from Baring 1998, eq 6 *)
getqedSynchultrarelnew; (* ultra rel QED version from Baring 1998, eq 6 but using eq 8a *)

(* use supression technique. Q0synchnoqednew has correct integrals and all terms  *)
Q1synch[rhob_,T_,bgauss_,npairs_]:=Q0synchnoqednew[rhob,T,bgauss,npairs];

(*
nbsigmasynch0[rhob_,T_,bgauss_,npairs_]:=Q1synch[rhob,T,bgauss,npairs]/(c*urad0[T]);
sigmasynch0[rhob_,T_,bgauss_,npairs_]:=nbsigmasynch0[rhob,T,bgauss,npairs]/nb[rhob];
*)
(* emission per particle density divided by c urad0 *)
sigmasynch0[rhob_,T_,bgauss_,npairs_]:=Q1synch[rhob,T,bgauss,npairs]/(netot[rhob,npairs]*c*urad0[T]);
(* Use supression factor for QED effects since QED calculations themselves are too slow or erroneous since far too wrong for given computer resources *)
(* see trying_qedscaling.nb *)
factorsigmasynch[T_,bgauss_]:=10^(-30)+(me*c^2)^3/(Sqrt[3]*Pi*kb*T*hbar*c*q*bgauss);
sigmasynch[rhob_,T_,bgauss_,npairs_]:=sigmasynch0[rhob,T,bgauss,npairs]/(1 + (factorsigmasynch[T,bgauss])^(-2/3) )^(2);
(*nbsigmasynch[rhob_,T_,bgauss_,npairs_]:=nb[rhob]*sigmasynch[rhob,T+10^4,bgauss,npairs];*)
(* so Kirchhoff's law defines Q0synch through nb*sigmasynch = Q0synch/(c*urad0) , but not used *)
(* Q0synch not used except perhaps as diagnostic *)
Q0synch[rhob_,T_,bgauss_,npairs_]:=netot[rhob,npairs]*sigmasynch[rhob,T+10^4,bgauss,npairs]*(c*urad0[T]); 

(* Full QED fails to integrate properly most of the time, it's too slow, and not really dealing with pitch properly *)
(* Q0synch[rhob_,T_,bgauss_,npairs_]:=If[Evaluate[Brat[bgauss]]<1/100,Q0synchnoqed[rhob,T,bgauss,npairs],Q0synchqed[rhob,T,bgauss,npairs]];*)
(*nbsigmasynch[rhob_,T_,bgauss_,npairs_]:=Q0synch[rhob,T,bgauss,npairs]/(c*urad0[T]);*)

Protect[Bc,Brat,beta,fgamfullfree,fgamfullfixedT,Q0synch,Q1synch,sigmasynch0,factorsigmasynch,sigmasynch,Q0synch];
];


(* see plancklaw.nb -- but not dealing with pitch angle properly *)
getclassSynch:=Module[
{foo},
(* Not protected since want to store results: Q0synchnoqed *)
Unprotect[myprecsynch,jgeo,rawcoef,jclass0raw,jclass0,jclassnew,grand,grandit,jclassthermalneworig,netot2,jclassthermalnew];
(* Stored: Q0synchnoqed *)
ClearAll[Q0synchnoqed]; (* purge any remembered versions in case change "Choice" below *)

(* Classical Relativistic Synchrotron *)
myprecsynch=lowestprec; (* 20 makes this too slow for iteration to get T,npairs *)
jgeo=SetPrecision[((1/(4*Pi))*(2*Pi*1)),myprecsynch];
rawcoef=SetPrecision[(2/3)*(q^2/(hbar*c))*(me*c^2)^2/hbar,myprecsynch];
jclass0raw[bgauss_]:=rawcoef*Brat[bgauss]^2;

jclass0[gamma_,bgauss_]:=jclass0raw[bgauss]*(gamma^2-1);
jclassnew[th_,gamma_,bgauss_]:=jgeo*jclass0[gamma,bgauss]/Sin[th];
grand[th_,gamma_,bgauss_]:=jclassnew[th,gamma*Sin[th],bgauss]; (* \gamma -> \gamma \sin\theta is for Lornetz boost *)
grandit[th_,gamma_,T_,bgauss_]:=grand[th,gamma,bgauss]*fgamfullfree[T]*fgamfullfixedT[gamma,T]; (* no Lorentz boost for distribution function itself *)

netot2[rhob_,npairs_]:=ne[rhob] + npairs;

(*jclassthermalneworig[rhob_?NumericQ,T_?NumericQ,bgauss_?NumericQ,npairs_?NumericQ]:=Module[{thetap,gammap},netot2[rhob,npairs]*NIntegrate[grandit[thetap,gammap,T,bgauss],{thetap,0,Pi},{gammap,1/Sin[thetap],Infinity},WorkingPrecision->myprecsynch, 
  Method -> "AdaptiveMonteCarlo", MaxPoints -> 10000]];*)

(* Use WorkingPrecision->15 (i.e. slowprec=15) below seems to be good enough for external FindRoot to work with WorkingPrecision of 30 *)
(* too small WorkingPrecision here and complains about convergence and takes long time as well *)
jclassthermalneworig[rhob_?NumericQ,T_?NumericQ,bgauss_?NumericQ,npairs_?NumericQ]:=Module[{thetap,gammap,result},result=netot2[rhob,npairs]*NIntegrate[grandit[thetap,gammap,T,bgauss],{thetap,0,Pi},{gammap,1/Sin[thetap],Infinity},WorkingPrecision->slowprec];
SetPrecision[result,lowestprec]
];


(* had to use montecarlo to get faster and accurate and more generally convergent answer, but requires more points *)
(* AccuracyGoal->myprecsynch *)
(*WorkingPrecision->myprecsynch]*)

(* below is approximation, to test if can converge with FindRoot[T] with T-dependent Q0synch *)
(* unsure if total or just ne or something more complicatd -- already defined above .. so used netot2 even though same definition *)
jclassthermalnew[rhob_,T_,bgauss_,npairs_]:=netot2[rhob,npairs]*fgamfullfree[T]*resultclass[T]*jclass0raw[bgauss];

(* SUPERDEBUG choose, but should choose jclassthermalneworig *)
(* Choice 1 *)
(* debug version *)
(*Q0synchnoqed[rhob_,T_,bgauss_,npairs_]:=Q0synchnoqed[rhob,T,bgauss,npairs]=Module[{foo},Print["nonqed=",T," ",npairs];jclassthermalnew[rhob,T,bgauss,npairs]];*)
(* normal version *)
(*Q0synchnoqed[rhob_,T_,bgauss_,npairs_]:=Q0synchnoqed[rhob,T,bgauss,npairs]=jclassthermalnew[rhob,T,bgauss,npairs];*)

(* Choice 2 *)
(* debug *)
(*Q0synchnoqed[rhob_,T_,bgauss_,npairs_]:=Q0synchnoqed[rhob,T,bgauss,npairs]=Module[{foo},Print["nonqedorig=",T," ",npairs];jclassthermalneworig[rhob,T,bgauss,npairs]];*)
(* normal version *)
Q0synchnoqed[rhob_,T_,bgauss_,npairs_]:=Q0synchnoqed[rhob,T,bgauss,npairs]=jclassthermalneworig[rhob,T,bgauss,npairs];

Protect[myprecsynch,jgeo,rawcoef,jclass0raw,jclass0,jclassnew,grand,grandit,jclassthermalneworig,netot2,jclassthermalnew];
];


(* see trying_nonqed _synch.nb  -- direct integration over omega-pre-integrated form to avoid having to repeat known result of integration over omega *)
(* also deals with pitch angle properly *)
(* all azimuthal angle stuff already integrated over *)
getclassSynchnew:=Module[
{foo},
(* Not protected since want to store results: Q0synchnoqednew *)
Unprotect[netot4,Thetadep2,beta2,fgamfullfree2,fgamfullfixedT2,jclassgen2];
(* Stored: Q0synchnoqednew *)
ClearAll[Q0synchnoqednew]; (* purge any remembered versions in case change "Choice" below *)

netot4[rhob_,npairs_]:=ne[rhob]+npairs;
Thetadep2[T_]:=(kb*T)/(me*c^2);
beta2[gamma_]:=Sqrt[1-1/gamma^2];
fgamfullfree2[T_]:=1/(Thetadep2[T]*BesselK[2,1/Thetadep2[T]]);
fgamfullfixedT2[gamma_,T_]:=gamma^2*beta2[gamma]*Exp[-gamma/Thetadep2[T]];
jclassgen2[gamma_,bgauss_]:=2*q^4*bgauss^2*(gamma^2-1)/(3*me^2*c^3);
pitchpart=Integrate[Sin[th]^3,{th,0,Pi}]; (* emissivity has Sin[thetap]^2 and then assume isotropic, so density weight is Sin[thetap]d\thetap *)
Pclassgen2[rhob_,T_,bgauss_,npairs_]:=Module[{omegap,gammap},netot4[rhob,npairs]*fgamfullfree2[T]*NIntegrate[pitchpart*fgamfullfixedT2[gammap,T]*jclassgen2[gammap,bgauss],{gammap,1,Infinity},Evaluate[synchintprec[[1]]]]];
(* ,PrecisionGoal->2,AccuracyGoal->Infinity*)


(* set precision to lowestprec so other processes don't use low precision to compute, which would sour their robustness *)
Q0synchnoqednew[rhob_?NumericQ,T_?NumericQ,bgauss_?NumericQ,npairs_?NumericQ]:=Q0synchnoqednew[rhob,T,bgauss,npairs]=Module[
{foo2},
(* return *)
SetPrecision[Pclassgen2[rhob,T,bgauss,npairs],lowestprec]
];

Protect[netot4,Thetadep2,beta2,fgamfullfree2,fgamfullfixedT2,jclassgen2];
];


(* too slow, use "new" version, given below, of this *)
(* see trying_qedscaling.nb *)
getqedSynchultrarel:=Module[
{foo},
(* Not protected since want to store results: Q0synchnoqednew *)
Unprotect[netot5,Thetadep3,beta3,fgamfullfree3,fgamfullfixedT3,jw,Pqedultrarel];
(* Stored: Q0synchqedultrarel *)
ClearAll[Q0synchqedultrarel]; (* purge any remembered versions in case change "Choice" below *)

netot5[rhob_,npairs_]:=ne[rhob]+npairs;

part1[y_?NumericQ]:=NIntegrate[BesselK[5/3,x],{x,y,Infinity}];
Bc=(me^2*c^3)/(q*hbar);
Brat[bgauss_]:=bgauss/Bc;
ygen[bgauss_?NumericQ,omega_?NumericQ,gamma_?NumericQ,al_?NumericQ]:=2/(3*Brat[bgauss]*Sin[al])*omega/(gamma*(gamma-omega));
part2[bgauss_,omega_,gamma_,al_]:=omega^2/(gamma*(gamma-omega))*BesselK[2/3,ygen[bgauss,omega,gamma,al]];
jw[bgauss_?NumericQ,omega_?NumericQ,gamma_?NumericQ,al_?NumericQ]:=(1/(Pi*Sqrt[3]))*q^2/(hbar*c)*(me*c^2)^2/hbar*omega/gamma^2*(part1[ygen[bgauss,omega,gamma,al]]+part2[bgauss,omega,gamma,al]);
Thetadep3[T_]:=(kb*T)/(me*c^2);
beta3[gamma_]:=Sqrt[1-1/gamma^2];
fgamfullfree3[T_]:=1/(Thetadep3[T]*BesselK[2,1/Thetadep3[T]]);
fgamfullfixedT3[gamma_?NumericQ,T_?NumericQ]:=gamma^2*beta3[gamma]*Exp[-gamma/Thetadep3[T]];
Pqedultrarel[rhob_,T_,bgauss_,npairs_]:=netot5[rhob,npairs]*fgamfullfree3[T]*NIntegrate[fgamfullfixedT3[gamma,T]*jw[bgauss,omega,gamma,al],{al,0,Pi},{omega,0,Infinity},{gamma,1+omega,Infinity}];

Q0synchqedultrarel[rhob_?NumericQ,T_?NumericQ,bgauss_?NumericQ,npairs_?NumericQ]:=Q0synchqedultrarel[rhob,T,bgauss,npairs]=Pqedultrarel[rhob,T,bgauss,npairs];

Protect[netot5,Thetadep3,beta3,fgamfullfree3,fgamfullfixedT3,jw,Pqedultrarel];
];





(* see trying_qedscaling.nb -- this version is efficient enough to get right answer with NIntegrate, unlike full integral over pitch angle *)
(* still quite slow, so only used this to extract suppression factor *)
getqedSynchultrarelnew:=Module[
{foo},
(* Not protected since want to store results: Q0synchnoqednew *)
Unprotect[netot6,Thetadep4,beta4,fgamfullfree4,fgamfullfixedT4,jgaom,Pqedultrarelother];
(* Stored: Q0synchqedultrarelother *)
ClearAll[Q0synchqedultrarelother]; (* purge any remembered versions in case change "Choice" below *)
ClearAll[ys,Wstuff1,Wstuff2,Wstuff,jgaom];

netot6[rhob_,npairs_]:=ne[rhob]+npairs;
Bc2=(me^2*c^3)/(q*hbar);
Brat2[bgauss_]:=bgauss/Bc2;
ys[bgauss_,omega_,gamma_]:=2/(3*Brat2[bgauss])*omega/(gamma*(gamma-omega));
Wstuff1[bg_,w_,ga_]:=WhittakerW[0,4/3,ys[bg,w,ga]]*WhittakerW[0,1/3,ys[bg,w,ga]]-WhittakerW[1/2,5/6,ys[bg,w,ga]]*WhittakerW[-1/2,5/6,ys[bg,w,ga]];
Wstuff2[bg_,w_,ga_]:=WhittakerW[0,1/3,ys[bg,w,ga]]^2+WhittakerW[1,1/3,ys[bg,w,ga]]*WhittakerW[-1,1/3,ys[bg,w,ga]];
Wstuff[bg_,w_,ga_]:=Wstuff1[bg,w,ga]+3*w*Brat2[bg]/4*Wstuff2[bg,w,ga];
jgaom[bgauss_,omega_,gamma_]:=(1/Sqrt[3])*q^2/(hbar*c)*(me*c^2)^2/hbar*(omega/gamma^2)*Wstuff[bgauss,omega,gamma];
Thetadep4[T_]:=(kb*T)/(me*c^2);
beta4[gamma_]:=Sqrt[1-1/gamma^2];
fgamfullfree4[T_]:=1/(Thetadep4[T]*BesselK[2,1/Thetadep4[T]]);
fgamfullfixedT4[gamma_?NumericQ,T_?NumericQ]:=gamma^2*beta4[gamma]*Exp[-gamma/Thetadep4[T]];
Pqedultrarelother[rhob_,T_,bgauss_,npairs_]:=netot6[rhob,npairs]*fgamfullfree4[T]*NIntegrate[fgamfullfixedT4[gamma,T]*jgaom[bgauss,omega,gamma],{omega,0,Infinity},{gamma,1+omega,Infinity}];
Q0synchqedultrarelother[rhob_,T_,bgauss_,npairs_]:=Q0synchqedultrarelother[rhob,T,bgauss,npairs]=Pqedultrarelother[rhob,T,bgauss,npairs];

Protect[netot6,Thetadep4,beta4,fgamfullfree4,fgamfullfixedT4,jgaom,Pqedultrarelother];
];





(* see plancklaw.nb *)
 (* go ahead and compute this since expensive and can be done analytically *)
(*
tempib1[x0_]=Module[{x},Simplify[Integrate[BesselK[5/3,x],{x,x0,Infinity}],{x0>0}]];
ib1[x0_]:=Evaluate[tempib1[x0]];
*)
(* actually, go ahead and do integral outside and copy/paste here so not slow each run of the gamma_jet _reconnection.nb file *)
(* too slow even for analytical  *)
(*ib1[x0_]:=(2^(2/3) Gamma[2/3] HypergeometricPFQ[{-(1/3)},{-(2/3),2/3},x0^2/4])/x0^(2/3)+(\[Pi] (-320+(81 2^(1/3) x0^(8/3) HypergeometricPFQ[{4/3},{7/3,8/3},x0^2/4])/Gamma[-(1/3)]))/(320 Sqrt[3]);*)
(* analytical stuff above too slow -- just use NIntegrate *)


(* NOTE: Due to catastrophic cancellation (not tried to avoid yet), the QED Synch calculation cannot be used for small Brat smaller than about Brat\sim 0.01.  Calculation is also kinda slow (faster than before with analytical IB1), so also reason to avoid unless QED effects matter *)
getQEDSynch:=Module[
{foo},
Unprotect[ib1,xi,IB1,sigma,chi,Dmu,B2,B3,Kstuff,jgen,fgamset,grandgennew0,fgamset,omegalow,omegahigh,gammalow,gammahigh,netot3,jgenthermalnew];
(* Stored: Q0synchqed,grandgennew *)
ClearAll[Q0synchqed,grandgennew];

(* QED Relativistic Synchrotron *)
ib1[x0_?NumericQ]:=Module[{x},NIntegrate[BesselK[5/3,x],{x,x0,Infinity},WorkingPrecision->lowestprec]];
xi[omega_,gamma_,bgauss_]:=-omega/Brat[bgauss]+(gamma^2-1)/(2*Brat[bgauss])*Log[(gamma+1)/(gamma-1)]-((gamma-omega)^2-1)/(2*Brat[bgauss])*Log[(gamma-omega+1)/(gamma-omega-1)];
IB1[omega_,gamma_,bgauss_]:=ib1[xi[omega,gamma,bgauss]];
sigma[omega_,gamma_]:=omega^2*gamma*(gamma-omega)/((gamma^2-1)*((gamma-omega)^2-1));
chi[omega_,gamma_]:=omega*(gamma*(gamma-omega)-1+omega^2)/((gamma^2-1)*((gamma-omega)^2-1));
Dmu[omega_,gamma_,bgauss_]:=Sqrt[2*Pi*Brat[bgauss]/(gamma^2-1)]*Log[(gamma-omega+1)*(gamma-1)/((gamma-omega-1)*(gamma+1))]^(-1/2);
B2[omega_,gamma_,bgauss_]:=sigma[omega,gamma]*BesselK[2/3,xi[omega,gamma,bgauss]];
B3[omega_,gamma_,bgauss_]:=chi[omega,gamma]*BesselK[1/3,xi[omega,gamma,bgauss]];
Kstuff[omega_,gamma_,bgauss_]:=IB1[omega,gamma,bgauss]+B2[omega,gamma,bgauss]-B3[omega,gamma,bgauss];
(* Barring Equation 31 *)
jgen[omega_,gamma_,bgauss_]:=(q^2/(hbar*c))*(me*c^2)^2/hbar*(omega/(Pi*gamma))*Sqrt[xi[omega,gamma,bgauss]/(2*Pi)]*Dmu[omega,gamma,bgauss]*Kstuff[omega,gamma,bgauss];
(* dw -> dw Sin[th], w-> w Sin[th], g-> g Sin[th] and Integrating over d\Omega = dth Sin[th]*)
(* {gamma->gammareal*Sin[th],omega->omegareal*Sin[th]} *)
grandgennew0[th_,omega_,gamma_,bgauss_]:=(1/(4*Pi))*(2*Pi*Sin[th])*(Sin[th])*(jgen[omega*Sin[th],gamma*Sin[th],bgauss]);
fgamset[th_,gamma_,T_]:=fgamfullfixedT[gamma*Sin[th],T];
grandgennew[th_,omega_,gamma_,T_,bgauss_]:=grandgennew[th,omega,gamma,T,bgauss]=grandgennew0[th,omega,gamma,bgauss]*fgamset[th,gamma,T];
omegalow[th_,gamma_]:=10^(-10);
(*omegahigh=-10^(-10)+(gammareal/Sin[th]-1);*)
omegahigh[th_,gamma_]:=-10^(-10)+(gamma-1/Sin[th]);
gammalow[th_]:=1/Sin[th];
gammahigh[th_]:=Infinity;
netot3[rhob_,npairs_]:=ne[rhob] + npairs; (* unsure if total or just ne or something more complicatd *)

(* Use WorkingPrecision->15 below seems to be good enough for external FindRoot to work with WorkingPrecision of 30 *)
(* too small WorkingPrecision here and complains about convergence and takes long time as well *)
(* ,WorkingPrecision->slowprec*)
(* PrecisionGoal->7,AccuracyGoal->7, *)
jgenthermalnew[rhob_?NumericQ,T_?NumericQ,bgauss_?NumericQ,npairs_?NumericQ]:=Module[{thp,omegap,gammap},netot3[rhob,npairs]*fgamfullfree[T]*NIntegrate[grandgennew[thp,omegap,gammap,T,bgauss],{thp,10^(-10),Pi-10^(-10)},{gammap,gammalow[thp],gammahigh[thp]},{omegap,omegalow[thp,gammap],omegahigh[thp,gammap]},PrecisionGoal->2,AccuracyGoal->Infinity, 
  Method -> "AdaptiveMonteCarlo", MaxPoints -> 2000]];

Q0synchqed[rhob_,T_,bgauss_,npairs_]:=Q0synchqed[rhob,T,bgauss,npairs]=Module[{foo},Print["QED"];jgenthermalnew[rhob,T,bgauss,npairs]];
(* removed AccuracyGoal since based upon number of digits, not number of significant digits! *)
(* AccuracyGoal->4,*)

Protect[ib1,xi,IB1,sigma,chi,Dmu,B2,B3,Kstuff,jgen,fgamset,grandgennew0,fgamset,omegalow,omegahigh,gammalow,gammahigh,netot3,jgenthermalnew];
];


(* normmatrix=Table[Sqrt[SquaredEuclideanDistance[p1[[1,1,ii]],p2[[1,1,jj]]]],{ii,1,Dimensions[p1[[1,1]]][[1]]},{jj,1,Dimensions[p2[[1,1]]][[1]]}];*)





minelement[p1_,p2_]:=Module[{ip1,ip2,dist,dist0,whichip1,whichip2,oldavgpoint,avgpoint,totalip1,totalip2,whichip1p,whichip1m,whichip2p,whichip2m,distpp,distpm,distmp,distmm,whichip1other,whichip2other,p1pos,p2pos,p1posother,p2posother,slopep1,interceptp1,slopep2,interceptp2,xpoint,ypoint,bottomp1,bottomp2},

dist0=10^(30);
totalip1=Dimensions[p1[[1,1]]][[1]];
totalip2=Dimensions[p2[[1,1]]][[1]];
For[ip1=1,ip1<=totalip1,
For[ip2=1,ip2<=totalip2,
dist=Sqrt[SquaredEuclideanDistance[p1[[1,1,ip1]],p2[[1,1,ip2]]]];
If[dist<dist0,dist0=dist;whichip1=ip1;whichip2=ip2;];
(*Print["dist=",dist," ip2=",ip2," ip1=",ip1];*)
ip2++;
];
ip1++;
];

If[totalip1>=1 && totalip2>=1,
(* oldavgpoint is stupid and does a kind of 1D fit to intersection *)
oldavgpoint={0.5*(p1[[1,1,whichip1]][[1]]+p2[[1,1,whichip2]][[1]]),0.5*(p1[[1,1,whichip1]][[2]]+p2[[1,1,whichip2]][[2]])};
];

If[totalip1>=2 && totalip2>=2,

(* x,y for each line *)
p1pos=p1[[1,1,whichip1]];
p2pos=p2[[1,1,whichip2]];

(* find neighbor that is not one of whichip1 or whichip2 but also closest to each other *)
whichip1p=If[whichip1+1<=totalip1,whichip1+1,totalip1];
whichip1m=If[whichip1-1>=1,whichip1-1,1];
whichip2p=If[whichip2+1<=totalip2,whichip2+1,totalip2];
whichip2m=If[whichip2-1>=1,whichip2-1,1];

If[whichip1p!=whichip1 && whichip2p!=whichip2,
distpp=Sqrt[SquaredEuclideanDistance[p1[[1,1,whichip1p]],p2[[1,1,whichip2p]]]];
,
distpp=10^(30);
];
If[whichip1p!=whichip1&&whichip2m!=whichip2,
distpm=Sqrt[SquaredEuclideanDistance[p1[[1,1,whichip1p]],p2[[1,1,whichip2m]]]];
,
distpm=10^(30);
];
If[whichip1m!=whichip1 && whichip2p!=whichip2,
distmp=Sqrt[SquaredEuclideanDistance[p1[[1,1,whichip1m]],p2[[1,1,whichip2p]]]];
,
distmp=10^(30);
];
If[whichip1m!=whichip1&&whichip2m!=whichip2,
distmm=Sqrt[SquaredEuclideanDistance[p1[[1,1,whichip1m]],p2[[1,1,whichip2m]]]];
,
distmm=10^(30);
];

(* guess in case distances triggers aren't completely general *)
whichip1other=whichip1p;
whichip2other=whichip2p;

(* get true next nearest neighbor *)
If[distpp<=distpm && distpp<=distmp && distpp<=distmm,
whichip1other=whichip1p;
whichip2other=whichip2p;
];
If[distpm<distpp&&distpm<=distmp&&distpm<=distmm,
whichip1other=whichip1p;
whichip2other=whichip2m;
];
If[distmp<distpp&&distmp<distpm&&distmp<distmm,
whichip1other=whichip1m;
whichip2other=whichip2p;
];
If[distmm<distpp&&distmm<distpm&&distmm<distmp,
whichip1other=whichip1m;
whichip2other=whichip2m;
];

(* get other points (x,y) *)
p1posother=p1[[1,1,whichip1other]];
p2posother=p2[[1,1,whichip2other]];

(* now have 4 points -- 2 per line, so extrapolate such that solution is where lines intersect *)
bottomp1=(p1posother[[1]]-p1pos[[1]]);
bottomp1=If[bottomp1==0,10^(-30),bottomp1];
slopep1=(p1posother[[2]]-p1pos[[2]])/bottomp1;
interceptp1=p1pos[[2]]-slopep1*p1pos[[1]];
bottomp2=(p2posother[[1]]-p2pos[[1]]);
bottomp2=If[bottomp2==0,10^(-30),bottomp2];
slopep2=(p2posother[[2]]-p2pos[[2]])/bottomp2;
interceptp2=p2pos[[2]]-slopep2*p2pos[[1]];
(* set yp1=yp2 and xp1=xp2 as 2 eqns and 2 unkowns solving for x and y *)
xpoint=(interceptp2-interceptp1)/(slopep1-slopep2);
ypoint=(interceptp2*slopep1-interceptp1*slopep2)/(slopep1-slopep2);
avgpoint={xpoint,ypoint};

If[doprintdebug==1,Print["whichip1=",whichip1," whichip2=",whichip2," whichip1other=",whichip1other," whichip2other=",whichip2other];];

If[doprintdebug==1, Print["p1pos=",p1pos," p2pos=",p2pos," p1posother=",p1posother," p2posother=",p2posother]; ];

If[doprintdebug==1, Print["avgpoint=",avgpoint];];
];


If[totalip1==1 ||  totalip2==1,avgpoint=oldavgpoint;];

If[totalip1==0 ||  totalip2==0,avgpoint=10^(30);dist0=10^(30);];

(* return *)
{avgpoint,dist0,whichip1,whichip2,totalip1,totalip2,p1[[1,1,whichip1]],p2[[1,1,whichip2]]}
];

Makeeq1difflist[eq1diff_,lT0_,lT1_,num_,npairs_]:=Module[
{foo,lT,ii,eq1difftable},
lT=Table[lT0+(lT1-lT0)*ii/(num-1),{ii,0,num-1}];
 (* eq1diff[T,npairs] *)
eq1difftable=Table[{lT[[ii]],eq1diff[10^lT[[ii]],npairs]},{ii,1,num}];
(* return *)
eq1difftable
];
ClearAll[gensolseq1diff];
gensolseq1diff[eq1diff_,npairs_]:=gensolseq1diff[eq1diff,npairs]=Module[
{foo,leta,list,lowestprec0,root,numele},
root=0;
lowestprec0=lowestprec;
lowestprec=30;
list=Makeeq1difflist[eq1diff,6,15,200,npairs];
numele=Dimensions[list][[1]];
(* assume monotonic -- else need to check all points if root near *)
If[list[[1,2]]>0 && list[[numele,2]]>0||list[[1,2]]<0 && list[[numele,2]]<0,
Print["eq1diffbad(at prec=30, trying again at prec=50=",list[[1,2]]," ",list[[numele,2]]];
lowestprec=50;
list=Makeeq1difflist[eq1diff,5,20,200,npairs];
];
(* check if still bad *)
If[list[[1,2]]>0 && list[[numele,2]]>0||list[[1,2]]<0 && list[[numele,2]]<0,
(* then report *)
Print["Did not span root: ",list];
(* report back large error at T=0 *)
list={{0,10^100}};
];
lowestprec=lowestprec0;
(* return *)
list
];
bisecteq1diff[ftol_,Ttol_,eq1diff_,npairs_]:=Module[
{foo,lowT,highT,fmin,fmax,error,myT,spanroot,MAXITER,ferr,ii,epsf,epsT},
spanroot=1; (* assume will span root *)
(* get fmin and fmax *)
lowT=10^5;
highT=10^20;
fmin=eq1diff[lowT,npairs];
fmax=eq1diff[highT,npairs];
If[fmin>0&&fmax>0 || fmin<0&&fmax<0,
(* need to expand starting points *)
lowT=10^4;
highT=10^25;
fmin=eq1diff[lowT,npairs];
fmax=eq1diff[highT,npairs];
If[fmin>0&&fmax>0 || fmin<0&&fmax<0,
Print["Bisection failure: ","fmin=",fmin," fmax=",fmax];
myT=0;
epsf=10^(30);
epsT=epsf;
spanroot=0;
];
];
If[spanroot==1,
 (* eq1diff[T,npairs] *)
MAXITER=200;

For[ii=1,ii<=MAXITER,
myT=Sqrt[lowT*highT];
ferr=eq1diff[myT,npairs];
(*Print["myT=",myT," ferr=",ferr," fmin=",fmin," fmax=",fmax];*)
If[ferr>0,highT=myT;fmax=ferr;,lowT=myT;fmin=ferr;];
epsf=Abs[ferr];
epsT=Abs[Log[10,highT/lowT]]/Abs[Log[10,lowT]];
(* break out of loop if tolerance met *)
If[ii==MAXITER,Print["MAXED-out MAXITER"];];
If[epsf<ftol || epsT<Ttol,ii=MAXITER+1;,ii++;];
]; (* end loop *)
]; (* end if spanned root *)
(* return *)
{myT,epsf,epsT}
];



(* Gets Aum (rhobcenter/rhobvalue) and T assuming npairs=0 *)
(* assumes rhobrad and rhobnorm same and that bgaussnorm and bgaussrad same *)
getTA[rhobnorm0_,rhobrad0_,bgaussnorm0_,bgaussrad0_]:=Module[
{foo,npairs0,lrhoblow,lrhobhigh,lTlow,lThigh,RELTOL,useminmethod,ntrials,goodpoint,triali,errorTA,pTA1,pTA2,errorlrhob,errorlT,pickpoint,doprintdebug0,minresult,errorpoint,MAXERROR,methodCPTAFR,okerrorlT,okerrorlrhob,myT,myrhob,solstrial,solsTAtrial},

npairs0=0;

(* set initial error as large so triggers to find solution *)
RELTOL=10^(-10);
errorTA=10^30*RELTOL;
(* bad sol so easily seen when debugging if this is not set *)
solsTAtrial={T->0,rhobforA->0};

(* setup equations to root find on *)
Unprotect[eqTA1diff,eqTA2diff,Qum0func,rhobcenterfunc,eqTAtotdiff];
Qum0func[bgauss_?NumericQ]:=bgauss^2/(4*Pi*Lpnum/vaout);
rhobcenterfunc[rhob_?NumericQ,T_?NumericQ,bgauss_?NumericQ,npairs_?NumericQ]:=(Qtot[rhob,rhob,T,bgauss,bgauss,npairs]/Qum0func[bgauss])*rhobingoing;
eqTA1diff[rhob_?NumericQ,T_?NumericQ,bgauss_?NumericQ,npairs_?NumericQ]:=(Pm-Pg[rhob,rhob,T,bgauss,bgauss,npairs])/Pm;
eqTA2diff[rhob_?NumericQ,T_?NumericQ,bgauss_?NumericQ,npairs_?NumericQ]:=(rhob-rhobcenterfunc[rhob,T,bgauss,npairs])/rhobingoing;
eqTAtotdiff[rhob_?NumericQ,T_?NumericQ,bgauss_?NumericQ,npairs_?NumericQ]:=eqTA1diff[rhob,T,bgauss,npairs]^2+eqTA2diff[rhob,T,bgauss,npairs]^2;
Protect[eqTA1diff,eqTA2diff,Qum0func,rhobcenterfunc,eqTAtotdiff];

(* Use ContourPlot to seek out shared root *)
ntrials=2;
goodpoint=0;
For[triali=1,triali<=ntrials,
If[errorTA>RELTOL,

(* assume only can compress, not decompress, so lower rho limit is rhobingoing.  Note that solution (s) are present for decompression, so have to avoid them *)
If[triali==1,
(* any higher lT than 9 and pairs important and then full 3D root finding would be needed *)
lTlow=4;lThigh=9;
lrhoblow=Log[10,rhobingoing*0.5];lrhobhigh=Log[10,10^(15)*rhobingoing];
];
(* sometimes pairs are very negligible and then temperature can be quite high *)
If[triali==2&&goodpoint==0,
Print["Trying Expanded"];
lTlow=4;lThigh=16;
lrhoblow=Log[10,rhobingoing*0.5];lrhobhigh=Log[10,10^(25)*rhobingoing];
pTA1old=pTA1;pTA2old=pTA2;
];
(* sometimes good point found but FindRoot not given good enough initial value *)
(* In that case, zoom-in around good point within error found already *)
If[triali==2&&goodpoint==1,
Print["Trying goodpoint zoom"];
lTlow=pickpoint[[1]]-Max[errorlT*2,1];lThigh=pickpoint[[1]]+Max[errorlT*2,1];
lrhoblow=pickpoint[[2]]-Max[errorlrhob*2,1];lrhobhigh=pickpoint[[2]]+Max[errorlrhob*2,1];
];

(* Get contour plots *)
If[doprintdebug==1,Print["CPTA1"];];
doprintdebug0=doprintdebug;doprintdebug=0; (* avoids excessive debug while getting plots *)
pTA1=ContourPlot[0==eqTA1diff[10^lrhob,10^lT,bgaussnorm,npairs0],{lT,lTlow,lThigh},{lrhob,lrhoblow,lrhobhigh}];
doprintdebug=doprintdebug0; (* recover value *)

If[doprintdebug==1,Print["CPTA2"];];
doprintdebug0=doprintdebug;doprintdebug=0; (* avoids excessive debug while getting plots *)
pTA2=ContourPlot[0==eqTA2diff[10^lrhob,10^lT,bgaussnorm,npairs0],{lT,lTlow,lThigh},{lrhob,lrhoblow,lrhobhigh}];
doprintdebug=doprintdebug0; (* recover value *)
If[doprintdebug==1,Print["CPATdone"];pTA1global=pTA1;pTA2global=pTA2;];

(* only pick point if Contour plots worked *)
If[Dimensions[pTA1[[1]]][[1]]>0 &&Dimensions[pTA2[[1]]][[1]]>0,
If[Dimensions[pTA1[[1,1]]][[1]]>0 &&Dimensions[pTA2[[1,1]]][[1]]>0,
minresult=minelement[pTA1,pTA2];
errorpoint=minresult[[2]];
MAXERROR=1; (* max overall log error which we call a good point that we can zoom in on *)
goodpoint=If[errorpoint>MAXERROR,0,1];
If[goodpoint==0,Print["No good CPTA point to pick: minresult",minresult]];
pickpoint=minresult[[1]];
errorlT=Abs[minresult[[7,1]]-minresult[[8,1]]];
errorlrhob=Abs[minresult[[7,2]]-minresult[[8,2]]];

methodCPTAFR=2; (* 2 gets job done, 1 can be problem when one of solutions zig-zags on small scales *)

(* Only FindRoot if still kinda bad error -- dont need these to be super accurate *)
okerrorlT=0.1;
okerrorlrhob=0.1;

If[methodCPTAFR==2,
(* if good enough error, then avoid Findroot and just assign *)
If[errorlT<okerrorlT && errorlrhob<okerrorlrhob,
myT=SetPrecision[10^pickpoint[[1]],lowestprec];
myrhob=SetPrecision[10^pickpoint[[2]],lowestprec];
solstrial={T->myT,rhob->myrhob};
errorTA=0;
];
];(* end if methodCPTAFR==2 *)

If[methodCPTAFR==1 || errorlT>okerrorlT || errorlrhob>okerrorlrhob,
Print["TAFR"];
solstrial=FindRoot[{eqTA1diff[10^x,10^y]==0,eqTA2diff[10^x,10^y]==0},{x,pickpoint[[1]]},{y,pickpoint[[2]]}];

myT=10^(solstrial[[1,2]]);
myrhob=10^(solstrial[[2,2]]);
myT=SetPrecision[myT,lowestprec];
myrhob=SetPrecision[myrhob,lowestprec];
errorTA=Abs[eqTAtotdiff[myT,myrhob]];
]; (* end if methodCPTAFR==1 *)

]; (* end Dimension inner check *)
];(* end Dimension outer check *)


If[errorTA>RELTOL && myT>10^8,Print["ContourPlot+FindRoot failed"," min=",errorTA];];
(* less strict on error at low temperatures if FR got a solution *)
(* reset errorTnpairs if want to pass solution through *)
If[errorTA>0.5 &&myT<10^8,Print["ContourPlot+FindRoot failed"," min=",errorTA];,errorTA=0;];

(* don't set or print-out solution if failed to get it *)
If[errorTA<RELTOL,
(* jump out of loop if got solution *)
triali=ntrials+1;
(* and set solution *)
solsTAtrial={T->myT,rhobforA->myrhob};
If[doprintdebug==1,Print["solsTAtrial=",solsTAtrial]];
If[doprintdebug==1,Print["errorTA=",errorTA]];
]; (* end if <RELTOL *)

]; (* end bit outer if <RELTOL *)

triali=triali+1;
]; (* end loop *)

(* return solution and error *)
{solsTAtrial,errorTA}
];


(* First check trivial case where npairs=0 is best solution *)
getTnpairs0[eq1diff_,eq2diff_,rhobnorm0_,rhobrad0_,bgaussnorm0_,bgaussrad0_]:=Module[
{foo,npairsguess,RELTOL,errorTnpairs,bisectreturn,Ttol,myT,epsf,epsT,solsTtrial,eq2diffnum,mynpairssol,npairsimplied,npairsperne},

npairsguess=0;

(* set initial error as large so triggers to find solution *)
RELTOL=10^(-10);
errorTnpairs=10^30*RELTOL;
(* bad sol so easily seen when debugging if this is not set *)
Clear[T,npairs];
solsTtrial={T->0,npairs->0};


(*
(* find good guess *)
Print["Before gensolseq1diff"];
solslist=gensolseq1diff[eq1diff,npairsguess];
Print["Before findelement for eq1diff"];
root=0;
lTguess=findelement[root,solslist][[3]];
Tguess=10^lTguess;
*)

(* bisect good because eq1diff can jump in value near root, never really getting close to zero but still "crossing" through it! *)
Ttol=10^(-6);
If[doprintdebug==1,Print["Trying Bisection for npairs=0"];];
bisectreturn=bisecteq1diff[RELTOL,Ttol,eq1diff,npairsguess];
If[doprintdebug==1,Print["Done Trying Bisection for npairs=0"];];
{myT,epsf,epsT}=bisectreturn;

(*
(* now find root *)
sols=FindRoot[eq1diff[T,0],{T,Tguess}];
myT=sols[[1,2]];
*)

(* now check eq2diff to see if npairs=0 works at this temperature *)
(* only do this check if bisect worked to either get eq1diff small or at least T near root *)
eq2diffnum=Abs[eq2diff[myT,npairsguess]];
npairsimplied=npairsfunc[rhobrad0,myT,bgaussrad0,npairsguess]//.consts;
npairsperne=npairsimplied/ne[rhobrad];
(* set npairs=0 if error small OR if implied npairs per ne is very small *)
If[(npairsperne<lowestnpairsperne)|| (eq2diffnum<RELTOL &&( Abs[epsf]<RELTOL||Abs[epsT]<Ttol)),
If[doprintdebug==1,Print["Got npairs=0 solution!"," eq2diffnum=",eq2diffnum];];
If[doprintdebug==1,Print["bisectreturn=",bisectreturn];];
If[doprintdebug==1,Print["npairsperne=",npairsperne];];
If[doprintdebug==1,Print["eq1diffparms:",rhobnorm0," ",rhobrad0," ",bgaussnorm0," ",bgaussrad0];];
If[doprintdebug==1,Print["eq1diffparms:",Precision[rhobnorm0]," ",Precision[rhobrad0]," ",Precision[bgaussnorm0]," ",Precision[bgaussrad0]];];

(* set solution *)
mynpairssol=0;

myT=SetPrecision[myT,lowestprec];
mynpairssol=SetPrecision[mynpairssol,lowestprec];
Clear[T,npairs];
solsTtrial={T->myT,npairs->mynpairssol};
errorTnpairs=0;
(* Then done! *)
]; (* if eq2diff check *)

(* return *)
{solsTtrial,errorTnpairs}

];(* end If[trynpairs0case==1, *)


(* old method *)
minmethod0func[eq1diff_,eq2diff_,rhobnorm0_,rhobrad0_,bgaussnorm0_,bgaussrad0_,errorother_,useminmethod_,myT_,mynpairssol_]:=Module[
{foo,GUESSRELTOL,Tguess,npairsguess,Tgoodguess,level1,level2,nlevel1,nlevel2,var10,var20,solsguess,solstrial,solsTtrial},

(* set most basic guess *)
GUESSRELTOL=1;
If[errorother<GUESSRELTOL && useminmethod==2,
(* then use previous "failed" result as a guess *)
Tguess=myT;
npairsguess=mynpairssol;
,
(* else use typical guess *)
Tgoodguess=(Pm/arad)^(1/4); (* assumes radiation dominated, which typically is *)
Tguess=SetPrecision[Tgoodguess,lowestprec];
npairsguess=SetPrecision[ne[rhobrad],lowestprec];
];

(* get better guess: cast wide net, then bit more shallow net, before using Newton's method *)
lowestprec=MachinePrecision;slowprec=MachinePrecision;
(* e.g. level1=0.5 and nevels1=10 with Tguess=10^9 goes like: 10^4 - 10^14 and nevel2=2 nevel2=10 w/ npairsguess=10^13 goes like: 10^-7 - 10^23 *)
level1=0.25; level2=1;nlevel1=20;nlevel2=20; var10=Tguess;var20=npairsguess;
solsguess=gettemperaturegetguess[level1,level2,nlevel1,nlevel2,eq1diff,eq2diff,var10,var20];

(*
level1=level1/2; level2=level2/2;nlevel1=10;nlevel2=10;var10=solsguess[[1]];var20=solsguess[[2]];solsguess=gettemperaturegetguess[level1,level2,nlevel1,nlevel2,eq1diff,eq2diff,var10,var20];
*)

level1=level2/8; level2=level2/8;nlevel1=10;nlevel2=10;var10=solsguess[[1]];var20=solsguess[[2]];solsguess=gettemperaturegetguess[level1,level2,nlevel1,nlevel2,eq1diff,eq2diff,var10,var20];

(* get solution for T and npairs *)
(* CAREFUL: Using high WorkingPrecision can lead to FindRoot offsetting indep's by too small a value to show up as new function value *)
lowestprec=30;slowprec=15;myprecfindroot=MachinePrecision;
(* re-get general functions with new precision *)
getPUNQ;
level1=.5; level2=2;nlevel1=5;nlevel2=5;
solstrial=gettemperature[level1,level2,nlevel1,nlevel2,eq1diff,eq2diff,solsguess[[1]],solsguess[[2]]];
myT=solstrial[[1]];
mynpairssol=solstrial[[2]];
myT=SetPrecision[myT,lowestprec];
mynpairssol=SetPrecision[mynpairssol,lowestprec];
solsTtrial={T->myT,npairs->mynpairssol};

(* return - 0 error assumes found solution, but may not have *)
{solsTtrial,0}
]; (* end If[useminmethod==0 || errorTnpairs>RELTOL, *)


(* Try using NMinimize on combined equation *)
minmethod1func[eqtotdiff_,rhobnorm0_,rhobrad0_,bgaussnorm0_,bgaussrad0_]:=Module[
{foo,min,solstrial,myT,mynpairssol,errorTnpairs,truemynpairs,solsTtrial,RELTOL},

(* set initial error as large so triggers to find solution *)
RELTOL=10^(-10);
errorTnpairs=10^30*RELTOL;
(* bad sol so easily seen when debugging if this is not set *)
solsTtrial={T->0,npairs->0};

(* now comes methods that work for non-zero npairs and can sometimes work even if npairs->0 *)
lowestprec=MachinePrecision;slowprec=MachinePrecision;
(*{min,solstrial}=NMinimize[{eqtotdiff[x,y],x>0,y>0},{x,y}];*)
{min,solstrial}=NMinimize[{eqtotdiff[x,y]},{x,y}];
myT=solstrial[[1,2]];
mynpairssol=solstrial[[2,2]];

(* errorTnpairs should be kept as global variable *)
errorTnpairs=Abs[min];

(*solsTtrial={T->solstrial[[1,2]],npairs->solstrial[[2,2]]};*)
(* when npairs negligible, need to compute directly since eq2diff always small *)
(* essentially this is limit when 2eqs/2unkns becomes 1eq/1unkn *)
truemynpairs=npairsfunc[rhobrad0,myT,bgaussrad0,mynpairssol];
solsTtrial={T->myT,npairs->truemynpairs};

If[errorTnpairs>RELTOL,Print["NMinimize failed"," min=",errorTnpairs];];

(* return *)
{solsTtrial,errorTnpairs}
];


(* Use ContourPlot to seek out shared root *)
minmethod2func[eq1diff_,eq2diff_,rhobnorm0_,rhobrad0_,bgaussnorm0_,bgaussrad0_]:=Module[
{foo,ntrials,goodpoint,triali,errorTnpairs,RELTOL,solsTtrial,Tmid,Tbaryon,npairstest,npairsavg,yavg,ylow,yhigh,lTlow,lThigh,lnpairslow,lnpairshigh,p1old,p2old,p1,p2,pickpoint,errorlT,errorlnpairs,minresult,errorpoint,MAXERROR,methodCPFR,okerrorlT,okerrorlnpairs,mynpairssol,myT,solstrial,truemynpairs,numpoints1,numpoints2,npairslowest},

(* set initial error as large so triggers to find solution *)
RELTOL=10^(-10);
errorTnpairs=10^30*RELTOL;
(* bad sol so easily seen when debugging if this is not set *)
solsTtrial={T->0,npairs->0};

ntrials=2;
goodpoint=0;
For[triali=1,triali<=ntrials,
If[errorTnpairs>RELTOL,
Tmid=me*c^2/kb;
Tbaryon=Pm*mb/(kb*rhobingoing);
npairstest=If[Tbaryon>Tmid,npairsfunc[rhobingoing,Tmid,bgaussrad,ne[rhobingoing]],ne[rhobingoing]];
(* can't find good bootstrap besides ne, but that eventually can't work for very optically thick regions, so have to use very broad ylow to yhigh range *)
npairslowest=ne[rhobingoing]*lowestnpairsperne;
ylow=Log[10,npairslowest];
(* don't need to go down too far else npairs=0 method should work *)
yavg=Log[10,ne[rhobingoing]];
yhigh=yavg+10;
If[triali==1,
(* using lTlow=8 assumes, for efficiency to avoid Expanded, npairs=0 solution gets any T below as ok to set npairs=0 *)
(* lThigh=14 from looking at models parameter space *)
lTlow=globallTlow;lThigh=globallThigh;lnpairslow=ylow;lnpairshigh=yhigh;
];
(* sometimes pairs are very negligible and then temperature can be quite high *)
If[triali==2&&goodpoint==0,
Print["Trying Expanded"];lTlow=globallTlow-2;lThigh=globallThigh+2;lnpairslow=ylow;lnpairshigh=yhigh;
p1oldglobal=p1;p2oldglobal=p2;
];
(* sometimes good point found but FindRoot not given good enough initial value *)
(* In that case, zoom-in around good point within error found already *)
If[triali==2&&goodpoint==1,Print["Trying goodpoint zoom"];lTlow=pickpoint[[1]]-Max[errorlT*2,1];lThigh=pickpoint[[1]]+Max[errorlT*2,1];lnpairslow=pickpoint[[2]]-Max[errorlnpairs*2,1];lnpairshigh=pickpoint[[2]]+Max[errorlnpairs*2,1];];

If[doprintdebug==1,Print["CP1"];];
p1=ContourPlot[0==eq1diff[10^x,10^y],{x,lTlow,lThigh},{y,lnpairslow,lnpairshigh}];
If[doprintdebug==1,Print["CP2"];];
p2=ContourPlot[0==eq2diff[10^x,10^y],{x,lTlow,lThigh},{y,lnpairslow,lnpairshigh}];
If[doprintdebug==1,Print["CPdone"];p1global=p1;p2global=p2;];

(* only pick point if Contour plots worked *)
If[Dimensions[p1[[1]]][[1]]>0 &&Dimensions[p2[[1]]][[1]]>0,
numpoints1=Dimensions[p1[[1,1]]][[1]];
numpoints2=Dimensions[p2[[1,1]]][[1]];
Print["CP1 numpoints1=",numpoints1];
Print["CP2 numpoints2=",numpoints2];
If[numpoints1>0 &&numpoints2>0,
minresult=minelement[p1,p2];
errorpoint=minresult[[2]];
MAXERROR=1; (* max overall log error which we call a good point that we can zoom in on *)
goodpoint=If[errorpoint>MAXERROR,0,1];
If[goodpoint==0,Print["No good CP point to pick: minresult",minresult]];
pickpoint=minresult[[1]];
errorlT=Abs[minresult[[7,1]]-minresult[[8,1]]];
errorlnpairs=Abs[minresult[[7,2]]-minresult[[8,2]]];

methodCPFR=2; (* 2 gets job done, 1 can be problem when one of solutions zig-zags on small scales *)

(* Only FindRoot if still kinda bad error -- dont need these to be super accurate *)
okerrorlT=0.1;
okerrorlnpairs=0.1;

If[methodCPFR==2,
(* if good enough error, then avoid Findroot and just assign *)
(* NOTE: put in 1|| since don't want to switch to FR -- just leave with poor error or increase resolution of CP *)
If[1||errorlT<okerrorlT && errorlnpairs<okerrorlnpairs,
myT=SetPrecision[10^pickpoint[[1]],lowestprec];
mynpairssol=SetPrecision[10^pickpoint[[2]],lowestprec];
solstrial={T->myT,npairs->mynpairssol};
errorTnpairs=0;
];
];(* end if methodCPFR==2 *)

If[ errorlT>okerrorlT || errorlnpairs>okerrorlnpairs,
Print["Not good error, but don't use FR for now"];
Print["errorlT=",errorlT];
Print["errorlnpairs=",errorlnpairs];
(* if change this, then remove 1|| above in methodCPFR==2 *)
];

If[methodCPFR==1 ,
Print["FR"];
solstrial=FindRoot[{eq1diff[10^x,10^y]==0,eq2diff[10^x,10^y]==0},{x,pickpoint[[1]]},{y,pickpoint[[2]]}];

myT=10^(solstrial[[1,2]]);
mynpairssol=10^(solstrial[[2,2]]);
myT=SetPrecision[myT,lowestprec];
mynpairssol=SetPrecision[mynpairssol,lowestprec];
errorTnpairs=Abs[eqtotdiff[myT,mynpairssol]];
];(* end if methodCPFR==1 *)

];(* end Dimension inner check *)
];(* end Dimension outer check *)


If[errorTnpairs>RELTOL && myT>10^8,Print["ContourPlot+FindRoot failed"," min=",errorTnpairs];];
(* less strict on error at low temperatures if FR got a solution *)
(* reset errorTnpairs if want to pass solution through *)
If[errorTnpairs>0.5 &&myT<10^8,Print["ContourPlot+FindRoot failed"," min=",errorTnpairs];,errorTnpairs=0;];

(* don't set or print-out solution if failed to get it *)
If[errorTnpairs<RELTOL,
(* jump out of loop if got solution *)
triali=ntrials+1;
(* and set solution *)
(* eq2diff[T_,npairs_]:=(npairs-npairsfunc[rhobrad,T,bgaussrad,npairs])/(ne[rhobrad])//.consts;*)
truemynpairs=npairsfunc[rhobrad,myT,bgaussrad,mynpairssol];
solsTtrial={T->myT,npairs->truemynpairs};
If[doprintdebug==1,Print["solsTtrial=",solsTtrial]];
If[doprintdebug==1,Print["errorTnpairs=",errorTnpairs]];
];(* end if <RELTOL *)

]; (* end bit outer if <RELTOL *)

triali=triali+1;
];(* end loop *)

(* return *)
{solsTtrial,errorTnpairs}
]; (* end If[useminmethod==2, *)


(* major function to get temperature *)
gettemperaturewrapper[rhobnorm0_,rhobrad0_,bgaussnorm0_,bgaussrad0_]:=Module[
{foo,rhobnorm=rhobnorm0,rhobrad=rhobrad0,bgaussnorm=bgaussnorm0,bgaussrad=bgaussrad0,myT,mynpairssol,truemynpairs,Pbnum,Tmid,Tbaryon,npairstest,npairsavg,triali,lTlow,lThigh,lnpairslow,lnpairshigh,ntrials,minresult,goodpoint,errorpoint,okerrorlT,okerrorlnpairs,methodCPFR,MAXERROR,failed,root,npairsguess,lTguess,Tguess,sols,trynpairs0case,RELTOL,Ttol,epsf,epsT,eq2diffnum,Aumlocal},

 (* 0=try to find MIN itself, then feed to FindRoot *)
(* 1==much more robust for this particular simple 2 equations and 2 unknowns since visually can tell a kinda of 2D bisection would be good enough *)
(* 1 can take long time for no good reason.  Sometimes fast, but sometimes very slow. *)
(* 2==ContourPlot+FindRoot : seems to be fastest and safest and doesn't get stuck like 1 *)
useminmethod=2;
trynpairs0case=1; (* whether to check if npairs=0 is a solution so just 1D problem *)


(* setup equations to find root of *)
Unprotect[Pgfunc];
Pgfunc[T_,npairs_]:=Pg[rhobnorm,rhobrad,T,bgaussnorm,bgaussrad,npairs]//.consts;
Protect[Pgfunc];
Pbnum=Pm; 
(* force balance condition *)
Unprotect[eq1diff,eq2diff,eqtotdiff];
Clear[eq1diff,eq2diff];
(* both are relative differences and reasonably normalized, but when lots of pairs, using $n_e$ to normalize might be too much of a constraint to have a relative error much less than unity *)
eq1diff[T_,npairs_]:=(Pgfunc[T,npairs]-Pbnum)/Pbnum//.consts;
(* problem with below eq2diff is that if npairs <<ne, then npairs can be set to any smaller value and Abs[eq2diff] becomes <<1 *)
eq2diff[T_,npairs_]:=(npairs-npairsfunc[rhobrad,T,bgaussrad,npairs])/(ne[rhobrad])//.consts;
(* try normalizing pairs with pre-suppressed pair density. -- doesn't work *)
(*eq2diff[T_,npairs_]:=(npairs-npairsfunc[rhobrad,T,bgaussrad,npairs])/(npairs0[rhobrad,Trad,bgaussrad])//.consts;*)
(* try normalizing directly by npairsfunc -- doesn't work *)
(*eq2diff[T_,npairs_]:=(npairs-npairsfunc[rhobrad,T,bgaussrad,npairs])/(npairsfunc[rhobrad,T,bgaussrad,npairs])//.consts;*)
Protect[eq1diff,eq2diff];
eqtotdiff[T_,npairs_]:=eq1diff[T,npairs]^2+eq2diff[T,npairs]^2;
Protect[eqtotdiff];


(* set initial error as large so triggers to find solution *)
RELTOL=10^(-10);
errorTnpairs=10^30*RELTOL;
(* bad sol so easily seen when debugging if this is not set *)
Clear[T,npairs];
solsTtrial={T->0,npairs->0};


If[trynpairs0case==1,
resultTnpairs0=getTnpairs0[eq1diff,eq2diff,rhobnorm,rhobrad,bgaussnorm,bgaussrad];
solsTtrial=resultTnpairs0[[1]];
errorTnpairs=resultTnpairs0[[2]];


(* if npairs=0, can find Aum kinda easily *)
If[errorTnpairs<RELTOL,
(* getAumitself requires Trad and npairsrad to compute Qtot,else undefined *)
(* rhobrad, bgaussrad, etc. should already be set *)
Trad=solsTtrial[[1,2]];
npairsrad=solsTtrial[[2,2]];
Aumlocal=getAumitself;

If[doprintdebug==1,Print["Aumlocal=",Aumlocal];];
RELTOLAum=0.2;
(*If[Abs[Aumlocal-1]>RELTOLAum,*)
If[Aumlocal>Aumtrigger,
resultTA=getTA[rhobnorm,rhobrad,bgaussnorm,bgaussrad];
solsTA=resultTA[[1]];
errorTA=resultTA[[2]];
If[errorTA<RELTOL,
(* ITERATED: rhobcenter *)
rhobcenter=solsTA[[2,2]];
errorTnpairs=0;
];(* end if good TA error *)
]; (* end if Aumlocal>1*)
]; (* end if good Tnpairs error *)
];(* end if getting npairs=0 solution *)


If[errorTnpairs>RELTOL,

If[useminmethod==1,
resultmin1=minmethod1func[eqtotdiff,rhobnorm,rhobrad,bgaussnorm,bgaussrad];
solsTtrial=resultmin1[[1]];
errorTnpairs=resultmin1[[2]];
];

If[useminmethod==2|| errorTnpairs>RELTOL,
resultmin2=minmethod2func[eq1diff,eq2diff,rhobnorm,rhobrad,bgaussnorm,bgaussrad];
solsTtrial=resultmin2[[1]];
errorTnpairs=resultmin2[[2]];
];

If[useminmethod==0 || errorTnpairs>RELTOL,
resultmin0=minmethod0func[eq1diff,eq2diff,rhobnorm,rhobrad,bgaussnorm,bgaussrad,errorTnpairs,useminmethod,solsTtrial[[1,2]],solsTtrial[[2,2]]];
solsTtrial=resultmin0[[1]];
errorTnpairs=resultmin0[[2]];
];

]; (* end overall RELTOL check before doing various methods *)

myTmev=kb*T/ergPmev//.{T->solsTtrial[[1,2]]};
If[doprintdebug==1,Print["myTmev=",myTmev," npairs/ne=",solsTtrial[[2,2]]/ne[rhobrad]," error=",errorTnpairs];
Print["solsTtrial=",solsTtrial];
];

(* return *)
solsTtrial
];




gettemperaturetestguess[rhobnorm0_,rhobrad0_,Tnorm0_,Trad0_,bgaussnorm0_,bgaussrad0_,npairsnorm0_,npairsrad0_]:=Module[
{foo,rhobnorm=rhobnorm0,rhobrad=rhobrad0,Tnorm=Tnorm0,Trad=Trad0,bgaussnorm=bgaussnorm0,bgaussrad=bgaussrad0,npairsnorm=npairsnorm0,npairsrad=npairsrad0,Pbnum,solstrial},

Unprotect[Pgfunc];
Pgfunc[T_,npairs_]:=Pg[rhobnorm,rhobrad,T,bgaussnorm,bgaussrad,npairs]//.consts;
Protect[Pgfunc];
Pbnum=Pm; 

(* force balance condition *)
Unprotect[eq1diff,eq2diff];
Clear[eq1diff,eq2diff];
(* both are relative differences and reasonably normalized, but when lots of pairs, using $n_e$ to normalize might be too much of a constraint to have a relative error much less than unity *)
eq1diff[T_,npairs_]:=(Pgfunc[T,npairs]-Pbnum)/Pbnum//.consts;
eq2diff[T_,npairs_]:=(npairs-npairsfunc[rhobrad,T,bgaussrad,npairs])/(ne[rhobrad])//.consts;
Protect[eq1diff,eq2diff];

(* set most basic guess *)
Tguess=Tnorm;
npairsguess=npairsnorm;

(* get solution for T and npairs *)
level1=0; level2=0;nlevel1=1;nlevel2=1;
solstrial=gettemperature[level1,level2,nlevel1,nlevel2,eq1diff,eq2diff,Tguess,npairsguess];
Clear[solsTtrial,T,npairs];
solsTtrial={T->solstrial[[1]],npairs->solstrial[[2]]};

myTmev=kb*T/ergPmev//.{T->solsTtrial[[1,2]]};
If[doprintdebug==1,
Print["myTmev=",myTmev," npairs/ne=",solsTtrial[[2,2]]/ne[rhobrad]];
Print["solsTtrial=",solsTtrial];
];

(* return *)
solsTtrial
];





(* get both T and npairs *)
gettemperature[level10_,level20_,nlevel10_,nlevel20_,eq1diff_,eq2diff_,var100_,var200_]:=Module[
{foo,level1=level10,level2=level20,nlevel1=nlevel10,nlevel2=nlevel20,ii,jj,var1,var10=var100,myvar1,var10list,numvar10,var2,var20=var200,myvar2,var20list,numvar20,erroreq1,erroreq2,error0eq1,error0eq2,myprec,sols0,sols,fulleq1,fulleq2,errorroot,debugformat,RELTOL,nn,var1orig,var2orig},
(*solsT=FindRoot[Pg==Pm,{T,10^(10)},WorkingPrecision->20];*)
(*solsT=FindRoot[Ug==Um,{T,10^(10)},WorkingPrecision->20];*)
(* Problems getting root with bad guess, so do below *)
(* Also, problem with FindRoot not returning correct answer if anything odd happens like Overflow *)
myprec=lowestprec;
debugformat=0; (* 0 = normal : 1 = show error per initial point *)


fulleq1[var1_?NumericQ,var2_?NumericQ]:=SetPrecision[Expand[eq1diff[var1,var2]],myprec];
fulleq2[var1_?NumericQ,var2_?NumericQ]:=SetPrecision[Expand[eq2diff[var1,var2]],myprec];

(*
fulleq1[var1_,var2_]:=SetPrecision[Expand[eq1diff[var1,var2]],myprec];
fulleq2[var1_,var2_]:=SetPrecision[Expand[eq2diff[var2,var2]],myprec];
*)

(* random error *)
var1orig=var10;
var2orig=var20;
(* default solution in case nothing good found *)
sols={T->var1orig,npairs->var2orig};
erroreq1=Abs[fulleq1[var1orig,var2orig]];
erroreq2=Abs[fulleq2[var1orig,var2orig]];

(* probe various starting points rather than a single starting point with many iterations *)
(* start with most plausible and move to least plausible, so quicker to get solution *)
level1array=var10*Table[10^( (-1)^nn* level1*IntegerPart[(nn+1)/2]),{nn,0,nlevel1-1}];
level2array=var20*Table[10^( (-1)^nn* level2*IntegerPart[(nn+1)/2]),{nn,0,nlevel2-1}];
var10list=SetPrecision[level1array,myprec];
numvar10=Dimensions[var10list][[1]];
var20list=SetPrecision[level2array,myprec];
numvar20=Dimensions[var20list][[1]];


For[ii=1,ii<=numvar10,
(* pick*)
var10=SetPrecision[var10list[[ii]],myprec];

For[jj=1,jj<=numvar20,
(* pick*)
var20=SetPrecision[var20list[[jj]],myprec];

(* Evaluated->False required because equations have NIntegrate, which requires numerical values be inputed.  Evaluated->True (default) means functions are evaluated before numerical values are put in *)
errorroot=0;

(* DO Type 1 *)
(* Newton *)
(* ,AccuracyGoal->Infinity,PrecisionGoal->4 *)
If[doprintdebug==1,Print["gettemperature: FindRoot"];];
(* CAREFUL: Using high WorkingPrecision can lead to FindRoot offsetting indep's by too small a value to show up as new function value *)
Check[sols0=FindRoot[{fulleq1[var1,var2]==0,fulleq2[var1,var2]==0},{{var1,var10},{var2,var20}},WorkingPrecision->myprecfindroot],errorroot=1,{FindRoot::"cvmit",FindRoot::"lstol",FindRoot::"jsing",FindRoot::"nlnum"}];

(* DO Type 1.5 *)
(* Newton with Reap and Sow *)
(*
If[doprintdebug==1,Print["FindRoot reap/sow"];];
Clear[stxy];
Check[{sols0,stxy}=Reap[FindRoot[{fulleq1[var1,var2]==0,fulleq2[var1,var2]==0},{{var1,var10},{var2,var20}},WorkingPrecision->myprecfindroot,EvaluationMonitor:>Sow[{var1,var2}]]],errorroot=1,{FindRoot::"cvmit",FindRoot::"lstol",FindRoot::"jsing",FindRoot::"nlnum"}];
*)

(* DO Type 2 *)
(* Secant -- doesn't work *)
(*Check[sols0=FindRoot[{fulleq1[var1,var2]==0,fulleq2[var1,var2]==0},{{var1,var10/10,var10*10},{var2,var20/10^3,var20*10^3}},WorkingPrecision->myprecfindroot],errorroot=1,{FindRoot::"cvmit",FindRoot::"lstol"}];*)

(* DO Type 3 *)
(* just report error at this "initial" position *)
(*sols0={var1->var10,var2->var20};*)


myvar1=sols0[[1,2]];
myvar2=sols0[[2,2]];

error0eq1=Abs[fulleq1[myvar1,myvar2]];
error0eq2=Abs[fulleq2[myvar1,myvar2]];

If[doprintdebug==1&&debugformat==0,Print["gettemperature: sols0=",sols0];Print["gettemperature: error0eq1=",error0eq1];Print["gettemperature: error0eq2=",error0eq2];Print["gettemperature: errorroot=",errorroot];];

(* also checks that relative error for equation 1 relative difference is smallish and not abnormally large *)
errorroot=errorroot+If[sols0[[1,2]]!=var10 && sols0[[1,2]]>0&&sols0[[2,2]]!=var20 && sols0[[2,2]]>0&&error0eq1<10^(-2)&&error0eq1<erroreq1&&error0eq2<erroreq2,0,1];

If[doprintdebug==1&&debugformat==0,Print["gettemperature: post check: errorroot=",errorroot];];

If[doprintdebug==1&&debugformat==1,Print["gettemperature: specialFindRoot: =",SetPrecision[var10,5]," ",SetPrecision[var20,5]," ",SetPrecision[error0eq1,5]," ",SetPrecision[error0eq2,5]];];

(* if all good, then no longer need to iterate *)
(* override any FindRoot lstol issues if error is actually small enough.  Assume just problem getting down to very small errors *)
RELTOL=SetPrecision[10^(-4),myprec];
If[errorroot==0 || error0eq1<RELTOL&&error0eq2<RELTOL,sols=sols0;erroreq1=error0eq1;erroreq2=error0eq2;ii=numvar10;jj=numvar20];

(* iterate *)
jj++;
];
(* iterate *)
ii++;
];

If[doprintdebug==1&&debugformat==0,Print["gettemperature: FinalsolT"];Print[sols];Print["gettemperature: Finalerror1&2=",erroreq1," ",erroreq2];];

(* death check -- just return inputted solution *)
If[errorroot==0 || error0eq1<RELTOL&&error0eq2<RELTOL,0,Print["gettemperature: NO GOOD SOLUTION FOUND!"];];

(* return actual values *)
{sols[[1,2]],sols[[2,2]]}
];




(* find good guess by going over 2D grid of reasonable guesses.  Better to do this than let Newton's method work from each point since that would use many many more function evaluations *)
gettemperaturegetguess[level10_,level20_,nlevel10_,nlevel20_,eq1diff_,eq2diff_,var100_,var200_]:=Module[
{foo,level1=level10,level2=level20,nlevel1=nlevel10,nlevel2=nlevel20,ii,jj,var1,var10=var100,myvar1,var10list,numvar10,var2,var20=var200,myvar2,var20list,numvar20,erroreq1,erroreq2,error0eq1,error0eq2,myprec,sols0,sols,fulleq1,fulleq2,errorroot,debugformat,level1array,level2array,nn,errorrat,gooderror,gooderrorold,betterguess},
(*solsT=FindRoot[Pg==Pm,{T,10^(10)},WorkingPrecision->myprecfindroot];*)
(*solsT=FindRoot[Ug==Um,{T,10^(10)},WorkingPrecision->myprecfindroot];*)
(* Problems getting root with bad guess, so do below *)
(* Also, problem with FindRoot not returning correct answer if anything odd happens like Overflow *)
myprec=lowestprec;


fulleq1[var1_?NumericQ,var2_?NumericQ]:=SetPrecision[Expand[eq1diff[var1,var2]],myprec];
fulleq2[var1_?NumericQ,var2_?NumericQ]:=SetPrecision[Expand[eq2diff[var1,var2]],myprec];

(*
fulleq1[var1_,var2_]:=SetPrecision[Expand[eq1diff[var1,var2]],myprec];
fulleq2[var1_,var2_]:=SetPrecision[Expand[eq2diff[var2,var2]],myprec];
*)

(* random error *)
erroreq1=Abs[fulleq1[var10,var20]];
erroreq2=Abs[fulleq2[var10,var20]];
(* initial guess is supposed solution *)
sols={var1->var10,var2->var20};
If[doprintdebug==1,Print["Initial"];Print[sols];Print["Initialerror1&2=",erroreq1," ",erroreq2];];

(* probe various starting points rather than a single starting point with many iterations *)
(* start with most plausible and move to least plausible, so quicker to get solution *)
level1array=var10*Table[10^( (-1)^nn* level1*IntegerPart[(nn+1)/2]),{nn,0,nlevel1-1}];
level2array=var20*Table[10^( (-1)^nn* level2*IntegerPart[(nn+1)/2]),{nn,0,nlevel2-1}];
var10list=SetPrecision[level1array,myprec];
numvar10=Dimensions[var10list][[1]];
var20list=SetPrecision[level2array,myprec];
numvar20=Dimensions[var20list][[1]];

For[ii=1,ii<=numvar10,
(* pick*)
var10=SetPrecision[var10list[[ii]],myprec];

For[jj=1,jj<=numvar20,
(* pick*)
var20=SetPrecision[var20list[[jj]],myprec];

sols0={var1->var10,var2->var20};

myvar1=sols0[[1,2]];
myvar2=sols0[[2,2]];

error0eq1=Abs[fulleq1[myvar1,myvar2]];
error0eq2=Abs[fulleq2[myvar1,myvar2]];


(* if low errors, then choose it as best guess *)
(* don't rely strictly on error in var2 (i.e. npairs) since error can vary by alot, while error in eq1 is more true to the real error *)
(*errorrat=10^4; (* should be much bigger than 1 so less strict with eq2's error *)*)
(*betterguess=If[error0eq1<erroreq1 && (error0eq2<erroreq2||error0eq2<errorrat*erroreq2),1,0];*)

gooderrorold=Sqrt[(erroreq1^2+erroreq2^2)]/2;
gooderror=Sqrt[(error0eq1^2+error0eq2^2)]/2;

(*
gooderrorold=(erroreq1);
gooderror=(error0eq1);
*)

betterguess=If[gooderror<gooderrorold,1,0];
If[betterguess==1,If[doprintdebug==1,Print["Better guess found"]];erroreq1=error0eq1;erroreq2=error0eq2;sols={var1->var10,var2->var20};];

If[doprintdebug==1,Print["special:","ii=",ii," jj=",jj," ",SetPrecision[var10,5]," ",SetPrecision[var20,5]," ",SetPrecision[error0eq1,5]," ",SetPrecision[error0eq2,5]," ",SetPrecision[gooderror,5]];];


(* iterate *)
jj++;
];
(* iterate *)
ii++;
];

If[doprintdebug==1,Print["Finalstart"];Print[sols];Print["Finalerror1&2=",erroreq1," ",erroreq2];];

(* return actual values *)
{sols[[1,2]],sols[[2,2]]}
];





(* once have T and npairs, can get numerical values before compute plasma things *)
getradnums:=Module[
{foo},

(* other things needed by plasma part of calculation that turn into numbers *)
(* also some things that are related and inexpensive to compute *)
Qtotnum=Qtot[rhobnorm,rhobrad,Trad,bgaussnorm,bgaussrad,npairsrad];
Qradnum=Qrad[rhobrad,Trad,bgaussrad,npairsrad];
Qnunum=Qnu[rhobrad,Trad,bgaussrad,npairsrad];
Qnurat=Qnunum/Qtotnum;

Habsnum=Habs[rhobrad,Trad,bgaussrad,npairsrad];
Hscanum=Hsca[rhobrad,Trad,bgaussrad,npairsrad];
dtrad=Uradnum/Qradnum;

tauradabsnum=tauradabs[rhobrad,Trad,bgaussrad,npairsrad]; 
dtauradscadsnum=dtauradscads[rhobrad,Trad,bgaussrad,npairsrad];
dtauradabsdsnum=dtauradabsds[rhobrad,Trad,bgaussrad,npairsrad];

lambdascanum=1/dtauradscadsnum;
lambdaabsnum=1/dtauradabsdsnum;

Pgnum=Pg[rhobnorm,rhobrad,Trad,bgaussnorm,bgaussrad,npairsrad];
Pradnum=Prad[rhobrad,Trad,bgaussrad,npairsrad];
Ppairsnum=Ppairs[rhobrad,Trad,bgaussrad,npairsrad];
Ppairs0num=Ppairs0[rhobrad,Trad,bgaussrad];
Pbaryonnum=Pbaryon[rhobnorm,Tnorm];
Penum=Pe[rhobnorm,Tnorm];
Pnunum=Pnu[rhobnorm,Tnorm,bgaussrad,npairsrad];

Ugnum=Ug[rhobnorm,rhobrad,Trad,bgaussnorm,bgaussrad,npairsrad];
Uradnum=Urad[rhobrad,Trad,bgaussrad,npairsrad];
Upairsnum=Upairs[rhobrad,Trad,bgaussrad,npairsrad];
Upairs0num=Upairs0[rhobrad,Trad,bgaussrad];
Ubaryonnum=Ubaryon[rhobnorm,Tnorm];
Uenum=Ue[rhobnorm,Tnorm];
Ununum=Unu[rhobnorm,Tnorm,bgaussrad,npairsrad];

sigmaffnum=sigmaff[rhobrad,Trad,bgaussrad,npairsrad];
sigmasynchnum=sigmasynch[rhobrad,Trad,bgaussrad,npairsrad];

damptauradnum=damptaurad[rhobrad,Trad,bgaussrad,npairsrad];
damptaurad2num=damptaurad2[rhobrad,Trad,bgaussrad,npairsrad];

nradnum=nrad[rhobrad,Trad,bgaussrad,npairsrad];

npairs0num=npairs0[rhobrad,Trad,bgaussrad];
npairs0qednum=npairs0qed[Trad,bgaussrad];
Upairs0qednum=Upairs0qed[Trad,bgaussrad];
Ppairs0qednum=Ppairs0qed[Trad,bgaussrad];

taunuscanum=taunusca[rhobrad,Trad,bgaussrad,npairsrad];
Hnuscanum=Hnusca[rhobrad,Trad,bgaussrad,npairsrad];
taunuabsnum=taunuabs[rhobrad,Trad,bgaussrad,npairsrad];
Hnuabsnum=Hnuabs[rhobrad,Trad,bgaussrad,npairsrad];
damptaununum=damptaunu[rhobrad,Trad,bgaussrad,npairsrad];
damptaunu2num=damptaunu2[rhobrad,Trad,bgaussrad,npairsrad];
Ununum=Unu[rhobrad,Trad,bgaussrad,npairsrad];
nnutruenum=nnutrue[rhobrad,Trad,bgaussrad,npairsrad];
nnunum=nnu[rhobrad,Trad,bgaussrad,npairsrad];
Pnunum=Pnu[rhobrad,Trad,bgaussrad,npairsrad];
Qnunum=Qnu[rhobrad,Trad,bgaussrad,npairsrad];

vaoutnum=c*Sqrt[bsqvalue/(rhobvalue*c^2+bsqvalue)];
Qum0num=bsqgaussvalue/(4*Pi*Lpnum/vaoutnum);

Qgg2pairsnum=Rgg2pairs[rhobrad,Trad,bgaussrad,npairsrad];
Qge2pairsnum=Rge2pairs[rhobrad,Trad,bgaussrad,npairsrad];
Qee2pairsnum=Ree2pairs[rhobrad,Trad,bgaussrad,npairsrad];
taupairsscanum=taupairssca[rhobrad,Trad,bgaussrad,npairsrad];
taupairsabsnum=taupairsabs[rhobrad,Trad,bgaussrad,npairsrad];
damptaupairsnum=damptaupairs[rhobrad,Trad,bgaussrad,npairsrad];
damptaupairs2num=damptaupairs2[rhobrad,Trad,bgaussrad,npairsrad];
Qpairsnum=Qpairs[rhobrad,Trad,bgaussrad,npairsrad];

Rgg2pairsnum=Rgg2pairs[rhobrad,Trad,bgaussrad,npairsrad];
Rge2pairsnum=Rge2pairs[rhobrad,Trad,bgaussrad,npairsrad];
Ree2pairsnum=Ree2pairs[rhobrad,Trad,bgaussrad,npairsrad];
taunumpairsabsnum=taunumpairsabs[rhobrad,Trad,bgaussrad,npairsrad];
damptaunumpairsnum=damptaunumpairs[rhobrad,Trad,bgaussrad,npairsrad];
damptaunumpairs2num=damptaunumpairs2[rhobrad,Trad,bgaussrad,npairsrad];
Rpairsnum=Rpairs[rhobrad,Trad,bgaussrad,npairsrad];

veffpairsnum=veffpairs[rhobrad,Trad,bgaussrad,npairsrad];

];


(* resolves problems (computing right answer and getting done at all with even wrong answer) with Mathematica and large mu *)
ClearAll[omegaprelfactor]; (* purge any stored values before defining function *)
omegaprelfactor[muth_]:=omegaprelfactor[muth]=Module[
{mu},
top0=MeijerG[{{0},{2}},{{-1/2,1,3/2},{0}},mu^2/4];
bottom0=(2*BesselK[2,mu]);
top=FullSimplify[Normal[Series[top0,{mu,Infinity,2}]],{mu>0}];
bottom=FullSimplify[Normal[Series[bottom0,{mu,Infinity,2}]],{mu>0}];
omegaprelfactorreturn=If[muth<10,Sqrt[top0/bottom0]//.{mu->muth},Sqrt[top/bottom]//.{mu->muth}]
]
(* compute some plasma stuff *)
computeplasmastuff:=Module[
{foo},
(* See if pairs should be included as charge carriers *)
(* Compare annihilation time to plasma time to see if pairs included as charge carriers for plasma frequency *)
(* even a couple of positron pairs can annihilate with the many electrons, so should be ne+npairs, not npairs *)
netotpl=ne[rhobnorm]+npairs//.solsT;
sigmaesnum=sigmaes[Trad,bgaussplasmavalue];
sigmaBnum=sigmaB[Trad,bgaussplasmavalue];
sigmaknnum=sigmakn[Trad];
(* ITERATED within: Tann *)
Tann=1/(netotpl*sigmaesnum*c)//.consts//.solsT;
muth=(me*c^2)/(kb*T)//.consts//.solsT;
omegape=Sqrt[4*Pi*netotforomegape*q^2/me]*omegaprelfactor[muth];
Tpl=2*Pi/omegape;
Tdelta=Deltaspt/c;
(* ITERATED: netotforomegape *)
netotforomegape=ne[rhobnorm] + npairs*Exp[-Tpl^2/(Tann*Tdelta)]//.solsT;
muth=(me*c^2)/(kb*T)//.consts//.solsT;
omegape=Sqrt[4*Pi*netotforomegape*q^2/me]*omegaprelfactor[muth]//.consts//.solsT;
(* Gyration *)
omegag=(q*bgaussplasmavalue)/(gammae*me*c);
Tg=2*Pi/omegag;
(* QED gyration *)
omegabe1=(1/hbar)*(((me*c^2)^2+2*hbar*c*q*bgaussplasmavalue)^(1/2) - me*c^2);
];


gettaualongjet:=Module[
{foo},
(* below uses all electrons+positrons -- assuming layer heated up.  Only integrate up through layers in comoving frame *)
(*taualongjet1=(netot//.solsT)*sigmat*(fcover*Lpmodnum)//.consts;*)
tauradscanum=tauradsca[rhobrad,Trad,bgaussplasmavalue,npairsnorm];
taualongjet1=tauradscanum;
(* now integrate up rest of jet's electrons associated with baryons *)
rhobfake=rhobrad/(rc/Ljet)^2;
nbfake=nb[rhobfake];
nefake2=ne[rhobfake];
taualongjet2=Integrate[nefake2*sigmaesnum/(2*gammavalue),{rc,Ljet,Infinity}];
(* below is final opacity -- no pair production due to escaping photons for a given emax yet included *)
taualongjet=taualongjet1+taualongjet2;
];


(* Check because Solve got WRONG answer! *)
reportpressure:=Module[
{foo},
Pg//.solsT;
Pm//.solsT;
(*Print["P components"];*)
Pbaryon//.solsT;
Prad//.solsT;
Ppairs//.solsT;
(*Print["Tann"];*)
Tann//.solsT;
Tpl//.solsT;
taurad//.solsT;
Exp[-1/taurad]//.solsT;
];


getDelta:=Module[
{foo},
(* below assumes bsqvalue in HL units *)
(* Below is va mixed between within and outside layer *)
vamix=c*Sqrt[bsqplasmavalue/(rhobrad*c^2+bsqplasmavalue+Ugin+Pgin)]//.solsT;
(* Below is va **outside** layer assuming cold there, which is true so far *)
vaout=c*Sqrt[bsqplasmavalue/(rhobvalue*c^2+bsqplasmavalue)]//.solsT;
(* Below is va inside layer, which is just 0 -- never should be used *)
vain=0;
(* REDUNDANT: below is redundant so far, but conveniant place to have computed for clarity *)
muth=(me*c^2)/(kb*T)//.consts//.solsT;
omegape=Sqrt[4*Pi*netotforomegape*q^2/me]*omegaprelfactor[muth]//.solsT;
muthp=(mp*c^2)/(kb*T)//.consts//.solsT;
omegapp=Sqrt[4*Pi*np[rhobnorm]*q^2/mp]*omegaprelfactor[muthp]//.solsT;
Tpe=2*Pi/omegape//.solsT;
Tpp=2*Pi/omegapp//.solsT;
Deltapete=c/omegape//.solsT;
Deltapetp=c/omegapp//.solsT;
];





getlarmor:=Module[
{foo},
(* ELECTRONS *)
thetae=(kb*T)/(me*c^2)//.solsT;
thetaevth=(Ue[rhobnorm,Trad]/ne[rhobcenter]/(me*c^2))//.solsT;
vth=c*Sqrt[thetaevth*(2+thetaevth)]/(1+thetaevth)//.solsT;
(* ITERATED: gammae *)
gammae=1/Sqrt[1-(vth/c)^2]//.consts//.solsT;
pe=gammae*me*vth//.solsT;
Eele=(Sqrt[pe^2*c^2+me^2*c^4]-me*c^2)//.solsT;
(*ve=Sqrt[Eele*2/me]//.solsT;*)
wge=q*(bgaussplasmavalue)/(gammae*me*c)//.solsT;
(* Check Larmor radius in comoving frame *)
Rl=vth/wge//.solsT;
Rl/Lpnum//.solsT;
Deltapete/Lpnum//.solsT;
Deltapetp/Lpnum//.solsT;
space=1;
(* PROTONS *)
thetap=(kb*T)/(mp*c^2)//.solsT;
thetapvthp=(3/2)*(kb*T)/(mp*c^2)//.solsT;
vthp=c*Sqrt[thetapvthp*(2+thetapvthp)]/(1+thetapvthp)//.solsT;
gammap=1/Sqrt[1-(vthp/c)^2]//.solsT;
pp=gammap*mp*vthp//.solsT;
Ep=(Sqrt[pp^2*c^2+mp^2*c^4]-mp*c^2)//.solsT;
wgp=q*bgaussplasmavalue/(gammap*mp*c)//.solsT;
Rlp=vthp/wgp//.solsT;
];


(* assume input npairs is half of npairs corresponding to opposite charges *)
sigmacoul[rhob_,T_,bgauss_,npairshalf_]:=Module[{thetae,thetaevth,vth,vthermal,lambdaD,lambdaC,lambdac,sigma0,logL,sigmac,muth,netotforomegape,omegape,gammae,pe,Eele},
(* ELECTRONS *)
thetae=(kb*T)/(me*c^2);
thetaevth=(Ue[rhob,T]/ne[rhob]/(me*c^2));
vth=c*Sqrt[thetaevth*(2+thetaevth)]/(1+thetaevth);
(*LogL=20;*)
vthermal=vth;
muth=(me*c^2)/(kb*T);
netotforomegape=ne[rhob] + npairshalf*2; (* for this, assume all pairs always contribute to current *)
omegape=Sqrt[4*Pi*netotforomegape*q^2/me]*omegaprelfactor[muth];
lambdaD=(vthermal/omegape);
lambdaC=(1)*q^2/(kb*T);
gammae=1/Sqrt[1-(vth/c)^2];
pe=gammae*me*vth;
Eele=(Sqrt[pe^2*c^2+me^2*c^4]-me*c^2);
lambdac=q^2/(Eele);
sigma0=(5/16)*lambdac^2;
logL=Log[lambdaD/lambdac];
sigmac=sigma0*logL;
(* return *)
sigmac
];


getDeltasp:=Module[
{foo},
(* etac[units] = L^2*(M*L^2/S^2/L^3*L^2)/(M*L/S) = L^2/S *)
Uradnum=Urad[rhobrad,Trad,bgaussplasmavalue,npairsrad];
nucg=(4/3)*(Uradnum*sigmaesnum)/(me*c)//.solsT;
lambdamfpg=vth/nucg;
dpe=c/omegape//.solsT;
etac=dpe^2*nucg//.solsT;
Ununum=Unu[rhobrad,Trad,bgaussplasmavalue,npairsrad];
sigmanuenum=sigmanue[rhobrad,Trad,bgaussplasmavalue,npairsrad];
nucnu=(4/3)*(Ununum*sigmanuenum)/(me*c)//.solsT;
etanu=dpe^2*nucnu//.solsT;
(* below uses np, but want to estimate for ion+electron+positron *)
(*lambdamfps=1/(sigmac*np)//.solsT;*)
(*netot=ne+npairs;*)
(* only protons and pairs make change in average velocity of electron-positron pairs *)
nall=np[rhobnorm]+npairs//.solsT;
(* etas[units] = (L/S)*L *)
(*etas=c*radiuse*(thetae)^(-3/2)*LogLother2;*)
sigmac=sigmacoul[rhobnorm,Tnorm,bgaussrad,npairsrad];

lambdamfps=1/(sigmac*nall)//.solsT;
nucs=vth/lambdamfps//.solsT;
etas=dpe^2*nucs//.solsT;
If[etas<0.0,etas=10^(-500);];
(* OLD: Below must be iterated upon at least a few times *)
(* final Spitzer result -- now same as original one *)
etab=etas;
Tev=kb*T/ergPmev*10^6//.solsT;
(* ELECTRONS *)
thetae=(kb*Trad)/(me*c^2);
thetaevth=(Ue[rhobrad,Trad]/ne[rhobrad]/(me*c^2));
vth=c*Sqrt[thetaevth*(2+thetaevth)]/(1+thetaevth);
(*LogL=20;*)
vthermal=vth;
muth=(me*c^2)/(kb*Trad);
netotforomegape=ne[rhobrad] + npairsrad; (* for this, assume all pairs always contribute to current *)
omegape=Sqrt[4*Pi*netotforomegape*q^2/me]*omegaprelfactor[muth];
lambdaD=(vthermal/omegape);
lambdaC=(1)*q^2/(kb*Trad);
gammae=1/Sqrt[1-(vth/c)^2];
pe=gammae*me*vth;
Eele=(Sqrt[pe^2*c^2+me^2*c^4]-me*c^2);
lambdac=q^2/(Eele);
sigma0=(5/16)*lambdac^2;
logL=Log[lambdaD/lambdac];
LogLother2=Log[lambdaD/lambdaC];
(* number of protons witin Debye sphere *)
LambdaC1=24*Pi*np[rhobrad]*lambdaD^3;
(* number of charge-carrying particles within Debye sphere *)
LambdaC2=24*Pi*netotforomegape*lambdaD^3;
(* old, just checks *)
LogLother1=Log[(kb*Trad)^(3/2)/(Sqrt[Pi]*1*q^3*nb[rhobrad])];
etaprimebook=10^(-14)*LogLother2*(Tev)^(-3/2)//.solsT;
If[etaprimebook<0.0,etaprimebook=10^(-500);];
etabook=etaprimebook*c^2/(4*Pi)//.solsT;

(* total resistivity from radiation drag and from Coulomb/annihilation *)
etatotal=etac+etanu+etab;
Lundquistc=Lpnum*vaout/etac//.solsT;
Lundquistnu=Lpnum*vaout/etanu//.solsT;
Lundquists=Lpnum*vaout/etas//.solsT;
Lundquistb=Lpnum*vaout/etabook//.solsT;
Lundquistt=Lpnum*vaout/etatotal//.solsT;

(* UM10 *)
Deltaspc=(rhobcenter/rhobingoing)^(-1/2)*Sqrt[Lpnum*etac/vaout]//.solsT;
Deltaspnu=(rhobcenter/rhobingoing)^(-1/2)*Sqrt[Lpnum*etanu/vaout]//.solsT;
Deltasps=(rhobcenter/rhobingoing)^(-1/2)*Sqrt[Lpnum*etas/vaout]//.solsT;
Deltaspb=(rhobcenter/rhobingoing)^(-1/2)*Sqrt[Lpnum*etabook/vaout]//.solsT;
Deltaspt=(rhobcenter/rhobingoing)^(-1/2)*Sqrt[Lpnum*etatotal/vaout]//.solsT;

(* UM10 *)
vrecc0=etac/Deltaspc;
vrecnu0=etanu/Deltaspnu;
vrecs0=etas/Deltasps;
vrecb0=etab/Deltaspb;
vrect0=etatotal/Deltaspt;

vrecc=(rhobcenter/rhobingoing)^(1/2)*vrecc0;
vrecnu=(rhobcenter/rhobingoing)^(1/2)*vrecnu0;
vrecs=(rhobcenter/rhobingoing)^(1/2)*vrecs0;
vrecb=(rhobcenter/rhobingoing)^(1/2)*vrecb0;
vrect=(rhobcenter/rhobingoing)^(1/2)*vrect0;

];



(* New radiation element *)
(* requires Trad and npairsrad (among other things) be set globally *)
getAumitself:=Module[
{foo,Aum,vaout,Qum0,Qtotnum},

vaout=c*Sqrt[bsqTvalue/(rhobingoing*c^2+bsqTvalue)]//.solsT;
Qum0=bsqgaussTvalue/(4*Pi*Lpnum/vaout);
Qtotnum=Qtot[rhobnorm,rhobrad,Trad,bgaussnorm,bgaussrad,npairsrad];

If[doprintdebug==1,Print["Qtotnum=",Qtotnum," Qum0=",Qum0];];
If[doprintdebug==1,Print["Aumitselfstuff: ",Qum0," ",Qtotnum," ",rhobnorm," ",rhobrad," ",Trad," ",bgaussnorm," ",bgaussrad," ",npairsrad];];

(* Uzdensky & McKinney 2010 *)
Aum=Qtotnum/Qum0;
Aum=If[Aum<1,1,Aum]; (* If Aum<1, then reset to 1 since back to SP regime *)
Aum=SetPrecision[Aum,lowestprec];

(* return *)
Aum
];

(* for iterating over A *)
getAum:=Module[
{foo,Aum,vaout},
If[whichsplevel==0,rhobcenter=rhobingoing];
If[whichsplevel>0,

Aum=getAumitself;

If[doprintdebug==1,Print["Aum=",Aum];];

(* ITEREATED: rhobcenter *)
rhobcenter=Aum*rhobingoing;
(* set precision or else tiny loss of accuracy in Aum calculation accumulates after iterations -- equivalent to WorkingPrecision->lowestprec for this iteration process *)
rhobcenter=SetPrecision[rhobcenter,lowestprec];
];

];


(* needs to be updated for new full SP rel method -- kinda updated, but reverted partially *)
getDeltasprelnew:=Module[
{foo},
(* relativistic radiative version of SP -- replace Deltaspt with its output *)
(* have etatotal, now get solution *)

(* ignore relativistic SP stuff for now *)
solvespfullall;
Deltaspt=deltaspfinal;

];


limitT[Ttrial0_,Tc0_,limitfactor0_]:=Module[
{foo,Ttrial=Ttrial0,Tc=Tc0,limitfactor=limitfactor0},

If[Ttrial>limitfactor*Tc,Ttrial=limitfactor*Tc;];
If[Ttrial<Tc/limitfactor,Ttrial=Tc/limitfactor;];
(* return*)
Ttrial
];



(* super simplified SP case of only using pressure equilibrium *)
getDeltasprelorig:=Module[
{foo,limitfactor},

solsT=solsTtrial;
solsTrad=solsT;

(* "iterate" fsolssp as if returned like in solvespfullall for full SP solution *)
myu4vel=0.01; (* just keep non-rel *)
myb=bgaussnorm;
Ugnum=Ug[rhobnorm,rhobrad,Tnorm,bgaussnorm,bgaussrad,npairsrad];
myie=Ugnum;
fsolssp={d->Lpnum,ux->myu4vel,rhoc->rhobingoing,iec->myie,rhoout->rhobingoing,ieout->myie,Bx->myb,uy->myu4vel};
];


(* simplified SP case using pressure equilibrium AND radiative equilibrium from Uzdensky & McKinney 2010 *)
getDeltasprelum10:=Module[
{foo},
(* have etatotal, now get solution *)

(* TODO *)

(* Now need to set Afactor and use Afactor in enhancing baryon and electron density in layer *)
1
];


getconditione:=Module[
{foo},
(* electron/positrons dominate resistivity in Petschek regime *)
conditionec=FullSimplify[(Deltapete/(Deltaspc+10^(-500)))//.solsT,{bsqvalue>0,rhobvalue>0}];
conditionenu=FullSimplify[(Deltapete/(Deltaspnu+10^(-500)))//.solsT,{bsqvalue>0,rhobvalue>0}];
conditiones=FullSimplify[(Deltapete/(Deltasps+10^(-500)))//.solsT,{bsqvalue>0,rhobvalue>0}];
conditioneb=FullSimplify[(Deltapete/(Deltaspb+10^(-500)))//.solsT,{bsqvalue>0,rhobvalue>0}];
conditionet=FullSimplify[(Deltapete/(Deltaspt)+10^(-500))//.solsT,{bsqvalue>0,rhobvalue>0}];
];


getconditionp:=Module[
{foo},
(* protons dominate resistivity in Petschek regime -- normal! *)
conditionpc=FullSimplify[((Deltapetp/Deltaspc+10^(-500)))//.solsT,{bsqvalue>0,rhobvalue>0}];
conditionpnu=FullSimplify[((Deltapetp/Deltaspnu+10^(-500)))//.solsT,{bsqvalue>0,rhobvalue>0}];
conditionps=FullSimplify[((Deltapetp/Deltasps+10^(-500)))//.solsT,{bsqvalue>0,rhobvalue>0}];
conditionpb=FullSimplify[((Deltapetp/Deltaspb+10^(-500)))//.solsT,{bsqvalue>0,rhobvalue>0}];
conditionpt=FullSimplify[((Deltapetp/Deltaspt+10^(-500)))//.solsT,{bsqvalue>0,rhobvalue>0}];
(* Size of Pet layer compared to Lpnum *)
(* so perhaps every GRB fred is a reconnection event and number of freds related to number of polarity flips *)
Deltapetp/Lpnum//.solsT
];


getTobs:=Module[
{foo},
(* observed energy in MeV *)
T//.solsT;
Eco=(1/ergPmev)*(kb*T)//.solsT;
gammavalue;
(*Print["Observed value in MeV"];*)
Eobs=(1/ergPmev)*gammavalue*(kb*T)//.solsT;
(* ITERATED: gammae *)
gammae=(kb*T)/(me*c^2)//.solsT;
Esynobs=(1.7*10^(-8)/10^6*ergPmev*gammavalue*bgaussplasmavalue*gammae^2//.solsT);
Esynobskev=Esynobs/ergPmev*1000;
Eobsickev=Esynobskev*gammae^2;
];



gettimeann:=Module[
{foo},
(* Get pair density for critical field *)
Tannother=1/(ndentottemp2*sigmat*c); (* ndentottemp2 is a variable *)
muth=(me*c^2)/(kb*T);
omegap=Sqrt[4*Pi*ndentottemp2*q^2/me]*omegaprelfactor[muth];
Tplother=2*Pi/omegap;
(*Print["myn"];*)
myn=Solve[Tannother==Tplother,ndentottemp2][[1,1,2]];
myn*me*mp/me;
paireden=myn*me*c^2;
(* Obtain classical critical field strength *)
Solve[paireden==Bit^2/(8*Pi),Bit];
(* estimate quantum correction *)
2*10^15/137.;
(* Compare number density with classical electron density *)
1/(4*Pi/3*radiuse^3);
];



gettaus:=Module[
{foo},
netotnum=ne[rhobnorm]+npairs//.solsT;
taupairL=netotnum*sigmaesnum*Lpmodnum//.consts; (* diag *)
taugammaL=netotnum*sigmaesnum*Lpmodnum//.consts; (* diag *)
(* Sweet Parker optical depth across layer and along layer *)
tauspc=sigmaesnum*netotnum*Deltaspc//.solsT;
tausps=sigmaesnum*netotnum*Deltasps//.solsT;
tauspt=sigmaesnum*netotnum*Deltaspt//.solsT;
tauL=sigmaesnum*netotnum*(1)*Lpmodnum//.solsT;
(* compute optical depth to electron scattering within Petschek layer *)
taupete=sigmaesnum*netotnum*Deltapete//.solsT;
taupetp=sigmaesnum*netotnum*Deltapetp/.solsT;
(* Compute optical depth to baryon-electron scattering *)
(*sigmac=sigmat/(kb*T/(me*c^2))^2//.solsT;*)
taubet=np[rhobrad]*(Deltaspt)*sigmac//.solsT;
(*taubef=np*(Lpmodnum*fcover)*sigmac//.consts//.solsT;*)
(* baryons exist across entire jet, not just in layers *)
taubef=sigmaesnum*np[rhobrad]*Rjetmod//.consts//.solsT;
taubeR=np[rhobrad]*(Lpmodnum*1)*sigmac//.solsT;
(* So for any reasonable temperature baryons and electrons are significantly coupled due to high density still *)
];


getTdiffs:=Module[
{foo},
(* Compare photon diffusion time across layer and transit time along layer *)
TdiffacrossSPc = tauspc*Deltaspc/c//.solsT;
TdiffacrossSPs = tausps*Deltasps/c//.solsT;
TdiffacrossSPt= tauspt*Deltaspt/c//.solsT;
Tdiffalong= tauL*Lpmodnum/c//.solsT;

Tdiffsca1obs=(1/gammavalue)*Max[3*tauradscanum*Hscanum/c,Hscanum/c];
Tdiffsca2obs=(1/gammavalue)*Max[3*Deltaspt^2/(lambdascanum*c),Deltaspt/c];
Tdiffsca3obs=(1/gammavalue)*Max[3*Deltapetp^2/(lambdascanum*c),Deltapetp/c];

Tdiffabs1obs=(1/gammavalue)*Max[3*tauradabsnum*Habsnum/c,Habsnum/c];
Tdiffabs2obs=(1/gammavalue)*Max[3*Deltaspt^2/(lambdaabsnum*c),Deltaspt/c];
Tdiffabs3obs=(1/gammavalue)*Max[3*Deltapetp^2/(lambdaabsnum*c),Deltapetp/c];

(* Below is one special case when Lpmod should really be used since directly along single current layer *)
(* Ejection particle velocity is Alfven velocity outside layer *)
vtransit=vaout;
Ttransit=(Lpnum/vtransit)//.solsT;
Ttransitobs=Ttransit/gammavalue;
(* So photons leak out and cool layer before transiting fluid is heated *)

(* 10^(-16) just avoids warning messages about 1/0 when mmode=0 *)
TF=2*Pi/((mmode+10^(-16))*omegafvalue)//.consts;
Nslabs=10; (* assumes vr=0.1c *)
NpulsesperT=(1/TF)*(1/Nslabs);
dtminobs=10*TF;

];


getdtobs:=Module[
{foo},
(* observed reconnection time scale *)
(*dtobs=Ttransit/(2*gammavalue^2); -- no, not a photon catching up with shock *)
dttransitobs=Ttransit/(gammavalue);
(* rfast is location where fast reconnection occurs *)
rtransfast=rfast + dttransitobs*c;

(* radiation timescale for observer *)
dtradobs=dtrad/gammavalue;

(* Get luminosity of sheets *)
(* below wrong *)
vrecon=0.1*vaout;
Lrobs1=(gammavalue)*(2*bsqplasmavalue*vrecon)*(2*Pi*Rjet)*(2*Lpnum)//.consts;
(* Below wrong, new calculation shows luminosity is just jet luminosity *)
(*Lrobsf=(gammavalue)*(fcover*Rjet/Deltapetp)*(2*bsqvalue*vrecon)*(2*Pi*Rjet)*(2*Lpnum)//.consts;*)
Lrobsf=gammavalue^2*bsqplasmavalue*c*Pi*Rjet^2;
];


getidealValidity:=Module[ 
{foo},
netotnum=ne[rhobnorm]+npairs//.solsT;
(* with pairs --i.e. inside SP layer *)
vdprime=(c*Sqrt[bsqplasmavalue*4*Pi]/Lpnum)/(4*Pi*q*netotnum)//.solsT;
vdprime/c//.solsT;
(* without pairs *)
vdprime=(c*Sqrt[bsqplasmavalue*4*Pi]/Lpnum)/(4*Pi*q*netotnum)//.solsT;
vdprime/c//.solsT;
(* with current-carrying electrons+positrons *)
Jenc=(-Bphiplasmavalue*Sqrt[4*Pi]*Rjet*2*c)/(4*Pi*Rjet^2);
vdprime=Jenc/(q*netotforomegape)//.solsT;
vdprime/c//.solsT;
space=1;
Cthermg=Ttransit*nucg//.solsT;
Ctherms=Ttransit*nucs//.solsT;
Cthermnu=Ttransit*nucnu//.solsT;

space=1;
Tp=Lpnum/vaout//.solsT;
V1g=Tp*nucg//.solsT;
V1s=Tp*nucs//.solsT;
V2g=Lpnum/lambdamfpg//.solsT;
V2s=Lpnum/lambdamfps//.solsT;
space=1;
dv=0.2*Lpnum*(omegafvalue)//.consts//.solsT;
V3g=dv*Lpnum/(vth*lambdamfpg)//.consts//.solsT;
V3s=dv*Lpnum/(vth*lambdamfps)//.consts//.solsT;
space=1;
V5e=Tp*omegape/(2*Pi)//.consts//.solsT;
V5p=Tp*omegapp/(2*Pi)//.consts//.solsT;
space=1;
V6=(Lp/lambdaD)//.consts//.solsT;
space=1;
V7=(Exp[logL])//.consts//.solsT;
space=1;
V8a=(wge/(2*Pi*nucg))//.consts//.solsT;
V8b=(wge/(2*Pi*nucs))//.consts//.solsT;
V8c=(wgp/(2*Pi*nucg))//.consts//.solsT;
V8d=(wgp/(2*Pi*nucs))//.consts//.solsT;
space=1;
V9a=vth/vdprime//.consts//.solsT;
V9b=dv/vdprime//.consts//.solsT;
space=1;
V10=Tp*wge/(2*Pi)//.consts//.solsT;
space=1;
V11=Lp/Rl//.consts//.solsT;
space=1;
V12e=Tp*omegape^2/wge//.consts//.solsT;
V12p=Tp*omegapp^2/wgp//.consts//.solsT;
space=1;
V13e=(Lp/Rl)^2/(Tp*omegape)//.consts//.solsT;
V13p=(Lp/Rlp)^2/(Tp*omegapp)//.consts//.solsT;
space=1;
V14g=Lp*dv/etac//.consts//.solsT;
V14s=Lp*dv/etab//.consts//.solsT;
space=1;
V15e=Tp*omegape//.consts//.solsT;
V15p=Tp*omegapp//.consts//.solsT;
space=1;
V16e=Lp*(omegape^2/wge)*(dv/c^2)//.consts//.solsT;
V16p=Lp*(omegapp^2/wgp)*(dv/c^2)//.consts//.solsT;
space=1;
V17e=Lp*dv*wge/vth^2//.consts//.solsT;
V17p=Lp*dv*wgp/vthp^2//.consts//.solsT;
space=1;
V18e=Lp*wge/vth//.consts//.solsT;
V18p=Lp*wgp/vthp//.consts//.solsT;
space=1;
netotnum=netot[rhobrad,npairsrad];
(* q^2 = g cm^3/s^2 *)
(* Jcur = q/(s cm^2  as desired *)
Jcur=Abs[(2*c*Rjet*Bphiplasmavalue)/(Rjet^2)];
vdrifte=Jcur/(netotnum*q);
vdrifteperc=vdrifte/c; (* dimensionless as required *)
V19a=vth/vdrifte;
V19b=1/vdrifteperc;
space=1;
V20e=dv/(vth*Rl/Lp)//.consts//.solsT;
V20p=dv/(vthp*Rlp/Lp)//.consts//.solsT;
];







(* things not needed by any internal calculation, but things reported to diag file *)
getfinalnum:=Module[
{foo},

etanumcenternorm=myetae[rhobcenter,Tnorm];
etanumcenternormtrue=myetaetrue[rhobcenter,Tnorm];

(*
etanumcenterrad=myetae[rhobcenter,Trad];
etanumingoing=myetae[rhobingoing,Tnorm]; (* not really T out there? *)
*)
(* HACK for speed for now since Aum never anything but 1 *)
etanumcenterrad=etanumcenternorm;
etanumingoing=etanumcenternorm;


(* beta-eq Ye *)
Yebetanum=Yebeta[rhobrad,Trad,etanumcenternorm];
Yebetatruenum=Yebeta[rhobrad,Trad,etanumcenternormtrue];


(* see if nucleons are degen *)
degennucnum=degennuc[rhobrad,Trad];


(* non-QED accurate versions *)
npairs0true=npairs0noqed[rhobnorm,Tnorm];
Ppairs0true=Ppairs0noqed[rhobnorm,Tnorm];
Upairs0true=Upairs0noqed[rhobnorm,Tnorm];

(* non-QED accurate with accurate eta *)
npairs0truetrue=npairs0noqedtrue[rhobnorm,Tnorm];
Ppairs0truetrue=Ppairs0noqedtrue[rhobnorm,Tnorm];
Upairs0truetrue=Upairs0noqedtrue[rhobnorm,Tnorm];


];


(* Klein-Nishina *)
kncalc:=Module[
{foo},

(* Klein-Nishina for a given photon energy *)
alphaqm=q^2/(hbar*c);
sigmat=(8*Pi/3)*(alphaqm*hbar/(me*c))^2;
sigmat2=(8*Pi/3)*(q^4/(me^2*c^4));
AA=(2*Pi*q^4)/(me^2*c^4);
sigmaknnew=(3/4)*sigmat*((1+alphakn)/(alphakn^2)*(2*(1+alphakn)/(1+2*alphakn)-1/alphakn*Log[1+2*alphakn])+1/(2*alphakn)*Log[1+2*alphakn]-(1+3*alphakn)/(1+2*alphakn)^2);
sigmaknfreq=sigmaknnew//.{alphakn->(h*freqgamma)/(me*c^2)};
(* checks *)
result1=Limit[sigmaknnew,alphakn->0]/sigmat;
result2=sigmat-Limit[sigmaknnew,alphakn->0];
result3=sigmat2-Limit[sigmaknnew,alphakn->0];
result4=Series[sigmaknnew,{alphakn,Infinity,1}];
mysigmakn=(sigmaknnew//.{alphakn->ep})/sigmat;

diffsigmakn=Simplify[sigmakngen-sigmaknfreq];

];


(* optical depth appendix in paper *)
Clear[nep,fep,totalep,al,epmin,epmax,alphasp,sigmaggpersigmaes,sigmagg,sol,etaep,epminann];
nep[ep_,al_]:=(ep)^(-al-1);
fep[ep_,al_]:=(ep)^(-al);
(* A1: I in paper *)
totaleptemp[epmin_,epmax_,alphasp_]=FullSimplify[Integrate[fep[ep,alphasp],{ep,epmin,epmax}],{epmin>0,epmax>epmin,epmax>0,alphasp>1}];
totalep[epmin_?NumericQ,epmax_?NumericQ,alphasp_?NumericQ]:=Evaluate[totaleptemp[epmin,epmax,alphasp]];

(* A1b: I in paper *)
totaleptemp2[epmin_,epmax_,alphasp_]=FullSimplify[Integrate[ep*fep[ep,alphasp],{ep,epmin,epmax}],{epmin>0,epmax>epmin,epmax>0,alphasp>1}];
totalep2[epmin_?NumericQ,epmax_?NumericQ,alphasp_?NumericQ]:=Evaluate[totaleptemp2[epmin,epmax,alphasp]];

Clear[x];
totalxinttemp[ep_,epmin_,epmax_,alphasp_]=FullSimplify[Integrate[x^(-alphasp),{x,eplower,epmax}],{alphasp>1,eplower>0,epmax>eplower}]//.{eplower->Max[ep,epmin]};
totalxint[ep_?NumericQ,epmin_?NumericQ,epmax_?NumericQ,alphasp_?NumericQ]:=Evaluate[totalxinttemp[ep,epmin,epmax,alphasp]];

(* A5: sigmagg in paper *)
(* Get sigma_ {\gamma\gamma} averaged over photon spectra for those photons that can annihilate *)
epminann=1;
etaep[al_]:=4^al*6*(Gamma[1+al]^2/Gamma[5+2*al])*(14+20*al+9*al^2+al^3)/((3+al)*(2+al));
sol[al_]=FullSimplify[Integrate[nep[ep,al]*(etaep[al]/ep),{ep,epminann,Infinity}],{al>=1}]/FullSimplify[Integrate[nep[ep,al],{ep,epminann,Infinity}],{al>=1}];
sigmaggpersigmaes[alphasp_]=FullSimplify[sol[alphasp-1]]; (* al->alphasp-1 *)
(* gives 11/180 for alphasp=2 as in Lithwith & Sari (2001) when using epmax of Infinity *)
sigmagg[alphasp_]:=sigmaggpersigmaes[alphasp]*sigmat;

setupalphaepmin:=Module[
{eminobsMeV,eminobs,epmin,alphasp},
eminobsMeV=0.1;
(*eminobsMeV=1.0; *)
eminobs=eminobsMeV*ergPmev/(me*c^2); (* most strict lower-limit for highest-energy photon *)
epmin=eminobs/gammavalue;
alphasp=2.00001; (* shocks? *) (* for exactly 2, choose something like 2.00001 so don't have to worry about ensuring mathematica integrated to get general solution that allows log version when \alpha=2 *)
(* return *)
{alphasp,epmin,eminobsMeV}
];

tauhighe[alphasp_,eminobsMeV_]:=Module[
{foo,eminobs,epmin,epmax,Area,al,Ng,Ntot,Ntotold,deltat,minmethodtau,epmaxnum,epmaxerror,epthicknum,epmaxobs,fakeepthick,startepmax,solepmax,myminsols,mymin,depmaxnum,epmaxminnum,startepmaxmin,solepmaxmin,depmaxminnum,epmaxminerror,epmaxminobs,startepmaxmax,solepmaxmax,epmaxmaxnum,depmaxmaxnum,epmaxmaxerror,epmaxmaxobs,errormin,eq1diff,eq2diff,solmintau,solseps},

minmethodtau=3; (* ==1 more robust than FindRoot.  ==2 forces to avoid \gamma+pairs (\gamma+\gamma) -> \gamma + pairs *)
(* ==2 is useful since typically that process is not important and other method only relies upon 1-D procedure.  But then typically 2 mins, and want higher-energy version where photons are always optically thick for higher energies *)
(* 3 most robust using CP method *)

(*eminobsMeV=1.0; *)
eminobs=eminobsMeV*ergPmev/(me*c^2); (* most strict lower-limit for highest-energy photon *)
epmin=eminobs/gammavalue;

(* stays Rjet and Lpnum, not Rjetmod and Lpmodnum *)
Area=Pi*Rjet*Lpnum;
deltat=Ttransit;

(* A3: Ntot in paper *)
Ntotold[epmin_,epmin_]:=( Qradnum*Habsnum)*Area*deltat;
Ntot[epmin_,epmax_,al_]:=totalep[epmin,epmax,al]*(Uradnum*Habsnum)*Area/totalep2[epmin,epmax,al];

(* could use fastest rate of dissipation of magnetic energy into current sheet, corresponding to, say, non-thermal production in non-SP sheet.  Found similar *)
(*Ntot=2*(bgaussrad^2/(8*Pi)*c)*Area*deltat;*)

(* A2,A4: N>e in paper *)
Ng[ep0_,epmin_,epmax_]:=Module[
{result,ep},
ep=ep0;
ep=Max[ep,epmin];
ep=Min[ep,epmax];
result=(Ntot[epmin,epmax,alphasp]/totalep[epmin,epmax,alphasp])*totalxint[ep,epmin,epmax,alphasp];
(* return result *)
result
];


taugg[ep_?NumericQ,epmin_?NumericQ,epmax_?NumericQ]:=sigmagg[alphasp]*Ng[1/ep,epmin,epmax]/Area;

kncalc;
sigmagetemp[ep_]=sigmat*Evaluate[mysigmakn];
(* problem with ep when small, so just limit *)
sigmage[ep_]:=Module[{result},
result=If[ep<1,sigmat,sigmagetemp[ep]];
(* return *)
result
];

(* number of pairs produced by photon annihilation *)
Nee[epmin_,epmax_,epthick_]:=Ng[Max[1,epthick],epmin,epmax];
(* already-present thermal pairs should also be used -- no, these are included below already *)
(*Nee2:=npairsrad*Area*Habsnum; *)
Nee2=0;
Neetot[epmin_,epmax_,epthick_]:=Nee[epmin,epmax,epthick]+Nee2;

(* gamma+gamma+gamma -> e^+ + e^- +gamma -> gamma + e scattering *)
tauggge[ep_,epmin_,epmax_,epthick_]:=sigmage[ep]*Neetot[epmin,epmax,epthick]/Area;

(* similar to taualongjet calculation *)
tauge1[ep_]:=sigmage[ep]*((npairs//.solsTrad)*Nscalayers*Lpmodnum+ne[rhobrad]*Rjetmod);
(* now integrate up rest of jet's electrons associated with baryons *)
tauge2[ep_]:=sigmage[ep]/(2*gammavalue)*Integrate[ne[rhobrad/(rcep/Ljet)^2],{rcep,Ljet,Infinity}];
(* below is final opacity -- no pair production due to escaping photons for a given emax yet included *)
tauge[ep_]:=tauge1[ep]+tauge2[ep];

taugtot[ep_?NumericQ,epmin_?NumericQ,epmax_?NumericQ,epthick_?NumericQ]:=taugg[ep,epmin,epmax]+tauggge[ep,epmin,epmax,epthick]+tauge[ep];


(* taugtot tends to be a cubic that falls, rises, and eventually falls again *)
(* Whether any high point breaches taugtot==1 is dependent upon many factors *)
(* Sometimes, only one point (say first region) breaches *)

funDslow[epmax_]:=Module[
{fooin,epmaxlocal,result},
result=D[taugtot[epmaxlocal,epmin,epmaxlocal,1],epmaxlocal];
result//.{epmaxlocal->epmax}
];
funD[epmax_]:=Module[
{fooin,epmaxlocal,result,offset,xr,xl,tr,tl},
offset=10^(-5);
xr=epmax*(1+offset);
xl=epmax*(1-offset);
tr=taugtot[xr,epmin,xr,1];
tl=taugtot[xl,epmin,xl,1];
result=(tr-tl)/(xr-xl);
result
];

If[minmethodtau==3,
Print["minmethodtau=",minmethodtau];
solseps=0;
epmaxerror=0;
eq1diff[epmax_,epthick_]:=taugtot[epmax,epmin,epmax,epthick]-1;
eq2diff[epmax_,epthick_]:=taugg[epthick,epmin,epmax]-1;
Clear[solmintau];
solmintau=minmethod2functauhighe[eq1diff,eq2diff,-4,8,-4,8];
{solseps,epmaxerror}=solmintau;
epmaxnum=solseps[[1,2]];
epthicknum=solseps[[2,2]];

epmaxminerror=10^(30);
epmaxminnum=0;
epmaxminobs=0;
epmaxmaxerror=10^(30);
epmaxmaxnum=0;
epmaxmaxobs=0;
];

If[minmethodtau==2,
(* find min in tau *)
myminsols=FindRoot[funD[epmax]==0,{epmax,2}];
mymin=myminsols[[1,2]];
errormin=Abs[funD[mymin]];
If[errormin>10^(-1),Print["Warning: Did not find min for tau calc"];mymin=2;];

(* find root with positive derivative *)
fakeepthick=1;
startepmax=2*mymin; (* move to higher energy by factor of 2 so head towards desired root *)
solepmax=FindRoot[0==1-taugtot[x,epmin,x,fakeepthick],{x,startepmax}];
epmaxnum=solepmax[[1,2]];
depmaxnum=funD[epmaxnum];
epmaxerror=10^(30);
If[depmaxnum>0,
epmaxerror=Abs[1-taugtot[epmaxnum,epmin,epmaxnum,fakeepthick]];
];
If[depmaxnum<=0|| Abs[Re[depmaxnum]]<10^(10)*Abs[Im[depmaxnum]],
epmaxerror=10^30; (* register as not found *)
depmaxmaxnum=Abs[depmaxnum];
];
(* NOTE: Might not have found min, may have found max.  But then probably no solution anyways *)

(* find root with negative derivative on left side *)
fakeepthick=1;
startepmaxmin=mymin/2; (* move to lower energy by factor of 2 so head towards desired root *)
solepmaxmin=FindRoot[0==1-taugtot[x,epmin,x,fakeepthick],{x,startepmaxmin}];
epmaxminnum=solepmaxmin[[1,2]];
depmaxminnum=funD[epmaxminnum];
epmaxminerror=10^(30);
If[depmaxminnum<0,
epmaxminerror=Abs[1-taugtot[epmaxminnum,epmin,epmaxminnum,fakeepthick]];
];
If[depmaxminnum>=0|| Abs[Re[depmaxminnum]]<10^(10)*Abs[Im[depmaxminnum]],
epmaxminerror=10^30; (* register as not found *)
depmaxmaxnum=Abs[depmaxminnum];
];

(* find root with negative derivative on right side *)
fakeepthick=1;
startepmaxmax=10^10; (* if even higher than this, then not interesting *)
solepmaxmax=FindRoot[0==1-taugtot[x,epmin,x,fakeepthick],{x,startepmaxmax}];
epmaxmaxnum=solepmaxmax[[1,2]];
depmaxmaxnum=funD[epmaxmaxnum];
epmaxmaxerror=10^(30);
If[depmaxmaxnum<0,
epmaxmaxerror=Abs[1-taugtot[epmaxmaxnum,epmin,epmaxmaxnum,fakeepthick]];
];
If[depmaxmaxnum>=0 || Abs[Re[depmaxmaxnum]]<10^(10)*Abs[Im[depmaxmaxnum]],
epmaxmaxerror=10^30; (* register as not found *)
depmaxmaxnum=Abs[depmaxmaxnum];
];
epthicknum=fakeepthick; (* fake! *)
];


If[minmethodtau==1,
eqblob[epmax_?NumericQ,epthick_?NumericQ]:=(taugtot[epmax,epmin,epmax,epthick]-1)^2+(taugg[epthick,epmin,epmax]-1)^2;
solepmax=NMinimize[{eqblob[x,y],x>0,y>0},{x,y},MaxIterations->1000];
epmaxerror=Abs[solepmax[[1]]];
epmaxnum=solepmax[[2,1,2]];
epthicknum=solepmax[[2,2,2]];

(* dummy assignments *)
epmaxminerror=0;
epmaxminnum=0;
epmaxminobs=0;
epmaxmaxerror=0;
epmaxmaxnum=0;
epmaxmaxobs=0;
];


If[minmethodtau==0,
(* taugg[ep=epthick]==1 defines epthick *)
solepmax=FindRoot[{taugtot[epmax,epmin,epmax,epthick]==1,taugg[epthick,epmin,epmax]==1},{epmax,3},{epthick,2}];
epmaxerror=0;
epmaxnum=solepmax[[1,2]];
epthicknum=solepmax[[2,2]];

(* dummy assignments *)
epmaxminerror=0;
epmaxminnum=0;
epmaxminobs=0;
epmaxmaxerror=0;
epmaxmaxnum=0;
epmaxmaxobs=0;
];

(* epmax is highest-energy photon that can escape *)
(* epmaxobs is maximum for observed photon *)
epmaxobs=epmaxnum*gammavalue*me*c^2/ergPmev; (* MeV units *)
epmaxminobs=epmaxminnum*gammavalue*me*c^2/ergPmev; (* MeV units *)
epmaxmaxobs=epmaxmaxnum*gammavalue*me*c^2/ergPmev; (* MeV units *)
(* return *)
{epmaxerror,epmaxnum,epthicknum,epmaxobs,epmaxminerror,epmaxminnum,epmaxminobs,epmaxmaxerror,epmaxmaxnum,epmaxmaxobs}
];


(* Use ContourPlot to seek out shared root *)
minmethod2functauhighe[eq1diff_,eq2diff_,lowx_,highx_,lowy_,highy_]:=Module[
{foo,ntrials,goodpoint,triali,errorTnpairs,RELTOL,solsTtrial,lTlow,lThigh,lnpairslow,lnpairshigh,p1old,p2old,p1,p2,pickpoint,errorlT,errorlnpairs,minresult,errorpoint,MAXERROR,methodCPFR,okerrorlT,okerrorlnpairs,mynpairssol,myT,solstrial,truemynpairs},

(* set initial error as large so triggers to find solution *)
RELTOL=10^(-10);
errorTnpairs=10^30*RELTOL;
(* bad sol so easily seen when debugging if this is not set *)
solsTtrial={epmax->0,epthick->0};

ntrials=1; (* only ntrials 1 since too slow otherwise and not necessary for tauhighe *)
goodpoint=0;
For[triali=1,triali<=ntrials,
If[errorTnpairs>RELTOL,

If[triali==1,
lTlow=lowx;lThigh=highx;lnpairslow=lowy;lnpairshigh=highy;
];
(* sometimes pairs are very negligible and then temperature can be quite high *)
If[triali==2&&goodpoint==0,
Print["Trying Expanded"];lTlow=lowx-Abs[highx-lowx]/2;lThigh=highx+Abs[highx-lowx]/2;lnpairslow=lowy-Abs[highy-lowy]/2;lnpairshigh=highy+Abs[highy-lowy]/2;
p1old=p1;p2old=p2;
];
(* sometimes good point found but FindRoot not given good enough initial value *)
(* In that case, zoom-in around good point within error found already *)
If[triali==2&&goodpoint==1,Print["Trying goodpoint zoom"];lTlow=pickpoint[[1]]-Max[errorlT*2,1];lThigh=pickpoint[[1]]+Max[errorlT*2,1];lnpairslow=pickpoint[[2]]-Max[errorlnpairs*2,1];lnpairshigh=pickpoint[[2]]+Max[errorlnpairs*2,1];];

If[doprintdebug==1,Print["CP1"];];
p1=ContourPlot[0==eq1diff[10^x,10^y],{x,lTlow,lThigh},{y,lnpairslow,lnpairshigh}];
If[doprintdebug==1,Print["CP2"];];
p2=ContourPlot[0==eq2diff[10^x,10^y],{x,lTlow,lThigh},{y,lnpairslow,lnpairshigh}];
If[doprintdebug==1,Print["CPdone"];p1globaltau=p1;p2globaltau=p2;];

(* only pick point if Contour plots worked *)
If[Dimensions[p1[[1]]][[1]]>0 &&Dimensions[p2[[1]]][[1]]>0,
If[Dimensions[p1[[1,1]]][[1]]>0 &&Dimensions[p2[[1,1]]][[1]]>0,
minresult=minelement[p1,p2];
errorpoint=minresult[[2]];
MAXERROR=1; (* max overall log error which we call a good point that we can zoom in on *)
goodpoint=If[errorpoint>MAXERROR,0,1];
If[goodpoint==0,Print["No good CP point to pick: minresult",minresult]];
pickpoint=minresult[[1]];
errorlT=Abs[minresult[[7,1]]-minresult[[8,1]]];
errorlnpairs=Abs[minresult[[7,2]]-minresult[[8,2]]];

methodCPFR=2; (* 2 gets job done, 1 can be problem when one of solutions zig-zags on small scales *)

(* Only FindRoot if still kinda bad error -- dont need these to be super accurate *)
okerrorlT=0.2;
okerrorlnpairs=0.2;

If[methodCPFR==2,
(* if good enough error, then avoid Findroot and just assign *)
If[errorlT<okerrorlT && errorlnpairs<okerrorlnpairs,
myT=SetPrecision[10^pickpoint[[1]],lowestprec];
mynpairssol=SetPrecision[10^pickpoint[[2]],lowestprec];
solstrial={epmax->myT,epthick->mynpairssol};
errorTnpairs=0;
];
];(* end if methodCPFR==2 *)

(* if only 1 line, use it's epthick="lowest" case *)
If[Dimensions[p1[[1]]][[1]]>0 &&Dimensions[p1[[1,1]]][[1]]>0  && Dimensions[p2[[1]]][[1]]==0 &&Dimensions[p2[[1,1]]][[1]]==0,
epmaxes=Table[p1[[1,1,ii,1]],{ii,1,Dimensions[p1[[1,1]]][[1]]}];
mymaxes=Max[epmaxes];
myT=10^mymaxes;
mynpairssol=0;
solstrial={epmax->myT,epthick->mynpairssol};
errorTnpairs=10^(-20);
];

If[1==1,
trialepmax=0;
trialepthick=0;
If[Dimensions[p1[[1]]][[1]]>0 &&Dimensions[p1[[1,1]]][[1]]>0 ,
epmaxes=Table[p1[[1,1,ii,1]],{ii,1,Dimensions[p1[[1,1]]][[1]]}];
mymaxes=Max[epmaxes];
trialepmax=10^mymaxes;
];
If[Dimensions[p2[[1]]][[1]]>0 &&Dimensions[p2[[1,1]]][[1]]>0 ,
epmaxes=Table[p2[[1,1,ii,2]],{ii,1,Dimensions[p2[[1,1]]][[1]]}];
mymaxes=Max[epmaxes];
trialepthick=10^mymaxes;
];
myT=trialepmax;
mynpairssol=trialepthick;
solstrial={epmax->myT,epthick->mynpairssol};
errorTnpairs=10^(-25);
errorlT=-1-2*okerrorlT;
errorlnpairs=-1-2*okerrorlnpairs;
Print["Trial here ",trialepmax," ",trialepthick];
];

If[methodCPFR==1 || errorlT>okerrorlT || errorlnpairs>okerrorlnpairs,
Print["FRtau"];
solstrial=FindRoot[{eq1diff[10^x,10^y]==0,eq2diff[10^x,10^y]==0},{x,pickpoint[[1]]},{y,pickpoint[[2]]}];

myT=10^(solstrial[[1,2]]);
mynpairssol=10^(solstrial[[2,2]]);
myT=SetPrecision[myT,lowestprec];
mynpairssol=SetPrecision[mynpairssol,lowestprec];
errorTnpairs=Sqrt[Abs[eq1diff[myT,mynpairssol]^2+eq2diff[myT,mynpairssol]^2]];
];(* end if methodCPFR==1 *)

];(* end Dimension inner check *)
];(* end Dimension outer check *)


If[errorTnpairs>RELTOL ,Print["ContourPlot+FindRoot failed"," min=",errorTnpairs];];

(* don't set or print-out solution if failed to get it *)
If[errorTnpairs<RELTOL,
(* jump out of loop if got solution *)
triali=ntrials+1;
solsTtrial={epmax->myT,epthick->mynpairssol};
If[doprintdebug==1,Print["solsTtrial=",solsTtrial]];
If[doprintdebug==1,Print["errorTnpairs=",errorTnpairs]];
];(* end if <RELTOL *)

]; (* end bit outer if <RELTOL *)

triali=triali+1;
];(* end loop *)

(* return *)
{solsTtrial,errorTnpairs}
]; (* end If[useminmethod==2, *)

(* get tau table *)
taux[ii_,num_]:=Module[{xlow,xhigh},
xlow=2.001;
xhigh=3;
(* return *)
xlow + (xhigh-xlow)*(ii-1)/(num-1)
];
tauy[ii_,num_]:=Module[{lxlow,lxhigh,lresult},
lxlow=-8;
lxhigh=0;
(* return *)
lresult=lxlow + (lxhigh-lxlow)*(ii-1)/(num-1);
10^(lresult)
];
numtaui=5;
numtauj=5;
postable=Table[{taux[ii,numtaui],tauy[jj,numtauj]},{ii,1,numtaui},{jj,1,numtauj}];
MatrixForm[N[postable]]

(* e.g. *)
(*
tautable=Table[tauhighe[taux[ii,numi],tauy[jj,numj]][[4]],{ii,0,numi},{jj,0,numj}];
MatrixForm[tautable]
*)








(* Overall procedure *)
(*doprintdebug=0;*) (* default: whether to print debug info: 0 or 1 *)
gammajetreconnectionall1:=Module[
{foo,npairsnum,damptauiter,numdamptauiter},
(* call reconnection functions *)
If[doprintdebug==1,Print["Start gammajetreconnectionall1"];];

(* Setup jet values: doesn't need to be iterated upon and would be slow to do so and so avoid *)
setupvalues;
If[doprintdebug==1,Print["after setupvalues"];];
(* setup iteration guesses *)
setupiterguesses;
If[doprintdebug==1,Print["after setupiterguesses"];];

(* iterate over part of solution that is required to get T,npairs *)
numiterations=1; (* NEW: T and npairs are solved for and that's all that is required for iteration for plasma computations *)
For[overalliteration=1,overalliteration<=numiterations,
If[doprintdebug==1,Print["overalliteration"];Print[overalliteration];];

 (* gets functions now which are dependent on all indep vars *)
getfullPUNQ;
If[doprintdebug==1,Print["after getfullUPNQ"];];

(* iterate beyond initial guess *)
overalliteration++;
];

(* store numerical values for some quantities now that have T and npairs *)
getradnums;
If[doprintdebug==1,Print["after getradnums"];];


(* iterate over plasma quantities: netotforomegape, etc. that do not change T,npairs *)
numiterations=20; (* number of iterations for getting plasma things converged *)
(* things ITERATED that can check to see if need to keep iterating on them *)
netotforomegapeold=netotforomegape;
gammaeold=gammae;
RELTOLPLASMA=10^(-3);

For[overalliteration=1,overalliteration<=numiterations,
If[doprintdebug==1,Print["overalliteration"];Print[overalliteration];];

computeplasmastuff;
If[doprintdebug==1,Print["after computeplasmastuff"];];
(*OLD code: gettemperature;If[doprintdebug==1,Print["after gettemperature"];];*)
gettaualongjet;
If[doprintdebug==1,Print["after taualongjet"];];
reportpressure;
If[doprintdebug==1,Print["after reportpressure"];];
getDelta;
If[doprintdebug==1,Print["after getDelta"];];
getlarmor;
If[doprintdebug==1,Print["after getlarmor"];];
getDeltasp;
If[doprintdebug==1,Print["after getDeltasp"];];
(*getDeltasprel;*)
(*getDeltasprelum10;*)
getDeltasprelorig;
If[doprintdebug==1,Print["after getDeltasprel"];];
getconditione;
If[doprintdebug==1,Print["after getconditione"];];
getconditionp;
If[doprintdebug==1,Print["after getconditionp"];];
(* below gets new taubet *)
gettaus;
If[doprintdebug==1,Print["after gettaus"];];

(*OLD: store iterated quantities for diagnotic *)
(* npairs netotforomegape gammae Hsca Habs solsT myT Tc Tout myie myu4vel myb *)
(*npairsnum=npairs//.solsT;*)
(*itercheckiter[[overalliteration]]={npairsnum, netotforomegape, gammae, Hsca, Habs, solsT, solsTrad, myie, myu4vel, myb,Q0ff,Q0synch,tauradscanum,tauradabsnum};*)

(* see if really need to keep iterating on plasma terms *)
errorplasma=0;
(* compute errors *)
relerr1=(netotforomegape-netotforomegapeold)/netotforomegapeold;
relerr2=(gammae-gammaeold)/gammaeold;
(* set new to old -- assumes converging towards solution! *)
netotforomegapeold=netotforomegape;
gammaeold=gammae;
(* check errors *)
errorplasma=errorplasma+If[relerr1<RELTOLPLASMA,0,1];
errorplasma=errorplasma+If[relerr2<RELTOLPLASMA,0,1];
If[doprintdebug==1,Print["errorplasma=",errorplasma," ","netotforomegape=",SetPrecision[netotforomegape,5]," ","gammae=",SetPrecision[gammae,5]];];
If[errorplasma==0,overalliteration=numiterations;]; (* jump out of loop if already converged *)

(* iterate beyond initial guess *)
overalliteration++;
];


If[doprintdebug==1,Print["Computing Non-Iterated Quantities"];];
(* things not part of ANY iteration but reported once converged solution already obtained *)
(* not needed *)
(*
gettimeann;
If[doprintdebug==1,Print["after gettimeann"];];
*)
getTobs;
If[doprintdebug==1,Print["after getTobs"];];
getTdiffs;
If[doprintdebug==1,Print["after getTdiffs"];];
getdtobs;
If[doprintdebug==1,Print["after getdtobs"];];
getidealValidity;
If[doprintdebug==1,Print["after getidealValidity"];];

getfinalnum;
If[doprintdebug==1,Print["after getfinalnum"];];
{myalphasp,myepmin,myeminobsMeV}=setupalphaepmin;
{epmaxerror,epmaxnum,epthicknum,epmaxobs,epmaxminerror,epmaxminnum,epmaxminobs,epmaxmaxerror,epmaxmaxnum,epmaxmaxobs}=tauhighe[myalphasp,myeminobsMeV];
If[doprintdebug==1,Print["after tauhighe"];];


(* Some results reports *)
If[doprintdebug==1,Print[" "];];

If[doprintdebug==1 && bgaussrad/Bc>=0.01,Print["QED Matters", " bgaussrad/Bc=",bgaussrad/Bc];];

If[doprintdebug==1 && conditionpt>=1,Print["FAST RECONNECTION", " conditionpt=",conditionpt];];
If[doprintdebug==1 && conditionpt<1,Print["SLOW RECONNECTION", " conditionpt=",conditionpt];];

If[doprintdebug==1 && etanumcenterrad>=1,Print["Degenerate pairs&electrons"," etanumcenterrad=",etanumcenterrad];];
If[doprintdebug==1 && etanumcenterrad<1,Print["Non-Degenerate pairs&electrons"," etanumcenterrad=",etanumcenterrad];];

If[doprintdebug==1,Print["etasim=",etanumcenternorm," etanumcenternormtrue=",etanumcenternormtrue];];

If[doprintdebug==1,Print["npairs0num=",npairs0num," npairs0true=",npairs0true," npairs0truetrue=",npairs0truetrue," npairs0qednum=",npairs0qednum];];
If[doprintdebug==1,Print["Upairs0num=",Upairs0num," Upairs0true=",Upairs0true," Upairs0truetrue=",Upairs0truetrue," Upairs0qednum=",Upairs0qednum];];
If[doprintdebug==1,Print["Ppairs0num=",Ppairs0num," Ppairs0true=",Ppairs0true," Ppairs0truetrue=",Ppairs0truetrue," Ppairs0qednum=",Ppairs0qednum];];

If[doprintdebug==1 && Qnurat>0.1,Print["Neutrinos matter"," Qnurat=",Qnurat];];

If[doprintdebug==1 && epmaxerror<10^(-1),Print["Got Max Energy"," epmaxobs=",epmaxobs," epmaxerror=",epmaxerror];];
If[doprintdebug==1 && epmaxminerror<10^(-1),Print["Got Max Min Energy"," epmaxminobs=",epmaxminobs," epmaxminerror=",epmaxminerror];];
If[doprintdebug==1 && epmaxmaxerror<10^(-1),Print["Got Max Max Energy"," epmaxmaxobs=",epmaxmaxobs," epmaxmaxerror=",epmaxmaxerror];];


];












